{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introl\u7684\u4e2a\u4eba\u77e5\u8bc6\u5e93","text":""},{"location":"#_1","title":"\u7b80\u4ecb","text":"<p>\u672c\u77e5\u8bc6\u5e93\u7528\u4e8eIntrol\u7684\u4e2a\u4eba\u603b\u7ed3\uff0c\u6db5\u76d6\u4fe1\u606f\u5b66\u7ade\u8d5b\uff08OI\uff09\u3001\u5355\u7247\u673a\u3001NAS\u642d\u5efa\u3001\u9ad8\u4e2d\u6587\u5316\u8bfe\u3001\u6570\u5b66\u3001\u7f51\u7edc\u6280\u672f\u3001\u6587\u5b66\u3001\u82f1\u8bed\u3001\u9605\u8bfb\u7b49\u591a\u4e2a\u9886\u57df\uff0c\u7528\u4e8e\u6784\u5efa\u7ed3\u6784\u5316\u7684\u77e5\u8bc6\u4f53\u7cfb\uff0c\u8f85\u52a9\u5b66\u4e60\u3002\u540c\u65f6\u4e5f\u4e3a\u5176\u4ed6\u60f3\u8981\u642d\u5efa\u4e2a\u4eba\u77e5\u8bc6\u5e93\u7684\u540c\u5b66\u63d0\u4f9b\u53c2\u8003\u548c\u5efa\u8bae\u3002</p> <p>\u672c\u77e5\u8bc6\u5e93\u4f1a\u6301\u7eed\u66f4\u65b0\u3002</p>"},{"location":"#about-introl","title":"\u5173\u4e8e\u6211/About Introl","text":"<p>Introl | INTP | SX | \u9ad8\u4e00 | OIer | \u79d1\u6280\u7231\u597d\u8005</p>"},{"location":"#_2","title":"\u5f53\u524d\u76ee\u6807\uff1a","text":"<p>NOIp\u7701\u4e00 | \u8fdb\u961f</p>"},{"location":"#_3","title":"\u8054\u7cfb\u6211\uff1a","text":"<p>\u200b   mail\uff1aintrol-ljl@qq.com / introlljl@gmail.com</p> <p>\u200b   Wechat\uff1aIntrol-ljl</p> <p>\u200b   QQ\uff1a3226749226</p>"},{"location":"#_4","title":"\u5feb\u901f\u5bfc\u822a","text":"\u5206\u7c7b \u7b80\u4ecb OI \u5173\u4e8e\u4fe1\u606f\u5b66\u5965\u6797\u5339\u514b\u7ade\u8d5b\uff08OI\uff09\u76f8\u5173\u7684\u77e5\u8bc6\u5185\u5bb9 \u9ad8\u4e2d\u6587\u5316\u8bfe \u5173\u4e8e\u9ad8\u4e2d\u7406\u79d1\u6587\u5316\u8bfe\u76f8\u5173\u77e5\u8bc6\u5185\u5bb9 \u5355\u7247\u673a \u5173\u4e8eSTM32\u53caESP32\u7b49\u5355\u7247\u673a\u76f8\u5173\u7684\u77e5\u8bc6\u5b9e\u8df5\u5185\u5bb9 NAS \u5173\u4e8e\u7fa4\u6656NAS\u7cfb\u7edf\u7684\u76f8\u5173\u6587\u6863\u4ee5\u53ca\u73a9\u6cd5\u64cd\u4f5c \u82f1\u8bed \u5173\u4e8e\u82f1\u8bed\u5b66\u4e60\u63d0\u5347\u7684\u76f8\u5173\u77e5\u8bc6 \u6587\u5b66 \u5173\u4e8e\u9605\u8bfb\uff0c\u6587\u5b66\u9274\u8d4f\u7b49\u65b9\u9762\u7684\u5185\u5bb9 \u5176\u4ed6 \u5176\u4ed6\u6570\u91cf\u7e41\u591a\u4f46\u4e0d\u8db3\u4ee5\u5355\u72ec\u5206\u7c7b\u7684\u77e5\u8bc6\u5185\u5bb9"},{"location":"#_5","title":"\u5185\u5bb9\u76f8\u5173","text":"<p>\u672c\u6587\u6863\u5168\u90e8\u4f7f\u7528 Markdown&amp;LeTeX\u683c\u5f0f\uff0c\u652f\u6301\u8de8\u6587\u4ef6\u8df3\u8f6c\u3002\u77e5\u8bc6\u5e93\u5b8c\u6210\u8fc7\u7a0b\u4e2d\u90e8\u5206\u5185\u5bb9\u5f15\u7528\u4ed6\u4eba\u5f00\u6e90\u5185\u5bb9\uff0c\u5982\u6709\u4fb5\u6743\u8bf7\u8054\u7cfb\u3002</p>"},{"location":"#_6","title":"\u66f4\u65b0\u8bb0\u5f55&amp;\u5f85\u529e\u4e8b\u9879","text":""},{"location":"#_7","title":"\u66f4\u65b0","text":"<p>2025-1-30\uff1a</p> <p>\u5f00\u59cb\u642d\u5efa\u77e5\u8bc6\u5e93\uff0c\u5b8c\u6210<code>README.md</code>\u6587\u4ef6\uff0c\u642d\u5efa\u6574\u4f53\u67b6\u6784\u3002</p> <p>2025-2-9\uff1a</p> <p>\u5b8c\u5584OI\u76f8\u5173\u7684\u90e8\u5206\u5185\u5bb9\uff0c\u8c03\u6574\u683c\u5f0f\u3002</p> <p>2025-2-18\uff1a</p> <p>\u5b9e\u73b0GoodNotes\u7b14\u8bb0\u6587\u4ef6\u7684\u540c\u6b65\u3002</p>"},{"location":"#_8","title":"\u5f85\u529e","text":"<ul> <li>\u5b8c\u5584\u5185\u5bb9</li> <li>\u5b8c\u6210OI\u76f8\u5173\u5185\u5bb9</li> <li>\u5c06\u5927\u5185\u5b58\u6587\u4ef6\u79fb\u52a8\u81f3\u4e2a\u4eba\u7f51\u76d8\u4ee5\u907f\u514dgit\u63d0\u4ea4\u901f\u5ea6\u8fc7\u6162\u4ee5\u53ca\u7a7a\u95f4\u4e0d\u8db3\u95ee\u9898\u3002</li> <li>\u5c06\u6587\u7ae0\u4e2d\u51fa\u73b0\u7684\u56fe\u7247\u7b49\u5168\u90e8\u79fb\u52a8\u81f3\u4e2a\u4eba\u56fe\u5e8a\u3002</li> </ul>"},{"location":"#_9","title":"\u7248\u6743\u4e0e\u534f\u8bae","text":""},{"location":"#_10","title":"\u4ee3\u7801","text":"<ul> <li>\u8bb8\u53ef\u534f\u8bae\uff1aApache 2.0 </li> <li>\u8981\u6c42\uff1a  </li> <li>\u4fdd\u7559\u6e90\u7801\u4e2d\u7684\u7248\u6743\u58f0\u660e  </li> <li>\u4fee\u6539\u9700\u5728\u6587\u4ef6\u5934\u6807\u6ce8\u53d8\u66f4\u8bb0\u5f55  </li> </ul>"},{"location":"#_11","title":"\u6587\u6863","text":"<ul> <li>\u8bb8\u53ef\u534f\u8bae\uff1aCC BY 4.0 </li> <li>\u8981\u6c42\uff1a  </li> <li>\u5fc5\u987b\u7f72\u540d\u4f5c\u8005  </li> <li>\u53ef\u5546\u7528\uff0c\u4f46\u7981\u6b62\u7528\u4e8e\u8fdd\u6cd5\u573a\u666f  </li> </ul>"},{"location":"#_12","title":"\u514d\u8d23\u58f0\u660e","text":"<p>\u5185\u5bb9\u90e8\u5206\u6765\u81ea\u7f51\u7edc\uff0c\u5982\u6709\u4fb5\u6743\u8bf7\u8054\u7cfb\u5220\u9664\u3002 \u4f5c\u8005\u4e0d\u5bf9\u56e0\u4f7f\u7528\u672c\u4ed3\u5e93\u5185\u5bb9\u5bfc\u81f4\u7684\u4efb\u4f55\u76f4\u63a5\u6216\u95f4\u63a5\u635f\u5931\u8d1f\u8d23\u3002</p>"},{"location":"NAS/","title":"NAS","text":""},{"location":"NAS/#_1","title":"\u7b80\u4ecb","text":"<p>\u5173\u4e8e\u7fa4\u6656NAS\u7684\u7528\u6cd5\uff0cdocker\u5bb9\u5668\u5185\u5bb9\uff0c\u90e8\u7f72\u65b9\u5f0f\uff0c\u4ee5\u53ca\u8f6f\u8def\u7531\u7684\u90e8\u7f72\u548c\u7f51\u7edc\u62d3\u6251\u76f8\u5173\u77e5\u8bc6</p>"},{"location":"NAS/#docker","title":"docker","text":""},{"location":"NAS/#_2","title":"\u7f51\u7edc","text":""},{"location":"NAS/#_3","title":"\u89c2\u5f71","text":""},{"location":"NAS/#_4","title":"\u6587\u4ef6\u5b58\u50a8","text":""},{"location":"NAS/#_5","title":"\u9879\u76ee","text":""},{"location":"OI/OI_README/","title":"OI/OI Knowledge Base","text":""},{"location":"OI/OI_README/#_1","title":"\u7b80\u4ecb","text":"<p>Introl\u4e2a\u4eba\u7684OI\u77e5\u8bc6\u5e93\uff0c\u5305\u542b\u4e2a\u4eba\u6a21\u677f\u3001\u7b97\u6cd5\u6587\u7ae0\u3001\u9898\u89e3\u96c6\u5408\u3001\u8bad\u7ec3\u8ba1\u5212\u3001\u5b9e\u7528\u5de5\u5177&amp;\u6280\u5de7\u548c\u4e2a\u4eba\u603b\u7ed3\u516d\u5927\u677f\u5757\uff0c\u6301\u7eed\u66f4\u65b0\u4e2d\u3002</p>"},{"location":"OI/OI_README/#_2","title":"\u4e2a\u4eba\u6a21\u677f","text":"<p>\u4e2a\u4eba\u6a21\u677f_README</p> <p>\u8fd9\u91cc\u662fIntrol\u7684\u4e2a\u4eba\u6a21\u677f\uff0c\u5305\u542b\u5927\u91cfOI\u4e2d\u5e38\u7528\u7684\u7b97\u6cd5\u3001\u6570\u636e\u7ed3\u6784\u3001\u52a8\u6001\u89c4\u5212\u7b49\u7684\u6a21\u677f\u3002</p>"},{"location":"OI/OI_README/#_3","title":"\u7b97\u6cd5\u6587\u7ae0","text":"<p>\u7b97\u6cd5\u6587\u7ae0_README</p> <p>\u8fd9\u91cc\u6709Introl\u5199\u7684\u5404\u79cd\u7b97\u6cd5\u76f8\u5173\u6587\u7ae0\uff0c\u5305\u62ec\u7b97\u6cd5\u3001\u6570\u636e\u7ed3\u6784\u7b49\u77e5\u8bc6\u70b9\u3002\u9664\u6b64\u4e4b\u5916\u8fd8\u5305\u62ec\u4e00\u4e9b\u8457\u540d\u6559\u5e08\u7684\u7b97\u6cd5\u8bb2\u89e3\u8bfe\u4ef6\u548cPDF\u3002</p>"},{"location":"OI/OI_README/#_4","title":"\u9898\u89e3\u96c6\u5408","text":"<p>\u9898\u89e3\u96c6\u5408_README</p> <p>\u8fd9\u91cc\u662f\u5b66\u4e60\u8fc7\u7a0b\u4e2d\u7684\u9898\u89e3\u4ee5\u53caodeforces/NOIp\u7b49\u6bd4\u8d5b\u7684\u590d\u76d8\u548c\u8865\u9898\u3002</p>"},{"location":"OI/OI_README/#_5","title":"\u8bad\u7ec3\u8ba1\u5212","text":""},{"location":"OI/OI_README/#7","title":"\u77ed\u671f\uff087\u5929\uff09","text":""},{"location":"OI/OI_README/#2025-3-142025-3-23","title":"2025-3-14~2025-3-23\uff1a","text":"<p>2025SX\u7701\u9009\u8865\u9898\uff0c\u590d\u76d82024\u5e74OI\u8fdb\u5c55\uff0c\u67e5\u7f3a\u8865\u6f0f\uff0c\u5b8c\u5584\u57fa\u7840OI\u77e5\u8bc6\u5e93\u3002</p>"},{"location":"OI/OI_README/#_6","title":"\u957f\u671f","text":""},{"location":"OI/OI_README/#36","title":"3~6\u6708","text":"<p>\u67e5\u7f3a\u8865\u6f0f\uff0c\u590d\u4e60\u65e7\u77e5\uff0c\u8fc7\u7a0b\u4e2d\u5927\u91cf\u5237\u9898\u3002\u9884\u8ba1\u603b\u505a\u9898\u6570\u8fbe\u52301000+\u3002</p>"},{"location":"OI/OI_README/#78","title":"7~8\u6708","text":"<p>\u5916\u51fa\u96c6\u8bad&amp;\u5b66\u4e60\u65b0\u77e5\u3002\u5237\u9898\u4efb\u52a1\u503e\u5411\u4e8e\u84dd\u9898+\u3002\u9884\u8ba1\u84dd\u9898\u4ee5\u4e0a\u5237\u9898\u91cf\u8fbe\u5230300+\u3002</p>"},{"location":"OI/OI_README/#911","title":"9~11\u6708","text":"<p>\u5f00\u59cb\u8fdb\u5165\u65b0\u8d5b\u5e74\uff0c\u505c\u6b62\u5b66\u4e60\u65b0\u77e5\uff0c\u91cd\u70b9\u503e\u5411\u4e8e\u5237\u9898\uff0c\u9884\u8ba1\u603b\u505a\u9898\u6570\u8d85\u8fc72000+\u4e14\u7d2b\u9ed1\u9898\u91cf\u8fbe\u5230500+\u3002</p>"},{"location":"OI/OI_README/#_7","title":"\u5b9e\u7528\u5de5\u5177&amp;\u6280\u5de7","text":""},{"location":"OI/OI_README/#_8","title":"\u5de5\u5177\u7c7b","text":""},{"location":"OI/OI_README/#_9","title":"\u4ee3\u7801\u7f16\u5199\u5de5\u5177","text":"<p>PS:\u8fd9\u91cc\u53ea\u4f1a\u63d0\u5230\u7f16\u8005\u7528\u8fc7\u7684\uff0c\u5bf9\u4e8e\u5176\u4ed6\u6ca1\u6709\u4f7f\u7528\u8fc7\u7684IDE\u4e0d\u505a\u8bc4\u4ef7\uff0c\u5efa\u8bae\u67e5\u8be2OI-Wiki\u4e86\u89e3[^1]\u3002</p> <ol> <li> <p>DEV-C++\uff1a\u6bd4\u8d5bWindows\u73af\u5883\u9ed8\u8ba4IDE\uff0c\u8fc7\u4e8e\u8001\u65e7\uff0c\u4e0d\u652f\u6301\u4ee3\u7801\u8865\u5168\u7b49\u9ad8\u7ea7\u529f\u80fd\uff0c\u53ea\u9002\u5408\u5165\u95e8\u3002</p> </li> <li> <p>\u5c0f\u718a\u732bC++\uff1a\u5c0f\u718a\u732bC++\u662f\u56fd\u5185\u5f00\u53d1\u8005royqh1979\u51fa\u4e8e\u6559\u80b2\u9700\u8981\u5f00\u53d1\u7684DEVC++\u5206\u652f\uff0c\u9664\u4e86\u63d0\u4f9b\u548c Dev-C++ \u76f8\u4f3c\u4f46\u66f4\u52a0\u5b8c\u5584\u7684\u5355\u6587\u4ef6\u7f16\u8bd1\u3001\u8c03\u8bd5\u3001\u8bed\u6cd5\u9ad8\u4eae\u3001\u641c\u7d22/\u66ff\u6362\u7b49\u529f\u80fd\u5916\uff0c\u8fd8\u63d0\u4f9b\u4e86\u8bf8\u5982 \u6697\u8272\u4e3b\u9898\u3001\u4ee3\u7801\u667a\u80fd\u63d0\u793a\u3001\u53d8\u91cf/\u51fd\u6570\u91cd\u547d\u540d\u3001\u5207\u6362/\u81ea\u52a8\u8bc6\u522b\u6587\u4ef6\u7f16\u7801 \u7b49\u73b0\u4ee3 IDE \u5e38\u89c1\u7684\u57fa\u672c\u529f\u80fd\u3002\u6b64\u5916\u5c0f\u718a\u732b C++ \u8fd8\u5177\u5907\u4e0e CP Editor \u7c7b\u4f3c\u7684\u8bd5\u9898\u96c6\u529f\u80fd\uff0c\u53ef\u4ee5\u81ea\u884c\u7f16\u5199\u6216 \u4ece\u5e38\u89c1\u7684 OJ \u7ade\u8d5b\u7f51\u7ad9\u4e0a\u4e0b\u8f7d\u8bd5\u9898\u6837\u4f8b\uff0c\u81ea\u52a8\u8fd0\u884c\u548c\u6d4b\u8bd5\u7a0b\u5e8f\u3002[^2]</p> </li> <li> <p>VScode\uff1a\uff08\u7f16\u8005\u63a8\u8350\uff09VScode\u662f\u5fae\u8f6f\u5f00\u53d1\u7684\u9002\u7528\u4e8eWindows\u3001Mac\u548cLinux\u7684\u5f00\u6e90\u8f7b\u91cf\u4ee3\u7801\u7f16\u8f91\u5668\uff0c\u62e5\u6709\u4e30\u5bcc\u7684\u6269\u5c55\u751f\u6001\u7cfb\u7edf\uff0c\u5728\u5b89\u88c5\u63d2\u4ef6\u7684\u524d\u63d0\u4e0b\u5341\u5206\u9002\u5408\u7ade\u8d5b\u5b66\u4e60\u3002\u4f46\u5728NOI-Linux\uff08\u6bd4\u8d5b\u73af\u5883\uff09\u4e2d\uff0cVScode\u65e0\u6cd5\u4f7f\u7528\u63d2\u4ef6\uff0c\u5bfc\u81f4\u4e0d\u652f\u6301\u9ad8\u7ea7\u7684\u4ee3\u7801\u8865\u5168\u529f\u80fd\u3002\u4f46\u5bf9\u4e8e\u5e73\u65f6\u4f7f\u7528VScode\u7684\u540c\u5b66\u8fd8\u662f\u5341\u5206\u53cb\u597d\u7684\u3002</p> </li> <li> <p>CP-Editor\uff1a\u4e13\u4e3a\u7b97\u6cd5\u7ade\u8d5b\u8bbe\u8ba1\uff0c\u4e0d\u50cf\u5176\u5b83 IDE \u4e3b\u8981\u662f\u4e3a\u4e86\u5f00\u53d1\u8bbe\u8ba1\u7684\u3002\u5b83\u53ef\u4ee5\u5e2e\u52a9\u4f60\u81ea\u52a8\u5316\u7f16\u8bd1\u3001\u8fd0\u884c\u3001\u6d4b\u8bd5\uff0c\u4ece\u800c\u8ba9\u4f60\u4e13\u6ce8\u4e8e\u7b97\u6cd5\u8bbe\u8ba1\u3002\u8f83\u4e3a\u63a8\u8350\u3002\uff08\u4f46\u7f16\u8005\u4e0d\u559c\u6b22\u7528\uff08\uff08\u3002</p> </li> </ol>"},{"location":"OI/OI_README/#_10","title":"\u8f85\u52a9\u63d2\u4ef6","text":"<ol> <li>CPH\uff08Competitive Programming Helper\uff09\uff1a \u7ade\u4e89\u7f16\u7a0b\u52a9\u624b\uff08Competitive Programming Helper, CPH\uff09\u662f\u4e00\u4e2a\u4e3a\u7ade\u4e89\u7f16\u7a0b\u8bbe\u8ba1\u7684VS Code\u6269\u5c55\u3002\u5b83\u80fd\u591f\u5e2e\u52a9\u7528\u6237\u5feb\u901f\u7f16\u8bd1\u3001\u8fd0\u884c\u548c\u8bc4\u5224\u7ade\u4e89\u7f16\u7a0b\u95ee\u9898\uff0c\u81ea\u52a8\u4e0b\u8f7d\u6d4b\u8bd5\u7528\u4f8b\uff0c\u6216\u8005\u7f16\u5199\u548c\u6d4b\u8bd5\u81ea\u5df1\u7684\u95ee\u9898\u3002\u5b8c\u6210\u540e\uff0c\u7528\u6237\u53ef\u4ee5\u901a\u8fc7\u70b9\u51fb\u6309\u94ae\u8f7b\u677e\u63d0\u4ea4\u89e3\u51b3\u65b9\u6848\u3002CPH\u652f\u6301\u591a\u4e2a\u6d41\u884c\u7684\u5e73\u53f0\uff0c\u5982Codeforces\u3001Codechef\u3001TopCoder\u7b49\uff0c\u5e76\u4e14\u9700\u8981\u914d\u5408Competitive Companion\u6d4f\u89c8\u5668\u6269\u5c55\u4f7f\u7528\u3002 [^3]</li> <li>OJBetter\uff1aOJBetter \u662f\u4e00\u4e2a Tampermonkey \u811a\u672c\u9879\u76ee\uff0c\u65e8\u5728\u63d0\u5347\u4f60\u5728\u5404\u4e2a\u5728\u7ebf\u8bc4\u6d4b\u7cfb\u7edf\uff08Online Judge, OJ\uff09\u7f51\u7ad9\u7684\u4f7f\u7528\u4f53\u9a8c\u3002\u901a\u8fc7\u6dfb\u52a0\u591a\u9879\u5b9e\u7528\u529f\u80fd\uff0c\u6539\u5584\u7f51\u7ad9\u754c\u9762\u548c\u7528\u6237\u4ea4\u4e92\uff0c\u4f7f\u4f60\u7684\u7f16\u7a0b\u7ade\u8d5b\u4e4b\u65c5\u66f4\u52a0\u9ad8\u6548\u3001\u4fbf\u6377\u3002\u652f\u6301\u9ed1\u6697\u6a21\u5f0f\u3001\u9898\u76ee\u7ffb\u8bd1\u3001Clist Rating\u7b49\u4f17\u591a\u529f\u80fd\u3002</li> <li>Carrot\uff1aCodeforces\u6bd4\u8d5bRating\u8ba1\u7b97\u63d2\u4ef6\uff0c\u672c\u5730\u8ba1\u7b97\uff0c\u53ef\u4ee5\u5e2e\u52a9\u9884\u6d4brating\u8d70\u5411\u3002</li> <li>exlg\uff1a\u6d1b\u8c37\u63d2\u4ef6\uff0c\u53ef\u4ee5\u5b9e\u73b0\u5f88\u591a\u529f\u80fd\uff0c\u662f\u6700\u597d\u7528\u7684luogu\u63d2\u4ef6\u4e4b\u4e00\u3002</li> </ol>"},{"location":"OI/OI_README/#_11","title":"\u8d44\u6e90\u94fe\u63a5","text":"<p>NOI\u5b98\u7f51\uff1a\u5168\u56fd\u9752\u5c11\u5e74\u4fe1\u606f\u5b66\u5965\u6797\u5339\u514b\u7ade\u8d5b\uff0c\u4e2d\u56fd\u4e94\u5927\u5b66\u79d1\u7ade\u8d5b\u4e4b\u4e00\u3002 codeforces\uff1a\u5168\u7403\u6700\u5927\u7684\u7f16\u7a0b\u7ade\u8d5b\u5e73\u53f0\uff0c\u4f4d\u4e8e\u4fc4\u7f57\u65af\uff0c\u4e0d\u5b9a\u65f6\u63a8\u51fa\u6bd4\u8d5b\uff08Codeforces Round\uff09\uff0c\u6bd4\u8d5b\u5206\u4e3a4\u4e2a\u7b49\u7ea7\uff0c\u62e5\u6709\u72ec\u7279\u7684Rating\u7cfb\u7edf\uff0c\u5341\u5206\u63a8\u8350\u7684\u7ec3\u4e60\u5e73\u53f0\u3002\uff08Atcoder\u7c7b\u4f3c\uff0c\u4e0d\u5355\u72ec\u8d58\u8ff0\uff09</p> <p>Luogu\uff1a\u56fd\u5185\u6700\u5927\uff0c\u77e5\u540d\u5ea6\u6700\u9ad8\u7684\u7b97\u6cd5\u7ec3\u4e60\u5e73\u53f0\uff0c\u62e5\u6709\u5927\u91cf\u7684\u4f18\u8d28\u9898\u89e3\uff0c\u662f\u5f88\u5e9e\u5927\u7684\u793e\u533a\u5e73\u53f0\uff0c\u4f46\u662f\u8fd1\u671f\uff0c\u6d1b\u8c37\u5173\u95ed\u8ba8\u8bba\u533a\u548c\u4e13\u680f\uff0c\u53ef\u80fd\u8fdb\u4e00\u6b65\u5bfc\u81f4\u6d1b\u8c37OIer\u6570\u91cf\u51cf\u5c11\u3002</p> <p>Vjudge\uff1a \u901a\u8fc7\u722c\u53d6\u5176\u4ed6OJ\u7684\u9898\u76ee\uff0c\u8ba9\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u5728VJ\u4e0a\u67e5\u627e\u5e76\u63d0\u4ea4\u5404\u79cdOJ\u7684\u9898\u76ee\uff0c\u7136\u540e\u5c06\u6211\u4eec\u7684\u9898\u76ee\u901a\u8fc7\u4ed6\u7684\u8d26\u53f7\uff0c\u5728\u771f\u6b63\u7684OJ\u4e0a\u63d0\u4ea4\u5e76\u628a\u7ed3\u679c\u53cd\u9988\u7ed9\u6211\u4eec\u3002\u53ef\u7528OJ\u5305\u62ecluogu\u3001codeforces\u3001Atcoder\u4ee5\u53ca\u5404\u5927\u9ad8\u6821OJ\uff0c\u6574\u5408\u5927\u91cf\u7684\u8d44\u6e90\u3002</p> <p>\u4e91\u5170\u9601\uff1a\u5411\u9633\u8054\u76df\u673a\u6784\u5185\u90e8\u81ea\u7528OJ[^4]</p>"},{"location":"OI/OI_README/#_12","title":"\u8003\u573a\u6280\u5de7","text":""},{"location":"OI/OI_README/#_13","title":"\u4e2a\u4eba\u603b\u7ed3","text":"<p>\u4e2a\u4eba\u603b\u7ed3_README</p> <ul> <li> <p>OI-Wiki\u76f8\u5173\u5185\u5bb9</p> </li> <li> <p>\u5f15\u7528OI-Wiki\u76f8\u5173\u6587\u672c https://oi-wiki.org/tools/editor/devcpp</p> </li> <li> <p>CPH\u7684\u4f7f\u7528\u5b89\u88c5\u6559\u7a0b https://blog.csdn.net/ros275229/article/details/141142540</p> </li> <li> <p>\u4e91\u5170\u9601OJ\u5b98\u65b9\u6587\u6863\uff1a\u4e91\u5170\u9601\u98df\u7528\u624b\u518c</p> </li> </ul>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF_README/","title":"\u4e2a\u4eba\u6a21\u677f","text":"<p>\u8fd9\u91cc\u662fIntrol\u7684\u4e2a\u4eba\u6a21\u677f\uff0c\u5305\u542b\u5927\u91cfOI\u4e2d\u5e38\u7528\u7684\u7b97\u6cd5\u3001\u6570\u636e\u7ed3\u6784\u3001\u52a8\u6001\u89c4\u5212\u7b49\u7684\u6a21\u677f\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF_README/#_2","title":"\u603b\u8d44\u6599","text":"<p>\u6765\u81ea@EBeason\u7684\u5e38\u7528\u6a21\u677f</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF_README/#_3","title":"\u7f3a\u7701\u6e90","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF_README/#_4","title":"\u56fe\u8bba","text":"<p>Dijkstra</p> <p>\u5e76\u67e5\u96c6</p> <p>SPFA</p> <p>LCA</p> <p>Prim</p> <p>kruskal</p> <p>\u4e8c\u5206\u56fe\u6700\u5927\u5339\u914d</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF_README/#_5","title":"\u6570\u636e\u7ed3\u6784","text":"<p>\u7ebf\u6bb5\u68111</p> <p>\u7ebf\u6bb5\u68112</p> <p>\u6811\u72b6\u6570\u7ec4</p> <p>\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811</p> <p>ST\u8868</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF_README/#_6","title":"\u5b57\u7b26\u4e32","text":"<p>\u5b57\u5178\u6811</p> <p>KMP</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF_README/#_7","title":"\u6570\u8bba","text":"<p>\u5feb\u901f\u5e42</p> <p>\u8d28\u6570\u7b5b</p> <p>\u7ec4\u5408\u6570</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/","title":"\u603b\u8d44\u6599","text":"<ul> <li>\u6742\u9879<ul> <li>$O2$ \u4f18\u5316</li> <li>\u9ad8\u7cbe\u5ea6</li> <li>\u54c8\u5e0c<ul> <li>\u5355\u54c8\u5e0c</li> </ul> </li> <li>Mod\u7f51\u8d5b</li> <li>\u666e\u901a\u83ab\u961f</li> <li>\u6837\u4f8b #1<ul> <li>\u6837\u4f8b\u8f93\u5165 #1</li> <li>\u6837\u4f8b\u8f93\u51fa #1</li> </ul> </li> <li>\u6811\u4e0a\u83ab\u961f</li> <li>\u6574\u4f53\u4e8c\u5206<ul> <li>[\u56fd\u5bb6\u96c6\u8bad\u961f]\u77e9\u9635\u4e58\u6cd5<ul> <li>\u9898\u76ee\u63cf\u8ff0</li> <li>\u8f93\u5165\u683c\u5f0f</li> <li>\u8f93\u51fa\u683c\u5f0f</li> <li>\u6837\u4f8b #1         - \u6837\u4f8b\u8f93\u5165 #1</li> <li>\u6837\u4f8b\u8f93\u51fa #1</li> <li>\u6570\u636e\u89c4\u6a21\u4e0e\u7ea6\u5b9a</li> </ul> </li> </ul> </li> <li>cdq\u5206\u6cbb<ul> <li>\u3010\u6a21\u677f\u3011\u4e09\u7ef4\u504f\u5e8f\uff08\u964c\u4e0a\u82b1\u5f00\uff09</li> </ul> </li> <li>KD-Tree</li> <li>\u5e76\u67e5\u96c6</li> <li>\u5e26\u6743\u5e76\u67e5\u96c6<ul> <li>\u9898\u89e3</li> </ul> </li> <li>\u79bb\u6563\u5316</li> <li>\u624b\u6253\u961f\u5217</li> <li>\u70b9\u5206\u6cbb<ul> <li>\u3010\u6a21\u677f\u3011\u70b9\u5206\u6cbb1<ul> <li>\u9898\u76ee\u63cf\u8ff0</li> <li>\u8f93\u5165\u683c\u5f0f</li> <li>\u8f93\u51fa\u683c\u5f0f<ul> <li>\u6570\u636e\u89c4\u6a21\u4e0e\u7ea6\u5b9a\u3002</li> </ul> </li> </ul> </li> </ul> </li> <li>\u6811\u4e0a\u542f\u53d1\u5f0f\u5408\u5e76</li> </ul> </li> <li>\u6570\u636e\u7ed3\u6784<ul> <li>ST \u8868</li> <li>FHQ-treap<ul> <li>\u5e73\u8861\u6811\u7ef4\u62a4Hash</li> <li>\u666e\u901a\u5e73\u8861\u6811<ul> <li>\u6dfb\u70b9</li> <li>\u5408\u5e76</li> <li>\u5206\u88c2<ul> <li>\u666e\u901a</li> <li>\u533a\u95f4\u5206\u88c2</li> </ul> </li> </ul> </li> <li>$\\mathcal{O}(1)$\u5efa\u6811</li> <li>FHQ-Treap\u7ed9\u7f16\u53f7\u5bfb\u4f4d\u7f6e</li> </ul> </li> <li>\u3010\u6a21\u677f\u3011\u6587\u827a\u5e73\u8861\u6811\uff08Splay\uff09<ul> <li>\u9898\u76ee\u63cf\u8ff0<ul> <li>\u8f93\u5165\u683c\u5f0f</li> <li>\u8f93\u51fa\u683c\u5f0f</li> <li>\u601d\u8def</li> </ul> </li> </ul> </li> <li>\u6811\u72b6\u6570\u7ec4</li> <li>\u7ebf\u6bb5\u6811<ul> <li>Introl</li> </ul> </li> <li>\u6743\u503c\u7ebf\u6bb5\u6811</li> <li>\u6811\u94fe\u5256\u5206<ul> <li>Introl</li> </ul> </li> <li>\u3010\u6a21\u677f\u3011\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811 1\uff08\u53ef\u6301\u4e45\u5316\u6570\u7ec4\uff09<ul> <li>\u9898\u76ee\u63cf\u8ff0</li> </ul> </li> <li>\u3010\u6a21\u677f\u3011\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811 2(\u4e3b\u5e2d\u6811)</li> <li>\u53ef\u6301\u4e45\u5316\u5e76\u67e5\u96c6</li> <li>ODT</li> <li>\u3010\u6a21\u677f\u3011\u5de6\u504f\u6811\uff08\u53ef\u5e76\u5806\uff09<ul> <li>\u9898\u76ee\u63cf\u8ff0<ul> <li>\u8f93\u5165\u683c\u5f0f</li> <li>\u8f93\u51fa\u683c\u5f0f</li> </ul> </li> </ul> </li> <li>\u3010\u6a21\u677f\u3011\u53ef\u6301\u4e45\u5316\u5e73\u8861\u6811         - \u9898\u76ee\u80cc\u666f         - \u9898\u76ee\u63cf\u8ff0         - \u8f93\u5165\u683c\u5f0f         - \u8f93\u51fa\u683c\u5f0f</li> <li>\u3010\u6a21\u677f\u3011\u53ef\u6301\u4e45\u5316\u6587\u827a\u5e73\u8861\u6811         - \u9898\u76ee\u63cf\u8ff0         - \u8f93\u5165\u683c\u5f0f         - \u8f93\u51fa\u683c\u5f0f         - \u63d0\u793a</li> <li>LCA</li> <li>[Vani\u6709\u7ea6\u4f1a]\u96e8\u5929\u7684\u5c3e\u5df4 /\u3010\u6a21\u677f\u3011\u7ebf\u6bb5\u6811\u5408\u5e76<ul> <li>\u9898\u76ee\u63cf\u8ff0<ul> <li>\u8f93\u5165\u683c\u5f0f</li> <li>\u8f93\u51fa\u683c\u5f0f</li> <li>\u6837\u4f8b #1<ul> <li>\u6837\u4f8b\u8f93\u5165 #1</li> <li>\u6837\u4f8b\u8f93\u51fa #1</li> </ul> </li> <li>\u63d0\u793a<ul> <li>\u601d\u8def</li> </ul> </li> </ul> </li> </ul> </li> <li>\u3010\u6a21\u677f\u3011\u7ebf\u6bb5\u6811\u5206\u88c2<ul> <li>\u9898\u76ee\u63cf\u8ff0<ul> <li>\u8f93\u5165\u683c\u5f0f</li> <li>\u8f93\u51fa\u683c\u5f0f</li> <li>\u6837\u4f8b #1<ul> <li>\u6837\u4f8b\u8f93\u5165 #1</li> <li>\u6837\u4f8b\u8f93\u51fa #1</li> </ul> </li> </ul> </li> </ul> </li> <li>\u6811\u5957\u6811<ul> <li>1.\u7ebf\u6bb5\u6811\u5957FHQ-treap<ul> <li>\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09</li> <li>\u9898\u76ee\u63cf\u8ff0</li> <li>\u8f93\u5165\u683c\u5f0f</li> <li>\u8f93\u51fa\u683c\u5f0f</li> </ul> </li> <li>2.\u6811\u72b6\u6570\u7ec4\u5957\u4e3b\u5e2d\u6811<ul> <li>\u9898\u76ee\u63cf\u8ff0</li> </ul> </li> <li>\u6743\u503c\u7ebf\u6bb5\u6811\u5957\u6743\u503c\u7ebf\u6bb5\u6811(\u4e8c\u7ef4\u5355\u70b9\u4fee\u6539\uff0c\u77e9\u5f62\u67e5\u8be2)</li> </ul> </li> <li>\u3010\u6a21\u677f\u3011\u52a8\u6001\u6811\uff08Link Cut Tree\uff09<ul> <li>\u9898\u76ee\u63cf\u8ff0</li> <li>\u8f93\u5165\u683c\u5f0f</li> <li>\u8f93\u51fa\u683c\u5f0f</li> <li>\u6837\u4f8b #1<ul> <li>\u6837\u4f8b\u8f93\u5165 #1</li> <li>\u6837\u4f8b\u8f93\u51fa #1</li> </ul> </li> <li>\u6837\u4f8b #2<ul> <li>\u6837\u4f8b\u8f93\u5165 #2</li> <li>\u6837\u4f8b\u8f93\u51fa #2</li> </ul> </li> <li>\u7ef4\u62a4\u5b50\u6811\u5927\u5c0f</li> <li>\u65e0makeroot</li> <li>\u4e58\u6cd5\u52a0\u6cd5\u6df7\u5408</li> </ul> </li> <li>K-D Tree<ul> <li>\u7b80\u5355\u9898<ul> <li>\u9898\u76ee\u63cf\u8ff0</li> <li>\u8f93\u5165\u683c\u5f0f</li> <li>\u8f93\u51fa\u683c\u5f0f</li> <li>\u6837\u4f8b #1<ul> <li>\u6837\u4f8b\u8f93\u5165 #1</li> <li>\u6837\u4f8b\u8f93\u51fa #1</li> </ul> </li> <li>\u63d0\u793a</li> </ul> </li> </ul> </li> </ul> </li> <li>\u6570\u8bba<ul> <li>sqrt\u6c42\u6839\u53f7</li> <li>\u8d28\u6570\u7b5b</li> <li>exgcd\u6c42\u9006\u5143</li> <li>\u7ec4\u5408\u6570</li> <li>\u3010\u6a21\u677f\u3011\u6269\u5c55\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\uff08EXCRT\uff09         - \u9898\u76ee\u63cf\u8ff0         - \u8f93\u5165\u683c\u5f0f         - \u8f93\u51fa\u683c\u5f0f         - \u6837\u4f8b #1             - \u6837\u4f8b\u8f93\u5165 #1             - \u6837\u4f8b\u8f93\u51fa #1         - \u63d0\u793a         - \u9898\u89e3\uff1a</li> <li>\u3010\u6a21\u677f\u3011Pollard-Rho\u7b97\u6cd5</li> </ul> </li> <li>\u5b57\u7b26\u4e32<ul> <li>Trie</li> <li>kmp</li> <li>Manacher</li> <li>\u3010\u6a21\u677f\u3011\u6269\u5c55 KMP\uff08Z \u51fd\u6570\uff09<ul> <li>\u9898\u76ee\u63cf\u8ff0</li> <li>\u8f93\u5165\u683c\u5f0f</li> </ul> </li> <li>\u540e\u7f00\u6570\u7ec4</li> <li>\u3010\u6a21\u677f\u3011\u540e\u7f00\u81ea\u52a8\u673a\uff08SAM\uff09         - \u9898\u76ee\u63cf\u8ff0         - \u8f93\u5165\u683c\u5f0f         - \u8f93\u51fa\u683c\u5f0f         - \u6837\u4f8b #1             - \u6837\u4f8b\u8f93\u5165 #1             - \u6837\u4f8b\u8f93\u51fa #1<ul> <li>\u540e\u7f00\u81ea\u52a8\u673a(SAM)</li> <li>EXSAM</li> <li>\u6700\u957f\u516c\u5171\u5b50\u4e32</li> </ul> </li> <li>\u56de\u6587\u81ea\u52a8\u673a\uff08\u56de\u6587\u6811\uff09</li> <li>AC\u81ea\u52a8\u673a(ACM)</li> </ul> </li> <li>\u56fe\u8bba<ul> <li>tarjan</li> <li>\u6a21\u677f\u3011\u5355\u6e90\u6700\u77ed\u8def\u5f84\uff08\u6807\u51c6\u7248\uff09</li> <li>EK\u8d39\u7528\u6d41\u5904\u7406\u8d1f\u73af</li> <li>\u6700\u5927\u6d41\uff08dinic\uff09</li> <li>\u8d39\u7528\u6d41</li> <li>2-SAT</li> </ul> </li> <li>dp<ul> <li>\u659c\u7387\u4f18\u5316</li> </ul> </li> <li>\u8ba1\u7b97\u51e0\u4f55         - \u4e8c\u7ef4\u51f8\u5305         - \u4e24\u76f4\u7ebf\u4ea4\u70b9         - \u5224\u65ad\u5728\u51f8\u5305\u5185         - \u591a\u8fb9\u5f62\u9762\u79ef         - \u5224\u65ad\u5706\u548c\u7ebf\u6bb5\u6709\u51e0\u4e2a\u4ea4\u70b9         - \u534a\u5e73\u9762\u4ea4         - \u65cb\u8f6c\u5361\u58f3         - \u95f5\u53ef\u592b\u65af\u57fa\u548c</li> </ul>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_1","title":"\u6742\u9879","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#o2","title":"$O2$ \u4f18\u5316","text":"<pre><code>#pragma GCC optimize(1, 2, 3, \"Ofast\", \"inline\")\n\nif ((ed - st) / CLOCKS_PER_SEC &gt;= 0.9) break;\n\nios::sync_with_stdio(0);\ncin.tie(0);\n\nwindos: -std=c++17 -Wl,--stack=1024000000     \nlinux: ulimit -s unlimited  \n\nll qread_tmp;\n#define read() qread(qread_tmp)\ntemplate&lt;class T&gt;\ninline T qread(T &amp;sum) {\n    sum=0;int boo=1;\n    char x=getchar();\n    while(x&lt;'0'||x&gt;'9'){if(x=='-')boo=-1;x=getchar();}\n    while(x&gt;='0'&amp;&amp;x&lt;='9'){sum=(sum&lt;&lt;1)+(sum&lt;&lt;3)+x-'0';x=getchar();}\n    sum*=boo;\n    return sum;\n}\ntemplate&lt;class T&gt;\nvoid qput(T x) {\n    if(x&lt;0) {x=-x;putchar('-');}\n    if(x&gt;9) qput(x/10);\n    putchar(x%10+48);\n}\n\n\n\nnamespace IN {\n    const int MAXN_INPUT = 1000000;\n    #define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + inbuf -&gt; sgetn(buf, MAXN_INPUT), p1 == p2) ? EOF : *p1++)\n    char buf[MAXN_INPUT], *p1, *p2;\n    template &lt;typename T&gt; inline bool qread(T &amp;x) {\n        static std::streambuf *inbuf = cin.rdbuf();\n        x = 0;\n        register int f = 0, flag = false;\n        register char ch = getc();\n        while (!std::isdigit(ch)) {\n            if (ch == '-') f = 1;\n        ch = getc();\n        }\n        if (std::isdigit(ch)) x = x * 10 + ch - '0', ch = getc(),flag = true;\n        while (std::isdigit(ch)) {\n            x = x * 10 + ch - 48;\n            ch = getc();\n        }\n        x = f ? -x : x ;\n        return flag;\n    }\n    template &lt;typename T,typename ...Args&gt; inline bool qread(T&amp; a,Args&amp; ...args) {\n       return qread(a) &amp;&amp; qread(args...);\n    }\n    #undef getc\n}\n\nnamespace OUT {\n    template &lt;typename T&gt; inline void qput(T x) {\n        static std::streambuf *outbuf = cout.rdbuf();\n        static char stack[255];\n        static int top = 0;\n        if (x &lt; 0) {\n            outbuf -&gt; sputc('-');\n            x=-x;\n        }\n        if (!x) {\n            outbuf -&gt; sputc('0');\n            outbuf -&gt; sputc('\\n');\n            return;\n        }\n        while (x) {\n            stack[++top] = x % 10 + '0';\n            x /= 10;\n        }\n        while (top) {\n            outbuf -&gt; sputc(stack[top]);\n            -- top;\n        }\n    }\n    inline void putc (const char ch) {\n        static std::streambuf *outbuf = cout.rdbuf();\n        outbuf -&gt; sputc(ch);\n    }\n    template &lt;typename T&gt; inline void qput(const char ch,T x)\n    {\n        static std::streambuf *outbuf = cout.rdbuf();\n        static char stack[255];\n        static int top = 0;\n        if (x &lt; 0) {\n            outbuf -&gt; sputc('-');\n            x=-x;\n        }\n        if (!x) {\n            outbuf -&gt; sputc('0');\n            outbuf -&gt; sputc(ch);\n            return;\n        }\n        while (x) {\n            stack[++top] = x % 10 + '0';\n            x /= 10;\n        }\n        while (top) {\n            outbuf -&gt; sputc(stack[top]);\n            --top;\n        }\n        outbuf -&gt; sputc(ch);\n    }\n    template&lt;typename T,typename ...Args&gt; inline void qput(T a,Args ...args) {\n        qput(a); qput(args...);\n    }\n    template&lt;typename T,typename ...Args&gt; inline void qput(const char ch,T a,Args ...args) {\n        qput(ch, a); qput(ch, args...);\n    }\n}\nusing IN::qread;\nusing OUT::qput;\nusing OUT::putc;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_2","title":"\u9ad8\u7cbe\u5ea6","text":"<pre><code>struct BigInteger {\n    static const int BASE = 100000000;\n    static const int WIDTH = 8;\n    vector&lt;int&gt; s;\n    bool negative;\n\n    BigInteger(long long num = 0) { *this = num; }\n    BigInteger(const string&amp; str) { *this = str; }\n\n    BigInteger operator=(long long num) {\n        s.clear();\n        negative = num &lt; 0;\n        num = std::abs(num);\n        do {\n            s.push_back(num % BASE);\n            num /= BASE;\n        } while (num &gt; 0);\n        return *this;\n    }\n\n    BigInteger operator=(const string&amp; str) {\n        s.clear();\n        negative = str[0] == '-';\n        int x, len = (str.length() - 1 - negative) / WIDTH + 1;\n        for (int i = 0; i &lt; len; i++) {\n            int end = str.length() - i * WIDTH;\n            int start = max(negative ? 1ll : 0ll, end - WIDTH);\n            sscanf(str.substr(start, end - start).c_str(), \"%lld\", &amp;x);\n            s.push_back(x);\n        }\n        return *this;\n    }\n\n    bool operator&lt;(const BigInteger&amp; b) const {\n        if (negative != b.negative) return negative;\n        if (s.size() != b.s.size()) return negative ? s.size() &gt; b.s.size() : s.size() &lt; b.s.size();\n        for (int i = s.size() - 1; i &gt;= 0; i--)\n            if (s[i] != b.s[i]) return negative ? s[i] &gt; b.s[i] : s[i] &lt; b.s[i];\n        return false;\n    }\n    bool operator&gt;(const BigInteger&amp; b) const { return b &lt; *this; }\n    bool operator&lt;=(const BigInteger&amp; b) const { return !(b &lt; *this); }\n    bool operator&gt;=(const BigInteger&amp; b) const { return !(*this &lt; b); }\n    bool operator!=(const BigInteger&amp; b) const { return b &lt; *this || *this &lt; b; }\n    bool operator==(const BigInteger&amp; b) const { return !(b &lt; *this) &amp;&amp; !(*this &lt; b); }\n\n    BigInteger operator+(const BigInteger&amp; b) const {\n        if (negative == b.negative) {\n            BigInteger c;\n            c.negative = negative;\n            c.s.clear();\n            for (int i = 0, g = 0;; i++) {\n                if (g == 0 &amp;&amp; i &gt;= s.size() &amp;&amp; i &gt;= b.s.size()) break;\n                int x = g;\n                if (i &lt; s.size()) x += s[i];\n                if (i &lt; b.s.size()) x += b.s[i];\n                c.s.push_back(x % BASE);\n                g = x / BASE;\n            }\n            return c;\n        }\n        return *this - (-b);\n    }\n\n    BigInteger operator-(const BigInteger&amp; b) const {\n        if (negative == b.negative) {\n            if (abs() &gt;= b.abs()) {\n                BigInteger c;\n                c.negative = negative;\n                c.s.clear();\n                for (int i = 0, g = 0;; i++) {\n                    if (g == 0 &amp;&amp; i &gt;= s.size() &amp;&amp; i &gt;= b.s.size()) break;\n                    int x = g;\n                    if (i &lt; s.size()) x += s[i];\n                    if (i &lt; b.s.size()) x -= b.s[i];\n                    if (x &lt; 0) {\n                        c.s.push_back(x + BASE);\n                        g = -1;\n                    } else {\n                        c.s.push_back(x);\n                        g = 0;\n                    }\n                }\n                c.killzero();\n                return c;\n            }\n            return -(b - *this);\n        }\n        return *this + (-b);\n    }\n\n    BigInteger operator*(const BigInteger&amp; b) const {\n        BigInteger c;\n        c.s.resize(s.size() + b.s.size(), 0);\n        c.negative = negative != b.negative;\n        for (int i = 0; i &lt; s.size(); i++) {\n            long long carry = 0;\n            for (int j = 0; j &lt; b.s.size(); j++) {\n                long long sum = (long long)s[i] * b.s[j] + c.s[i + j] + carry;\n                c.s[i + j] = sum % BASE;\n                carry = sum / BASE;\n            }\n            if (carry) c.s[i + b.s.size()] += carry;\n        }\n        c.killzero();\n        return c;\n    }\n\n    BigInteger operator/(const BigInteger&amp; b) const {\n        BigInteger c, cur;\n        c.s.resize(s.size());\n        cur.negative = negative;\n        c.negative = negative != b.negative;\n        BigInteger abs_b = b.abs();\n        for (int i = s.size() - 1; i &gt;= 0; i--) {\n            cur = cur * BASE + s[i];\n            int x = 0, l = 0, r = BASE;\n            BigInteger cur_b = cur.abs();\n            while (l &lt;= r) {\n                int mid = (l + r) / 2;\n                if (abs_b * mid &lt;= cur_b) {\n                    x = mid;\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n            c.s[i] = x;\n            cur = cur - abs_b * x;\n        }\n        c.killzero();\n        return c;\n    }\n\n    BigInteger operator/(const int&amp; b) const {\n        BigInteger c;\n        c.s.clear();\n        long long r = 0;\n        c.negative = negative != (b &lt; 0);\n        int abs_b = std::abs(b);\n        for (int i = s.size() - 1; i &gt;= 0; --i) {\n            r = r * BASE + s[i];\n            c.s.push_back(r / abs_b);\n            r %= abs_b;\n        }\n        reverse(c.s.begin(), c.s.end());\n        c.killzero();\n        return c;\n    }\n\n    BigInteger operator%(const BigInteger&amp; b) const {\n        return *this - (*this / b) * b;\n    }\n\n    BigInteger operator%(const int&amp; b) const {\n        return *this - (*this / b) * b;\n    }\n\n    BigInteger operator+=(const BigInteger&amp; b) {\n        *this = *this + b;\n        return *this;\n    }\n    BigInteger operator++(signed) {\n        *this = *this + 1;\n        return *this;\n    }\n    BigInteger operator++() {\n        *this = *this + 1;\n        return *this;\n    }\n    BigInteger operator-=(const BigInteger&amp; b) {\n        *this = *this - b;\n        return *this;\n    }\n    BigInteger operator--(signed) {\n        *this = *this - 1;\n        return *this;\n    }\n    BigInteger operator--() {\n        *this = *this - 1;\n        return *this;\n    }\n    BigInteger operator*=(const BigInteger&amp; b) {\n        *this = *this * b;\n        return *this;\n    }\n    BigInteger operator/=(const BigInteger&amp; b) {\n        *this = *this / b;\n        return *this;\n    }\n    BigInteger operator%=(const BigInteger&amp; b) {\n        *this = *this % b;\n        return *this;\n    }\n\n    BigInteger operator-() const {\n        BigInteger c = *this;\n        c.negative = !negative;\n        return c;\n    }\n\n    BigInteger abs() const {\n        BigInteger c = *this;\n        c.negative = false;\n        return c;\n    }\n\n    void killzero() {\n        while (s.back() == 0 &amp;&amp; s.size() &gt; 1)\n            s.pop_back();\n    }\n\n    friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const BigInteger&amp; x) {\n        if (x.negative) out &lt;&lt; '-';\n        out &lt;&lt; x.s.back();\n        for (int i = x.s.size() - 2; i &gt;= 0; i--) {\n            char buf[20];\n            sprintf(buf, \"%08d\", x.s[i]);\n            out &lt;&lt; buf;\n        }\n        return out;\n    }\n\n    friend istream&amp; operator&gt;&gt;(istream&amp; in, BigInteger&amp; x) {\n        string s;\n        if (!(in &gt;&gt; s)) return in;\n        x = s;\n        return in;\n    }\n};\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_3","title":"\u54c8\u5e0c","text":"<pre><code>const int P1 = 1e9 + 7;\nconst int P2 = 1e9 + 9;\nconst int b1 = 33331;\nconst int b2 = 32141;\nstruct Hash {\n    ll x, y;\n    Hash(): x(0), y(0) {}\n    Hash(ll x): x(x), y(x) {}\n    Hash(ll t1, ll t2): x(t1), y(t2) {}\n    inline bool operator==(const Hash &amp;aa) const {\n        if (x == aa.x &amp;&amp; y == aa.y) return 1;\n        return 0;\n    }\n    inline bool operator!=(const Hash &amp;aa) const {\n        return !(*this == aa);\n    }\n    inline void js(){\n        x = (x % P1 + P1) % P1;\n        y = (y % P2 + P2) % P2;\n    }\n    inline bool operator&lt;(const Hash &amp;aa) const {\n        if (x != aa.x) return x &lt; aa.x;\n        return y &lt; aa.y;\n    }\n    inline Hash operator+(const Hash &amp;aa) const {\n        return (Hash){ x + aa.x, y + aa.y };\n    }\n    inline Hash operator-(const Hash &amp;aa) const {\n        return (Hash){ x - aa.x, y - aa.y };\n    }\n    inline Hash operator*(const Hash &amp;aa) const {\n        return (Hash){ x * aa.x, y * aa.y };\n    }\n    inline Hash operator*(const ll &amp;aa) const {\n        return (Hash){ x * aa, y * aa };\n    }\n    inline Hash operator%(const Hash &amp;aa) const {\n        return (Hash){ (x % aa.x + aa.x) % aa.x, (y % aa.y + aa.y) % aa.y };\n    }\n    inline void print() {\n        cout &lt;&lt; x &lt;&lt; ' ';\n        cout &lt;&lt; y &lt;&lt; endl;\n    }\n};\nstruct my_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x &gt;&gt; 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x &gt;&gt; 27)) * 0x94d049bb133111eb;\n    return x ^ (x &gt;&gt; 31);\n  }\n\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n\n  // \u9488\u5bf9 std::pair&lt;int, int&gt; \u4f5c\u4e3a\u4e3b\u952e\u7c7b\u578b\u7684\u54c8\u5e0c\u51fd\u6570\n  size_t operator()(Hash x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x.x + FIXED_RANDOM) ^\n           (splitmix64(x.y + FIXED_RANDOM) &gt;&gt; 1);\n  }\n};\nconst Hash P = {P1, P2};\nconst Hash B = {b1, b2};\nunordered_map&lt;Hash, int, my_hash&gt; mp;\nstruct TT {\n    Hash sum[MaxN], power[MaxN];\n    void pre(string s1, int N) {\n        power[0] = Hash(1);\n        for (int i = 1; i &lt;= N; i++) {\n            sum[i] = (sum[i - 1] * B + Hash(s1[i])) % P;\n            power[i] = power[i - 1] * B % P;\n        }\n    }\n    Hash query(int l, int r) {\n        Hash ans = sum[r] - sum[l - 1] * power[r - l + 1] % P;\n        ans.js();\n        return ans;\n    }\n} TT[2];\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_4","title":"\u5355\u54c8\u5e0c","text":"<pre><code>const int P1 = 1e9 + 7;\nconst int P2 = 1e9 + 9;\nconst int b1 = 33331;\nconst int b2 = 32141;\nstruct Hash {\n    ll x;\n    Hash(): x(0) {}\n    Hash(ll x): x(x) {}\n    Hash(ll t1, ll t2): x(t1) {}\n    inline bool operator==(const Hash &amp;aa) const {\n        if (x == aa.x) return 1;\n        return 0;\n    }\n    inline bool operator!=(const Hash &amp;aa) const {\n        return !(*this == aa);\n    }\n    inline void js(){\n        x = (x % P1 + P1) % P1;\n    }\n    inline bool operator&lt;(const Hash &amp;aa) const {\n        return x &lt; aa.x;\n    }\n    inline Hash operator+(const Hash &amp;aa) const {\n        return (Hash){ x + aa.x };\n    }\n    inline Hash operator-(const Hash &amp;aa) const {\n        return (Hash){ x - aa.x };\n    }\n    inline Hash operator*(const Hash &amp;aa) const {\n        return (Hash){ x * aa.x };\n    }\n    inline Hash operator*(const ll &amp;aa) const {\n        return (Hash){ x * aa };\n    }\n    inline Hash operator%(const Hash &amp;aa) const {\n        return (Hash){ (x % aa.x + aa.x) % aa.x };\n    }\n    inline void print() {\n        cout &lt;&lt; x &lt;&lt; ' ';\n    }\n};\nstruct my_hash {\n  static uint64_t splitmix64(uint64_t x) {\n    x += 0x9e3779b97f4a7c15;\n    x = (x ^ (x &gt;&gt; 30)) * 0xbf58476d1ce4e5b9;\n    x = (x ^ (x &gt;&gt; 27)) * 0x94d049bb133111eb;\n    return x ^ (x &gt;&gt; 31);\n  }\n\n  size_t operator()(uint64_t x) const {\n    static const uint64_t FIXED_RANDOM =\n        chrono::steady_clock::now().time_since_epoch().count();\n    return splitmix64(x + FIXED_RANDOM);\n  }\n\n};\nconst Hash P = {P1};\nconst Hash B = {b1};\nunordered_map&lt;Hash, int, my_hash&gt; mp;\nstruct TT {\n    vector&lt;Hash&gt; sum, power;\n    void pre(string s1, int N) {\n        sum.assign(N + 1, 0);\n        power.assign(N + 1, 0);\n        power[0] = Hash(1);\n        for (int i = 1; i &lt;= N; i++) {\n            sum[i] = (sum[i - 1] * B + Hash(s1[i])) % P;\n            power[i] = power[i - 1] * B % P;\n        }\n    }\n    Hash query(int l, int r) {\n        Hash ans = sum[r] - sum[l - 1] * power[r - l + 1] % P;\n        ans.js();\n        return ans;\n    }\n} TT, Ta[MaxN];\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#mod","title":"Mod\u7f51\u8d5b","text":"<pre><code>template&lt;class T&gt;\nconstexpr T ksm(T x, ll y) {\n    T res = 1;\n    while (y) {\n        if (y &amp; 1) res = res * x;\n        x = x * x;\n        y &gt;&gt;= 1;\n    }\n    return res;\n}\n\nconstexpr ll mul(ll a, ll b, ll p) { //\u5feb\u901f\u4e58 \n    ll x = (long double)a / p * b;\n    return ((ull)a * b - (ull)x * p + p) % p;\n}\n\ntemplate&lt;ll P&gt;\nstruct MLong {\n    ll x;\n    constexpr MLong() : x{} {}\n    constexpr MLong(ll x) : x{norm(x % getMod())} {}\n\n    static ll Mod;\n    constexpr static ll getMod() {\n        if (P &gt; 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(ll Mod_) {\n        Mod = Mod_;\n    }\n    constexpr ll norm(ll x) const {\n        if (x &lt; 0) {\n            x += getMod();\n        }\n        if (x &gt;= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr ll val() const {\n        return x;\n    }\n    explicit constexpr operator ll() const {\n        return x;\n    }\n    constexpr MLong operator-() const {\n        MLong res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MLong inv() const {\n        assert(x != 0);\n        return ksm(*this, getMod() - 2);\n    }\n    constexpr MLong &amp;operator*=(MLong rhs) &amp; {\n        x = mul(x, rhs.x, getMod());\n        return *this;\n    }\n    constexpr MLong &amp;operator+=(MLong rhs) &amp; {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MLong &amp;operator-=(MLong rhs) &amp; {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MLong &amp;operator/=(MLong rhs) &amp; {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &amp;operator&gt;&gt;(std::istream &amp;is, MLong &amp;a) {\n        ll v;\n        is &gt;&gt; v;\n        a = MLong(v);\n        return is;\n    }\n    friend constexpr std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const MLong &amp;a) {\n        return os &lt;&lt; a.val();\n    }\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate&lt;&gt;\nll MLong&lt;0LL&gt;::Mod = (ll)(1E18) + 9;\n\ntemplate&lt;int P&gt;\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(ll x) : x{norm(x % getMod())} {}\n\n    static int Mod;\n    static int getMod() {\n        if (P &gt; 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(int Mod_) {\n        Mod = Mod_;\n    }\n    constexpr int norm(int x) const {\n        if (x &lt; 0) {\n            x += getMod();\n        }\n        if (x &gt;= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return ksm(*this, getMod() - 2);\n    }\n    constexpr MInt &amp;operator*=(MInt rhs) &amp; {\n        x = 1LL * x * rhs.x % getMod();\n        return *this;\n    }\n    constexpr MInt &amp;operator+=(MInt rhs) &amp; {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &amp;operator-=(MInt rhs) &amp; {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &amp;operator/=(MInt rhs) &amp; {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &amp;operator&gt;&gt;(std::istream &amp;is, MInt &amp;a) {\n        ll v;\n        is &gt;&gt; v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const MInt &amp;a) {\n        return os &lt;&lt; a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate&lt;&gt;\nint MInt&lt;0&gt;::Mod = 998244353;\n\ntemplate&lt;int V, int P&gt;\nconstexpr MInt&lt;P&gt; CInv = MInt&lt;P&gt;(V).inv();\n\nconstexpr int P = 1e9 + 7;\nusing Z = MInt&lt;P&gt;;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_5","title":"\u666e\u901a\u83ab\u961f","text":"<p>\u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e3an \u7684\u6570\u5217\uff0c$a_{1}$\u200b ,$a_{2}$\u200b ,...,$a_{n}$ \uff0c\u6709q \u4e2a\u8be2\u95ee\uff0c\u6bcf\u4e2a\u8be2\u95ee\u7ed9\u51fa\u6570\u5bf9$(i,j)$\uff0c\u9700\u8981\u4f60\u7ed9\u51fa$a_{i}$\u200b \uff0c$a_{i+1}$\u200b \uff0c...\uff0c$a_{j}$\u200b \u8fd9\u4e00\u6bb5\u4e2d\u6709\u591a\u5c11\u4e0d\u540c\u7684\u6570\u5b57</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1","title":"\u6837\u4f8b #1","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_1","title":"\u6837\u4f8b\u8f93\u5165 #1","text":"<pre><code>5\n1 1 2 1 3\n3\n1 5\n2 4\n3 5\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_2","title":"\u6837\u4f8b\u8f93\u51fa #1","text":"<pre><code>3\n2\n3\n</code></pre> <pre><code>    #include&lt;bits/stdc++.h&gt;\n    using namespace std;\n    #define ll long long \n    #define int ll\n    #define zuo p&lt;&lt;1\n    #define you p&lt;&lt;1|1\n    #define lowbit(x) ((x)&amp;(-x))\n    const int MaxN=1e6+100;\n    int N,M,K,b[MaxN],ans[MaxN],sum;\n    int vis[MaxN];\n    struct point\n    {\n        int l, r, t, id;\n        inline bool operator&lt;(const Point &amp;aa) const {\n            if (t != aa.t) return t &lt; aa.t;\n            if (t &amp; 1) return r &lt; aa.r;\n            return r &gt; aa.r;\n        }\n    }a[MaxN];\n    inline void move(int x,int v)\n    {\n        vis[b[x]]+=v;\n        if(v==1&amp;&amp;vis[b[x]]==1) sum++;\n        if(v==-1&amp;&amp;vis[b[x]]==0) sum--;\n    }\n    inline void md()\n    {\n        sort(a+1,a+1+M);\n        int l=0,r=0;\n        for(int i=1;i&lt;=M;i++)\n        {\n            while(l&gt;a[i].l) move(--l,1);\n            while(r&lt;a[i].r) move(++r,1);\n            while(l&lt;a[i].l) move(l++,-1);\n            while(r&gt;a[i].r) move(r--,-1);\n            ans[a[i].id]=sum;\n        }\n    }\n    signed main()\n    {\n        qread(N);\n        for(int i=1;i&lt;=N;i++) qread(b[i]);\n        K=sqrt(N);qread(M); //K = 1000\u53ef\u80fd\u4f1a\u6bd4\u8f83\u5feb\n        for(int i=1;i&lt;=M;i++)\n        {\n            qread(a[i].l);qread(a[i].r);\n            a[i].t=a[i].l/K;\n            a[i].id=i;\n        }\n        md();\n        for(int i=1;i&lt;=M;i++)\n        qput(ans[i]),putchar('\\n');\n    }\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_6","title":"\u6811\u4e0a\u83ab\u961f","text":"<p>$ \u9898\u610f\uff1a\u7ed9\u4f60\u4e00\u68f5\u6811\uff0c\u6811\u4e0a\u7b2c i \u4e2a\u70b9\u989c\u8272\u4e3a c_i\uff0c\u6bcf\u6b21\u8be2\u95ee\u4e00\u6761\u8def\u5f84 u_i,v_i, \u6c42\u8fd9\u6761\u8def\u5f84\u4e0a\u7684 $  $\\sum_{c} {val_c \\sum_{i=1}^{cnt_c} w_i }$ $ \u5176\u4e2d\uff1aval \u8868\u793a\u8be5\u989c\u8272\u7684\u4ef7\u503c\uff0ccnt \u8868\u793a\u989c\u8272\u51fa\u73b0\u7684\u6b21\u6570\uff0cw \u8868\u793a\u8be5\u989c\u8272\u51fa\u73b0 i \u6b21\u540e\u7684\u4ef7\u503c $</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\nconst int MaxN = 1e6 + 100;\nconst int INF = 1e9;\nint T, N, M, K;\nint a[MaxN], b[MaxN], vis[MaxN], c[MaxN], s[MaxN];\nint dep[MaxN], fa[MaxN][31];\nint d[MaxN], top, fr[MaxN], la[MaxN], num1, num2, ans;\nint jg[MaxN];\nvector&lt;int&gt; G1[MaxN];\nstruct point\n{\n    int l, r, time, id;\n    inline bool operator&lt;(const point &amp;aa)const\n    {\n        if (l / T == aa.l / T &amp;&amp; r / T == aa.r / T)\n        {\n            return time &lt; aa.time;\n        }\n        if (l / T == aa.l / T)\n        {\n            return r / T &gt; aa.r / T;\n        }\n        return l / T &lt; aa.l / T;\n    }\n}q1[MaxN], q2[MaxN];\nvoid dfs1(int x, int f)\n{\n    d[++top] = x;\n    fr[x] = top;\n    dep[x] = dep[f] + 1;\n    fa[x][0] = f;\n    for (int i = 1; i &lt;= 20; i++)\n    {\n        fa[x][i] = fa[fa[x][i - 1]][i - 1];\n    }\n    for (int i = 0; i &lt; (int)G1[x].size(); i++)\n    {\n        int y = G1[x][i];\n        if (y == f)\n        {\n            continue;\n        }\n        dfs1(y, x);\n    }\n    d[++top] = x;\n    la[x] = top;\n}\nint lca(int x, int y)\n{\n    if (dep[x] &lt; dep[y])\n        swap(x, y);\n    for (int i = 20; i &gt;= 0; i--)\n    {\n        if (dep[fa[x][i]] &gt;= dep[y])\n        {\n            x = fa[x][i];\n        }\n        if (x == y)\n            return x;\n    }\n    for (int i = 20; i &gt;= 0; i--)\n    {\n        if (fa[x][i] != fa[y][i])\n        {\n            x = fa[x][i];\n            y = fa[y][i];\n        }\n    }\n    return fa[x][0];\n}\ninline void add1(int x)\n{\n    int t = d[x];\n    vis[t] ^= 1;\n    if (vis[t] == 1)\n    {\n        s[c[t]]++;\n        ans += a[c[t]] * b[s[c[t]]];\n    }\n    else\n    {\n        ans -= a[c[t]] * b[s[c[t]]];\n        s[c[t]]--;\n    }\n}\nvoid upt(int x, int t)\n{\n    if (vis[q2[t].l])\n    {\n        add1(fr[q2[t].l]);\n        swap(c[q2[t].l], q2[t].r);\n        add1(fr[q2[t].l]);\n        return;\n    }\n    swap(c[q2[t].l], q2[t].r);\n}\nvoid md()\n{\n    sort(q1 + 1, q1 + num1 + 1);\n    int l = 1, r = 1, t = 0;\n    s[c[1]]++;\n    ans = a[c[1]] * b[1];\n    vis[1] = 1;\n    for (int i = 1; i &lt;= num1; i++)\n    {\n        int li = q1[i].l, ri = q1[i].r;\n        while (li &lt; l) add1(--l);\n        while (ri &gt; r) add1(++r);\n        while (li &gt; l) add1(l++);\n        while (ri &lt; r) add1(r--);\n        while (t &lt; q1[i].time) upt(i, ++t);\n        while (t &gt; q1[i].time) upt(i, t--);\n        int k = lca(d[li], d[ri]);\n        if (k != d[li] &amp;&amp; k != d[ri])\n        {\n            jg[q1[i].id] = ans + a[c[k]] * b[s[c[k]] + 1];\n        }\n        else\n        jg[q1[i].id] = ans;\n    }\n}\ninline void Solve()\n{\n    qread(N); qread(M); qread(K);\n//  K = 4;\n    T = pow(2 * N, 0.6666);\n    for (int i = 1; i &lt;= M; i++)\n    {\n        qread(a[i]);\n    }\n    for (int i = 1; i &lt;= N; i++)\n    {\n        qread(b[i]);\n    }\n    for (int i = 1; i &lt; N; i++)\n    {\n        int x, y;\n        qread(x); qread(y);\n        G1[x].push_back(y);\n        G1[y].push_back(x);\n    }\n    dfs1(1, 0);\n    for (int i = 1; i &lt;= N; i++)\n    {\n        qread(c[i]);\n    }\n    for (int i = 1; i &lt;= K; i++)\n    {\n        int opt, x, y;\n        qread(opt);qread(x);qread(y);\n        if (opt == 0)\n        {\n            ++num2;\n            q2[num2].l = x;\n            q2[num2].id = num2;\n            q2[num2].r = y;\n        }\n        if (opt == 1)\n        {\n            ++num1;\n            if (fr[x] &gt; fr[y])\n                swap(x, y);\n            q1[num1].id = num1;\n            if (lca(x, y) == x)\n                q1[num1].l = fr[x];\n            else\n                q1[num1].l = la[x];\n            q1[num1].r = fr[y];\n            q1[num1].time = num2; \n        }\n    }\n    md();\n    for (int i = 1; i &lt;= num1; i++)\n    {\n        qput(jg[i]);putchar('\\n');\n    }\n}\nsigned main()\n{\n    Solve();\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_7","title":"\u6574\u4f53\u4e8c\u5206","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_8","title":"[\u56fd\u5bb6\u96c6\u8bad\u961f]\u77e9\u9635\u4e58\u6cd5","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_9","title":"\u9898\u76ee\u63cf\u8ff0","text":"<p>\u7ed9\u4f60\u4e00\u4e2a $n \\times n$ \u7684\u77e9\u9635\uff0c\u4e0d\u7528\u7b97\u77e9\u9635\u4e58\u6cd5\uff0c\u4f46\u662f\u6bcf\u6b21\u8be2\u95ee\u4e00\u4e2a\u5b50\u77e9\u5f62\u7684\u7b2c $k$ \u5c0f\u6570\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_10","title":"\u8f93\u5165\u683c\u5f0f","text":"<p>\u7b2c\u4e00\u884c\u6709\u4e24\u4e2a\u6574\u6570\uff0c\u5206\u522b\u8868\u793a\u77e9\u9635\u5927\u5c0f $n$ \u548c\u8be2\u95ee\u7ec4\u6570 $q$\u3002</p> <p>\u7b2c $2$ \u5230\u7b2c $(n + 1)$ \u884c\uff0c\u6bcf\u884c $n$ \u4e2a\u6574\u6570\uff0c\u8868\u793a\u8fd9\u4e2a\u77e9\u9635\u3002\u7b2c $(i + 1)$ \u884c\u7684\u7b2c $j$ \u4e2a\u6570\u8868\u793a\u77e9\u9635\u7b2c $i$ \u884c\u7b2c $j$ \u5217\u7684\u6570 $a_{i, j}$\u3002</p> <p>\u63a5\u4e0b\u6765 $q$ \u884c\uff0c\u6bcf\u884c\u4e94\u4e2a\u6574\u6570 $x_1, y_1, x_2, y_2, k$\uff0c\u8868\u793a\u4e00\u7ec4\u8be2\u95ee\uff0c\u8981\u6c42\u627e\u5230\u4ee5 $(x_1, y_1)$ \u4e3a\u5de6\u4e0a\u89d2\uff0c$(x_2, y_2)$ \u4e3a\u53f3\u4e0b\u89d2\u7684\u5b50\u77e9\u5f62\u4e2d\u7684\u7b2c $k$ \u5c0f\u6570\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_11","title":"\u8f93\u51fa\u683c\u5f0f","text":"<p>\u5bf9\u4e8e\u6bcf\u7ec4\u8be2\u95ee\uff0c\u8f93\u51fa\u4e00\u884c\u4e00\u4e2a\u6574\u6570\u8868\u793a\u7b54\u6848\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_3","title":"\u6837\u4f8b #1","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_4","title":"\u6837\u4f8b\u8f93\u5165 #1","text":"<pre><code>2 2\n2 1\n3 4\n1 2 1 2 1\n1 1 2 2 3\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_5","title":"\u6837\u4f8b\u8f93\u51fa #1","text":"<pre><code>1\n3\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_12","title":"\u6570\u636e\u89c4\u6a21\u4e0e\u7ea6\u5b9a","text":"<ul> <li>\u5bf9\u4e8e $100\\%$ \u7684\u6570\u636e\uff0c\u4fdd\u8bc1 $1 \\leq n \\leq 500$\uff0c$1 \\leq q \\leq 6 \\times 10^4$\uff0c$0 \\leq a_{i, j} \\leq 10^9$\u3002</li> </ul> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\n#define ls p &lt;&lt; 1\n#define rs p &lt;&lt; 1 | 1\n#define lowbit(x) ((x) &amp; (-x))\nconst int MaxN = 501;\nconst int MaxM = 1e6 + 100;\nconst int INF = 1e9;\nint T, N, M, K;\nint a[MaxN][MaxN], c[MaxM], tot;\nint ans[MaxM];\nint tree[MaxN][MaxN];\nvector&lt;pair&lt;int, int&gt; &gt; G1[MaxM];\nstruct point\n{\n    int x1, x2;\n    int y1, y2;\n    int k, id;\n}b[MaxM], q1[MaxM], q2[MaxM];\nint ef(int x)\n{\n    int l = 1, r = tot;\n    while (l &lt;= r)\n    {\n        int mid = (l + r) &gt;&gt; 1;\n        if (c[mid] &gt;= x) r = mid - 1;\n        else l = mid + 1;\n    }\n    return l;\n}\nvoid add1(int x, int y, int v)\n{\n    for (int i = x; i &lt;= N; i += lowbit(i))\n    {\n        for (int j = y; j &lt;= N; j += lowbit(j))\n        {\n            tree[i][j] += v;\n        }\n    }\n}\nint query(int x, int y)\n{\n    int ans = 0;\n    for (int i = x; i; i -= lowbit(i))\n    {\n        for (int j = y; j; j -= lowbit(j))\n        {\n            ans += tree[i][j];\n        }\n    }\n    return ans;\n}\nint query1(int x1, int y1, int x2, int y2)\n{\n    return query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);\n}\nvoid solve(int l, int r, int x, int y)\n{\n    if (l == r)\n    {\n        for (int i = x; i &lt;= y; i++)\n        {\n            ans[b[i].id] = l;\n        }\n        return;\n    }\n    int mid = (l + r) &gt;&gt; 1;\n    int sum1 = x - 1;\n    int sum2 = y + 1;\n    for (int i = l; i &lt;= mid; i++)\n    {\n        for (int j = 0; j &lt; (int)G1[i].size(); j++)\n        {\n            int x = G1[i][j].first;\n            int y = G1[i][j].second;\n            add1(x, y, 1);\n        }\n    }\n    for (int i = x; i &lt;= y; i++)\n    {\n        int k = query1(b[i].x1, b[i].y1, b[i].x2, b[i].y2);\n        if (k &gt;= b[i].k) q1[++sum1] = b[i];\n        else q2[--sum2] = b[i];\n    }\n    for (int i = x; i &lt;= sum1; i++)\n    {\n        b[i] = q1[i];\n    }\n    for (int i = sum2; i &lt;= y; i++)\n    {\n        b[i] = q2[i];\n    }\n    solve(mid + 1, r, sum2, y);\n    for (int i = l; i &lt;= mid; i++)\n    {\n        for (int j = 0; j &lt; (int)G1[i].size(); j++)\n        {\n            int x = G1[i][j].first;\n            int y = G1[i][j].second;\n            add1(x, y, -1);\n        }\n    }\n    solve(l, mid, x, sum1);\n}\ninline void Solve()\n{\n    cin &gt;&gt; N &gt;&gt; M;\n    for (int i = 1; i &lt;= N; i++)\n    {\n        for (int j = 1; j &lt;= N; j++)\n        {\n            cin &gt;&gt; a[i][j];\n            c[++tot] = a[i][j];\n        }\n    }\n    sort(c + 1, c + tot + 1);\n    tot = unique(c + 1, c + tot + 1) - (c + 1);\n    for (int i = 1; i &lt;= N; i++)\n    {\n        for (int j = 1; j &lt;= N; j++)\n        {\n            a[i][j] = ef(a[i][j]);\n            G1[a[i][j]].push_back(make_pair(i, j));\n        }\n    }\n    for (int i = 1; i &lt;= M; i++)\n    {\n        b[i].id = i;\n        cin &gt;&gt; b[i].x1;\n        cin &gt;&gt; b[i].y1;\n        cin &gt;&gt; b[i].x2;\n        cin &gt;&gt; b[i].y2;\n        cin &gt;&gt; b[i].k;\n    }\n    solve(1, tot, 1, M);\n    for (int i = 1; i &lt;= M; i++)\n    {\n        cout &lt;&lt; c[ans[i]] &lt;&lt; endl;\n    }\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    T = 1;\n    while (T--)\n        Solve();\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#cdq","title":"cdq\u5206\u6cbb","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_13","title":"\u3010\u6a21\u677f\u3011\u4e09\u7ef4\u504f\u5e8f\uff08\u964c\u4e0a\u82b1\u5f00\uff09","text":"<p>$ 1 \\leq n \\leq 10^5$\uff0c$1 \\leq a_i, b_i, c_i \\le k \\leq 2 \\times 10^5 $\u3002 \u4e09\u7ef4\u6bd4\u8f83\uff0c\u5148\u6309 $a$ \u6392\u5e8f, \u5728\u5206\u6cbb\u4e2d\u6309 $b$ \u6392\u5e8f, \u5c06 $c$ \u653e\u5165\u6811\u72b6\u6570\u7ec4\u6c42\u89e3\u3002</p> <pre><code>// map&lt;pair&lt;int, int&gt;, int&gt; ans;\nint ans[MaxN];\nstruct CDQ {\n    int tree[MaxN];\n    // \u6c42 a_i &lt;= a_j, b_i &lt;= b_j, c_i &lt;= c_j \u7684\u6570\u91cf\n    // c\u8303\u56f4\u8981\u6c42\u4e3a 1 \u5230 MAXN\n    int MAXN = 2e5, p;\n    struct Point {\n        int a, b, c;\n        int cnt, ans; // \u8fd9\u4e2a\u70b9\u7684\u6570\u91cf,\u7b54\u6848\n        int id;\n        inline bool operator!=(const Point &amp;aa) const {\n            if (a != aa.a) return 1;\n            if (b != aa.b) return 1;\n            if (c != aa.c) return 1;\n            return 0;\n        }\n        inline bool operator&lt;(const Point &amp;aa) const {\n            if (a != aa.a) return a &lt; aa.a;\n            if (b != aa.b) return b &lt; aa.b;\n            return c &lt; aa.c;\n        }\n    } a[MaxN], b[MaxN];\n    void add1(int x, int v) {\n        x++;\n        for (; x &lt;= MAXN; x += lowbit(x)) {\n            tree[x] += v;\n        }\n    }\n    int query(int x) {\n        x++;\n        int ans = 0;\n        for (; x; x -= lowbit(x)) {\n            ans += tree[x];\n        }\n        return ans;\n    }\n    inline bool cmp1(Point &amp;x, Point &amp;y) {\n        if (x.a != y.a) return x.a &lt; y.a;\n        if (x.b != y.b) return x.b &lt; y.b;\n        return x.c &lt; y.c;\n    }\n    void cdq(int l, int r) {\n        if (l == r) return;\n        int mid = (l + r) &gt;&gt; 1;\n        cdq(l, mid);\n        cdq(mid + 1, r);\n        sort(b + l, b + mid + 1, [&amp;](Point x, Point y) {\n            if (x.b != y.b) return x.b &lt; y.b;\n            return x.c &lt; y.c;\n        });\n        sort(b + mid + 1, b + r + 1, [&amp;](Point x, Point y) {\n            if (x.b != y.b) return x.b &lt; y.b;\n            return x.c &lt; y.c;\n        });\n        int i = l;\n        int j = mid + 1;\n        while (j &lt;= r) {\n            while (i &lt;= mid &amp;&amp; b[i].b &lt;= b[j].b) {\n                add1(b[i].c, b[i].cnt);\n                i++;\n            }\n            b[j].ans += query(b[j].c);\n            j++;\n        }\n        for (int k = l; k &lt; i; k++) {\n            add1(b[k].c, -b[k].cnt);\n        }\n    }\n    void clear() {\n        ans.clear();\n        p = 0;\n    }\n    void insert(int x, int y, int z, int cnt, int ans, int id) {\n        a[++p] = { x, y, z, cnt, ans, id };\n    }\n    void solve() {\n        int l = 1, r = p;\n        sort(a + l, a + 1 + r);\n        int tot = 0, sum = 0;\n        for (int i = l; i &lt;= r; i++) {\n            sum += a[i].cnt;\n            if (i == r || a[i] != a[i + 1]) {\n                b[++tot] = a[i];\n                b[tot].cnt = sum;\n                sum = 0;\n            }\n        }\n        cdq(1, tot);\n        for (int i = 1; i &lt;= tot; i++) {\n            // if (b[i].c == 1) ans[make_pair(b[i].a, b[i].b)] = b[i].ans;\n\n            ans[b[i].ans + b[i].cnt - 1] += b[i].cnt;\n        }\n    }\n} TT;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#kd-tree","title":"KD-Tree","text":"<pre><code>struct KDT {\n    struct Point {\n        int x[2];\n        int v, sum;\n        int l, r;\n        int L[2], R[2];\n        int d;\n    } t[MaxN], l, h;\n    int rt[LogN];\n    int b[MaxN], cnt, tot;\n    void clear() {\n        for (int i = 0; i &lt; LogN; i++) {\n            rt[i] = 0;\n        }\n        tot = 0;\n    }\n    void upd(int p) {\n        t[p].sum = t[t[p].l].sum + t[t[p].r].sum + t[p].v;\n        for (int k : {0, 1}) {\n            t[p].L[k] = t[p].R[k] = t[p].x[k];\n            if (t[p].l) {\n                t[p].L[k] = min(t[p].L[k], t[t[p].l].L[k]);\n                t[p].R[k] = max(t[p].R[k], t[t[p].l].R[k]);\n            }\n            if (t[p].r) {\n                t[p].L[k] = min(t[p].L[k], t[t[p].r].L[k]);\n                t[p].R[k] = max(t[p].R[k], t[t[p].r].R[k]);\n            }\n        }\n    }\n    inline bool cmp1(int x, int y) { return t[x].x[0] &lt; t[y].x[0]; }\n    inline bool cmp2(int x, int y) { return t[x].x[1] &lt; t[y].x[1]; }\n    int build(int l, int r) {\n        int mid = (l + r) &gt;&gt; 1;\n        ld ave1 = 0, ave2 = 0, fc1 = 0, fc2 = 0;\n        for (int i = l; i &lt;= r; i++) {\n            ave1 += t[b[i]].x[0];\n            ave2 += t[b[i]].x[1];\n        }\n        ave1 /= (r - l + 1);\n        ave2 /= (r - l + 1);\n        for (int i = l; i &lt;= r; i++) {\n            fc1 += (t[b[i]].x[0] - ave1) * (t[b[i]].x[1] - ave1);\n            fc2 += (t[b[i]].x[1] - ave2) * (t[b[i]].x[1] - ave2);\n        }\n        if (fc1 &gt; fc2) {\n            nth_element(b + l, b + mid, b + r + 1, [this](int x, int y) { return t[x].x[0] &lt; t[y].x[0]; });\n            t[b[mid]].d = 1;\n        } else {\n            nth_element(b + l, b + mid, b + r + 1, [this](int x, int y) { return t[x].x[1] &lt; t[y].x[1]; });\n            t[b[mid]].d = 2;\n        }\n\n        int x{b[mid]};\n        if (l &lt; mid) t[x].l = build(l, mid - 1);\n        if (mid &lt; r) t[x].r = build(mid + 1, r);\n        upd(x);\n        return x;\n    }\n    void append(int &amp;p) {\n        if (!p) return;\n        b[++cnt] = p;\n        append(t[p].l);\n        append(t[p].r);\n        p = 0;\n    }\n    int query(int p) {\n        if (!p || t[p].L[0] &gt; h.x[0] || t[p].R[0] &lt; l.x[0] || t[p].L[1] &gt; h.x[1] || t[p].R[1] &lt; l.x[1]) return 0;\n        if (t[p].L[0] &gt;= l.x[0] &amp;&amp; t[p].R[0] &lt;= l.x[0] &amp;&amp; t[p].R[1] &lt;= h.x[1] &amp;&amp; t[p].L[1] &gt;= l.x[1]) return t[p].sum;\n        int res = 0;\n        if (t[p].x[0] &gt;= l.x[0] &amp;&amp; t[p].x[0] &lt;= h.x[0] &amp;&amp; t[p].x[1] &gt;= l.x[1] &amp;&amp; t[p].x[1] &lt;= h.x[1]) {\n            res += t[p].v;\n        }\n        return query(t[p].l) + query(t[p].r) + res;\n    }\n    void insert(int x, int y, int z) {\n        t[++tot] = {x, y, z};\n        b[cnt = 1] = tot;\n        for (int i = 0; ; i++) {\n            if (!rt[i]) {\n                rt[i] = build(1, cnt);\n                break;\n            } else {\n                append(rt[i]);\n            }\n        }\n    }\n    int query(int x1, int y1, int x2, int y2) {\n        l = {x1, y1};\n        h = {x2, y2};\n        int ans = 0;\n        for (int i = 0; i &lt; LogN; i++) {\n            ans += query(rt[i]);\n        }\n        return ans;\n    }\n} TT;\n</code></pre> <p>## \u5e76\u67e5\u96c6</p> <pre><code>struct DSU{\n    vector&lt;int&gt; fn;\n    DSU(int n){\n        for(int i=0;i&lt;=n;i++){\n            fn.push_back(i);\n        }\n    }\n    int find(int x){\n        if(fn[x]==x){\n            return x;\n        }\n        return fn[x]=find(fn[x]);\n    }\n    void join(int x,int y){\n        int fx=find(x),fy=find(y);\n        if(fx!=fy){\n            fn[fx]=fy;\n        }\n    }\n};\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_14","title":"\u5e26\u6743\u5e76\u67e5\u96c6","text":"<p>\u4e00\u884c\uff0c\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u5047\u8bdd\u7684\u603b\u6570\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_15","title":"\u9898\u89e3","text":"<p>$g[x]$\u8868\u793a$x$\u5230\u6839\u8282\u70b9\u7684\u6743\u503c\u548c</p> <pre><code>struct DSU {\n    vector&lt;int&gt; fa, siz, sum, g;\n    vector&lt;pair&lt;int, int&gt;&gt; tmp;\n    DSU(int n) {\n        fa.assign(n + 1, 0);\n        siz.assign(n + 1, 1);\n        sum.assign(n + 1, 0);\n        g.assign(n + 1, 0);\n        for (int i = 1; i &lt;= n; i++) {\n            fa[i] = i;\n            sum[i] = i;\n        }\n    }\n    // int find(int x) {\n    //  if (fa[x] == x) return x;\n    //  auto f = find(fa[x]);\n    //  g[x] += g[fa[x]];\n    //  return fa[x] = f;\n    // }\n    int find(int x) {\n        if (fa[x] == x) return x;\n        return find(fa[x]);\n    }\n    void hebin(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            tmp.emplace_back(-1, -1);\n            return;\n        }\n        if (siz[x] &lt; siz[y]) swap(x, y);\n        tmp.emplace_back(x, y);\n        fa[y] = x;\n        siz[x] += siz[y];\n        sum[x] += sum[y];\n    }\n    void undone() { //\u64a4\u9500\n        auto [x, y] = tmp.back();\n        tmp.pop_back();\n        if (x == -1) return;\n        fa[y] = y;\n        siz[x] -= siz[y];\n        sum[x] -= sum[y];\n    }\n    void move(int x, int y) { // x -&gt; y\n        auto fx = find(x), fy = find(y);\n        if (fx == fy) return;\n        fa[x] = fy;\n        --siz[fx], ++siz[fy];\n        sum[fx] -= x, sum[fy] += x;\n    }\n};\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_16","title":"\u79bb\u6563\u5316","text":"<pre><code>template&lt;typename T&gt; \nstruct Map{\n    vector&lt;T&gt; nums;\n\n    Map() {}\n\n    void add(T x){\n        nums.push_back(x);\n    }\n\n    void build(){\n        sort(nums.begin(), nums.end());\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\n    }\n\n    int get(T x){\n        return int(lower_bound(nums.begin(), nums.end(), x) - nums.begin()) + 1;\n    }\n\n    T val(int x){\n        return nums[x - 1];\n    }\n\n    int size(){\n        return (int)nums.size();\n    }\n};\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_17","title":"\u624b\u6253\u961f\u5217","text":"<pre><code>    struct node\n    {\n        int l,r,v;\n    }p[MaxN&lt;&lt;1];\n    inline int newnode(int l,int r,int v)\n    {\n        p[++tot]=node{l,r,v};\n        return tot;\n    }\n    struct que\n    {\n        int star,end,len;\n        inline void push_back(int x)\n        {\n            if(!len) star=end=newnode(0,0,x);\n            else p[end].r=newnode(end,0,x),end=p[end].r;\n            len++;\n        }\n        inline int size()\n        {\n            return len;\n        }\n        inline int front()\n        {\n            return p[star].v;\n        }\n        inline int back()\n        {\n            return p[end].v;\n        }\n        inline void pop_front()\n        {\n            star=p[star].r;len--;\n        }\n        inline void pop_back()\n        {\n            end=p[end].l;\n            len--;\n        }\n        inline void push(int x)\n        {\n            while(!size()&amp;&amp;a[back()]&gt;a[x]) pop_back();\n            push_back(x);\n        }\n    }dui[MaxN&lt;&lt;1],dui1[MaxN&lt;&lt;1],*q=dui+MaxN,*q1=dui1+MaxN;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_18","title":"\u70b9\u5206\u6cbb","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_6","title":"\u3010\u6a21\u677f\u3011\u70b9\u5206\u6cbb1","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_19","title":"\u9898\u76ee\u63cf\u8ff0","text":"<p>\u7ed9\u5b9a\u4e00\u68f5\u6709 $n$ \u4e2a\u70b9\u7684\u6811\uff0c\u8be2\u95ee\u6811\u4e0a\u8ddd\u79bb\u4e3a $k$ \u7684\u70b9\u5bf9\u662f\u5426\u5b58\u5728\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_20","title":"\u8f93\u5165\u683c\u5f0f","text":"<p>\u7b2c\u4e00\u884c\u4e24\u4e2a\u6570 $n,m$\u3002</p> <p>\u7b2c $2$ \u5230\u7b2c $n$ \u884c\uff0c\u6bcf\u884c\u4e09\u4e2a\u6574\u6570 $u, v, w$\uff0c\u4ee3\u8868\u6811\u4e0a\u5b58\u5728\u4e00\u6761\u8fde\u63a5 $u$ \u548c $v$ \u8fb9\u6743\u4e3a $w$ \u7684\u8def\u5f84\u3002</p> <p>\u63a5\u4e0b\u6765 $m$ \u884c\uff0c\u6bcf\u884c\u4e00\u4e2a\u6574\u6570 $k$\uff0c\u4ee3\u8868\u4e00\u6b21\u8be2\u95ee\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_21","title":"\u8f93\u51fa\u683c\u5f0f","text":"<p>\u5bf9\u4e8e\u6bcf\u6b21\u8be2\u95ee\u8f93\u51fa\u4e00\u884c\u4e00\u4e2a\u5b57\u7b26\u4e32\u4ee3\u8868\u7b54\u6848\uff0c\u5b58\u5728\u8f93\u51fa <code>AYE</code>\uff0c\u5426\u5219\u8f93\u51fa <code>NAY</code>\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_22","title":"\u6570\u636e\u89c4\u6a21\u4e0e\u7ea6\u5b9a\u3002","text":"<ul> <li>\u5bf9\u4e8e $100\\%$ \u7684\u6570\u636e\uff0c\u4fdd\u8bc1 $1 \\leq n\\leq 10^4$\uff0c$1 \\leq m\\leq 100$\uff0c$1 \\leq k \\leq 10^7$\uff0c$1 \\leq u, v \\leq n$\uff0c$1 \\leq w \\leq 10^4$\u3002</li> </ul> <pre><code>struct dfz {\n    int siz[MaxN], maxp[MaxN], vis[MaxN], dis[MaxN];\n    bool judge[100000001];\n    int a[MaxN], ans[MaxN];\n    int tot, rt;\n    inline void getzx(int x, int f) {\n        siz[x] = 1;\n        maxp[x] = 0;\n        for (auto &amp;[y, z] : G1[x]) {\n            if (y == f || vis[y]) continue;\n            getzx(y, x);\n            siz[x] += siz[y];\n            maxp[x] = max(maxp[x], siz[y]);\n        }\n        maxp[x] = max(maxp[x], tot - siz[x]);\n        if (maxp[x] &lt; maxp[rt]) rt = x;\n    }\n    void getdis(int x, int f, queue&lt;int&gt; &amp;q) {\n        q.push(dis[x]);\n        for (auto &amp;[y, z] : G1[x]) {\n            if (vis[y] || y == f) continue;\n            dis[y] = dis[x] + z;\n            getdis(y, x, q);\n        }\n    }\n    inline void clac(int x) {\n        queue&lt;int&gt; q1;\n        for (auto &amp;[y, z]: G1[x]) {\n            if (vis[y]) continue;\n            queue&lt;int&gt; q;\n            dis[y] = z;\n            getdis(y, x, q);\n            queue&lt;int&gt; q2 = q;\n            while (!q.empty()) {\n                auto now = q.front(); q.pop();\n                for (int j = 1; j &lt;= M; j++)\n                    if (a[j] &gt;= now) {\n                        ans[j] |= judge[a[j] - now];\n                    }\n\n            }\n            while (!q2.empty()) {\n                auto now = q2.front(); q2.pop();\n                judge[now] = 1;\n                q1.push(now);\n            }\n\n        }\n        while (!q1.empty()) {\n            int x = q1.front();\n            q1.pop();\n            judge[x] = 0;\n        }\n    }\n    void solve(int x) {\n        vis[x] = 1;\n        judge[0] = 1;\n        clac(x);\n        judge[0] = 0;\n        for (auto &amp;[y, z]: G1[x]) {\n            if (vis[y]) continue;\n            tot = siz[y];\n            maxp[rt = 0] = INF;\n            getzx(y, 0);\n            solve(rt);\n        }\n    }\n    void Solve() {\n        tot = N;\n        maxp[rt = 0] = INF;\n        getzx(1, 0);\n        solve(rt);\n    }\n} TT;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_23","title":"\u6811\u4e0a\u542f\u53d1\u5f0f\u5408\u5e76","text":"<pre><code>struct Point {\n    int maxn = 0;\n    int sum = 0;\n    map&lt;int, int&gt; mp;\n    vector&lt;int&gt; li;\n    void add1(int x) {\n        mp[a[x]]++;\n        if (mp[a[x]] &gt; maxn) {\n            maxn = mp[a[x]];\n            sum = a[x];\n        } else if (mp[a[x]] == maxn) {\n            sum += a[x];\n        }\n        li.push_back(x);\n    }\n    int size() {\n        return li.size();\n    }\n} sub[MaxN];\nvoid dfs1(int x, int f) {\n    int son = 0, maxn = 0;\n    for (auto&amp; y : G1[x]) {\n        if (y == f) continue;\n        dfs1(y, x);\n        if (sub[fa[y]].size() &gt; maxn) {\n            maxn = sub[fa[y]].size();\n            son = y;\n        }\n    }\n    if (son) fa[x] = fa[son];\n    for (auto&amp; y : G1[x]) {\n        if (y == son) continue;\n        if (y == f) continue;\n        for (auto&amp; z : sub[fa[y]].li) {\n            sub[fa[x]].add1(z);\n        }\n    }\n    sub[fa[x]].add1(x);\n    ans[x] = sub[fa[x]].sum;\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_24","title":"\u6570\u636e\u7ed3\u6784","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#st","title":"ST \u8868","text":"<pre><code>struct ST {\n    int LogN, N;\n    vector&lt;vector&lt;int&gt;&gt; F1, F2;\n    vector&lt;int&gt; logn;\n    ST() {\n        init(0);\n    }\n    ST(int n) {\n        init(n);\n    }\n    inline void init(int n) {\n        N = n;\n        logn.assign(N + 1, 0);\n        logn[0] = -1;\n        for (int i = 1; i &lt;= N; i++) {\n            logn[i] = logn[i &gt;&gt; 1] + 1;\n        }\n        LogN = logn[N] + 1;\n        F1.assign(N + 1, vector&lt;int&gt;(LogN + 1));\n        F2.assign(N + 1, vector&lt;int&gt;(LogN + 1));\n    }\n    inline void pre() {\n        for (int j = 1; j &lt;= LogN; j++) {\n            for (int i = 1; i + (1 &lt;&lt; (j - 1)) &lt;= N; i++) {\n                F1[i][j] = max(F1[i][j - 1], F1[i + (1 &lt;&lt; (j - 1))][j - 1]);\n            }\n        }\n        for (int j = 1; j &lt;= LogN; j++) {\n            for (int i = 1; i + (1 &lt;&lt; (j - 1)) &lt;= N; i++) {\n                F2[i][j] = min(F2[i][j - 1], F2[i + (1 &lt;&lt; (j - 1))][j - 1]);\n            }\n        }\n    }\n    inline int querymax(int l, int r) {\n        int s = logn[r - l + 1];\n        return max(F1[l][s], F1[r - (1 &lt;&lt; s) + 1][s]);\n    }\n    inline int querymin(int l, int r) {\n        int s = logn[r - l + 1];\n        return min(F2[l][s], F2[r - (1 &lt;&lt; s) + 1][s]);\n    }\n};\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#fhq-treap","title":"FHQ-treap","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#hash","title":"\u5e73\u8861\u6811\u7ef4\u62a4Hash","text":"<pre><code>struct FHQ_TREAP {\n    struct Point {\n        int l, r, p, s;\n        Hash v, sum;\n    } tree[MaxN];\n    int tot = 0;\n    inline void pushdown(int p) {\n\n    }\n    inline void pushup(int p) {\n        tree[p].s = tree[tree[p].l].s + tree[tree[p].r].s + 1;\n        tree[p].sum = tree[tree[p].l].sum * power[tree[tree[p].r].s + 1] +\n                        tree[tree[p].r].sum + tree[p].v * power[tree[tree[p].r].s];\n        tree[p].sum = tree[p].sum % P;\n    }\n    inline Point pushup(Point now, Point l, Point r) {\n        now.s = l.s + r.s + 1;\n        now.sum = (l.sum * power[r.s + 1] % P + r.sum + now.v * power[r.s] % P) % P;\n        return now;\n    }\n    inline int newnode(Hash v) {\n        int x = ++tot;\n        tree[x].v = tree[x].sum = v;\n        tree[x].l = tree[x].r = 0;\n        tree[x].p = rand() * rand();\n        tree[x].s = 1;\n        return x;\n    }\n    int hebin(int x, int y) {\n        if (!x || !y) return x + y;\n        if (tree[x].p &lt; tree[y].p) {\n            pushdown(x);\n            tree[x].r = hebin(tree[x].r, y);\n            pushup(x);\n            // tree[x] = pushup(tree[x], tree[tree[x].l], tree[tree[x].r]);\n            return x;\n        } else {\n            pushdown(y);\n            tree[y].l = hebin(x, tree[y].l);\n            pushup(y);\n            // tree[y] = pushup(tree[y], tree[tree[y].l], tree[tree[y].r]);\n            return y;\n        }\n    }\n    void split(int x, int k, int &amp;l, int &amp;r) {\n        if (!x) {\n            l = r = 0;\n            return;\n        }\n        pushdown(x);\n        if (tree[tree[x].l].s + 1 &lt;= k) {\n            l = x;\n            split(tree[x].r, k - (tree[tree[x].l].s + 1), tree[x].r, r);\n        } else {\n            r = x;\n            split(tree[x].l, k, l, tree[x].l);\n        }\n        pushup(x);\n        // tree[x] = pushup(tree[x], tree[tree[x].l], tree[tree[x].r]);\n    }\n\n    string a;\n    int Build(int l, int r) {\n        if (l == r) return newnode(a[l]);\n        int mid = (l + r) &gt;&gt; 1;\n        return hebin(Build(l, mid), Build(mid + 1, r));\n    }\n    Hash query(int l, int r) {\n        int t1 = 0, t2 = 0, t3 = 0;\n        split(rt, l - 1, t1, t2);\n        split(t2, r - l + 1, t2, t3);\n        Hash ans = tree[t2].sum;\n        // dfs1(t2);\n        // cerr &lt;&lt; endl;\n        rt = hebin(hebin(t1, t2), t3);\n        return ans;\n    }\n    void change(int k, Hash v) {\n        int t1 = 0, t2 = 0, t3 = 0;\n        split(rt, k - 1, t1, t2);\n        split(t2, 1, t2, t3);\n        tree[t2].v = tree[t2].sum = v;\n        rt = hebin(hebin(t1, t2), t3);\n    }\n    void add1(int k, Hash v) {\n        int t1 = 0, t2 = 0, t3 = 0;\n        split(rt, k, t1, t3);\n        t2 = newnode(v);\n        rt = hebin(hebin(t1, t2), t3);\n    }\n    void dfs1(int x) {\n        if (!x) return;\n        dfs1(tree[x].l);\n        cerr &lt;&lt; x &lt;&lt; ' ';\n        dfs1(tree[x].r);\n    }\n} TT;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_25","title":"\u666e\u901a\u5e73\u8861\u6811","text":"<pre><code>struct FHQ_TREAP {\n    struct Point {\n        int l, r, p, s;\n        int v, sum;\n    } tree[MaxN];\n    int tot = 0;\n    inline void pushdown(int p) {\n\n    }\n    inline void pushup(int p) {\n        tree[p].s = tree[tree[p].l].s + tree[tree[p].r].s + 1;\n\n    }\n    inline Point pushup(Point now, Point l, Point r) {\n        now.s = l.s + r.s + 1;\n        return now;\n    }\n    inline int newnode(int v) {\n        int x = ++tot;\n        tree[x].v = tree[x].sum = v;\n        tree[x].l = tree[x].r = 0;\n        tree[x].p = rand() * rand();\n        tree[x].s = 1;\n        return x;\n    }\n    int hebin(int x, int y) {\n        if (!x || !y) return x + y;\n        if (tree[x].p &lt; tree[y].p) {\n            pushdown(x);\n            tree[x].r = hebin(tree[x].r, y);\n            pushup(x);\n            // tree[x] = pushup(tree[x], tree[tree[x].l], tree[tree[x].r]);\n            return x;\n        } else {\n            pushdown(y);\n            tree[y].l = hebin(x, tree[y].l);\n            pushup(y);\n            // tree[y] = pushup(tree[y], tree[tree[y].l], tree[tree[y].r]);\n            return y;\n        }\n    }\n    void split_v(int x, int k, int &amp;l, int &amp;r) {\n        if (!x) {\n            l = r = 0;\n            return;\n        }\n        pushdown(x);\n        if (tree[x].v &lt;= k) {\n            l = x;\n            split_v(tree[x].r, k, tree[x].r, r);\n        } else {\n            r = x;\n            split_v(tree[x].l, k, l, tree[x].l);\n        }\n        pushup(x);\n    }\n    void split(int x, int k, int &amp;l, int &amp;r) {\n        if (!x) {\n            l = r = 0;\n            return;\n        }\n        pushdown(x);\n        if (tree[tree[x].l].s + 1 &lt;= k) {\n            l = x;\n            split(tree[x].r, k - (tree[tree[x].l].s + 1), tree[x].r, r);\n        } else {\n            r = x;\n            split(tree[x].l, k, l, tree[x].l);\n        }\n        pushup(x);\n        // tree[x] = pushup(tree[x], tree[tree[x].l], tree[tree[x].r]);\n    }\n\n    int Build(int l, int r) {\n        if (l == r) return newnode(a[l]);\n        int mid = (l + r) &gt;&gt; 1;\n        return hebin(Build(l, mid), Build(mid + 1, r));\n    }\n    int query(int l, int r) {\n        int t1 = 0, t2 = 0, t3 = 0;\n        split(rt, l - 1, t1, t2);\n        split(t2, r - l + 1, t2, t3);\n        int ans = tree[t2].sum;\n        // dfs1(t2);\n        // cerr &lt;&lt; endl;\n        rt = hebin(hebin(t1, t2), t3);\n        return ans;\n    }\n    void change(int k, int v) {\n        int t1 = 0, t2 = 0, t3 = 0;\n        split(rt, k - 1, t1, t2);\n        split(t2, 1, t2, t3);\n        tree[t2].v = tree[t2].sum = v;\n        rt = hebin(hebin(t1, t2), t3);\n    }\n    void add1(int v) { //\u63d2\u5165\u4e00\u4e2a\u6570 $x$\n        int t1 = 0, t2 = 0, t3 = 0;\n        split_v(rt, v, t1, t3);\n        t2 = newnode(v);\n        rt = hebin(hebin(t1, t2), t3);\n    }\n    void delet(int v) { //\u5220\u9664\u4e00\u4e2a\u6570 $x$\uff08\u82e5\u6709\u591a\u4e2a\u76f8\u540c\u7684\u6570\uff0c\u5e94\u53ea\u5220\u9664\u4e00\u4e2a\uff09\n        int t1 = 0, t2 = 0, t3 = 0;\n        split_v(rt, v - 1, t1, t2);\n        split_v(t2, v, t2, t3);\n        t2 = hebin(tree[t2].l, tree[t2].r);\n        rt = hebin(hebin(t1, t2), t3);\n    }\n    int rank(int v) { //\u5b9a\u4e49\u6392\u540d\u4e3a\u6bd4\u5f53\u524d\u6570\u5c0f\u7684\u6570\u7684\u4e2a\u6570 +1\u3002\u67e5\u8be2x\u7684\u6392\u540d\u3002\n        int t1 = 0, t2 = 0, t3 = 0;\n        split_v(rt, v - 1, t1, t3);\n        int ans = tree[t1].s + 1;\n        rt = hebin(hebin(t1, t2), t3);\n        return ans;\n    }\n    int find_min(int  x) {\n        while (tree[x].l) {\n            x = tree[x].l;\n        }\n        return tree[x].v;\n    }\n    int find_max(int x) {\n        while (tree[x].r) {\n            x = tree[x].r;\n        }\n        return tree[x].v;\n    }\n    int ith(int k) { //\u67e5\u8be2\u6570\u636e\u7ed3\u6784\u4e2d\u6392\u540d\u4e3ax\u7684\u6570\n        int t1 = 0, t2 = 0, t3 = 0;\n        split(rt, k, t1, t3);\n        int ans = find_max(t1);\n        rt = hebin(hebin(t1, t2), t3);\n        return ans;\n    }\n    int get_pre(int v) { //\u6c42 $x$ \u7684\u524d\u9a71\uff08\u524d\u9a71\u5b9a\u4e49\u4e3a\u5c0f\u4e8e $x$\uff0c\u4e14\u6700\u5927\u7684\u6570\uff09\u3002\n        int t1 = 0, t2 = 0, t3 = 0;\n        split_v(rt, v - 1, t1, t3);\n        int ans = find_max(t1);\n        rt = hebin(hebin(t1, t2), t3);\n        return ans;\n    }\n    int get_next(int v) { //\u6c42 $x$ \u7684\u540e\u7ee7\uff08\u540e\u7ee7\u5b9a\u4e49\u4e3a\u5927\u4e8e $x$\uff0c\u4e14\u6700\u5c0f\u7684\u6570\uff09\n        int t1 = 0, t2 = 0, t3 = 0;\n        split_v(rt, v, t1, t3);\n        int ans = find_min(t3);\n        rt = hebin(hebin(t1, t2), t3);\n        return ans;\n    }\n    void dfs1(int x) {\n        if (!x) return;\n        dfs1(tree[x].l);\n        cerr &lt;&lt; tree[x].v &lt;&lt; ' ';\n        dfs1(tree[x].r);\n    }\n} TT;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_26","title":"\u6dfb\u70b9","text":"<pre><code>inline void add1(int x, int v) {\n    tree[x].v = v;\n    tree[x].l = tree[x].r = 0;\n    tree[x].p = rand();\n    tree[x].s = 1;\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_27","title":"\u5408\u5e76","text":"<pre><code>int hebin(int x, int y) {\n    if (!x || !y) return x + y;\n    if (tree[x].p &lt; tree[y].p) {\n        pushdown(x);\n        tree[x].r = hebin(tree[x].r, y);\n        pushup(x);\n        return x;\n    } else {\n        pushdown(y);\n        tree[y].l = hebin(x, tree[y].l);\n        pushup(y);\n        return y;\n    }\n}\nvoid split(int x, int k, int &amp;l, int &amp;r) {\n    if (!x) {\n        l = r = 0;\n        return;\n    }\n    pushdown(x);\n    if (tree[x].v &lt;= k) {\n        l = x;\n        split(tree[x].r, k, tree[x].r, r);\n    } else {\n        r = x;\n        split(tree[x].l, k, l, tree[x].l);\n    }\n    pushup(x);\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_28","title":"\u5206\u88c2","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_29","title":"\u666e\u901a","text":"<pre><code>void split(int x, int key, int &amp;l, int &amp;r) {\n    if (!x) {\n        l = r = 0;\n        return;\n    }\n    pushdown(x);\n    if (tree[tree[x].l].s + 1 &lt;= key) {\n        l = x;\n        split(tree[x].r, key - (tree[tree[x].l].s + 1), tree[x].r, r);\n    } else {\n        r = x;\n        split(tree[x].l, key, l, tree[x].l);\n    }\n    updata(x);\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_30","title":"\u533a\u95f4\u5206\u88c2","text":"<pre><code>void split_new(int x,int k)\n{\n    if(k&gt;=tree[x].y-tree[x].x+1) return;\n    int t=tree[x].x+k-1;\n    int nn=newnode(t+1,tree[x].y);\n    tree[x].y=t;\n    tree[x].r=hebin(nn,tree[x].r);\n    updata(x);\n}\nvoid split(int x,int k,int &amp;l,int &amp;r)\n{\n    if(!x)\n    {\n        l=r=0;\n        return;\n    }\n    if(tree[tree[x].l].s&gt;=k)\n    {\n        r=x;\n        split(tree[x].l,k,l,tree[x].l);\n    }\n    else\n    {\n        l=x;\n        split_new(x,k-tree[tree[x].l].s);\n        split(tree[x].r,k-(tree[tree[x].l].s\n        +tree[x].y-tree[x].x+1),tree[x].r,r);\n    }\n    updata(x);\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#mathcalo1","title":"$\\mathcal{O}(1)$\u5efa\u6811","text":"<pre><code>inline int Build(int l,int r)\n{\n    if(l==r) return add1(a[l]);\n    int mid=l+r;mid&gt;&gt;=1;\n    return hebin(Build(l,mid),Build(mid+1,r));\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#fhq-treap_1","title":"FHQ-Treap\u7ed9\u7f16\u53f7\u5bfb\u4f4d\u7f6e","text":"<pre><code>int ith(int x)\n{\n    int ans=tree[x].s-tree[tree[x].r].s;\n    while(x!=rt)\n    {\n        if(tree[tree[x].fa].r==x) \n        ans+=tree[tree[x].fa].s-tree[x].s;\n        x=tree[x].fa;\n    }\n    return ans;\n}\n\nint t=(--mp.lower_bound(x+1))-&gt;second;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#splay","title":"\u3010\u6a21\u677f\u3011\u6587\u827a\u5e73\u8861\u6811\uff08Splay\uff09","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_31","title":"\u9898\u76ee\u63cf\u8ff0","text":"<p>\u60a8\u9700\u8981\u5199\u4e00\u79cd\u6570\u636e\u7ed3\u6784\uff08\u53ef\u53c2\u8003\u9898\u76ee\u6807\u9898\uff09\uff0c\u6765\u7ef4\u62a4\u4e00\u4e2a\u6709\u5e8f\u6570\u5217\u3002  </p> <p>\u5176\u4e2d\u9700\u8981\u63d0\u4f9b\u4ee5\u4e0b\u64cd\u4f5c\uff1a\u7ffb\u8f6c\u4e00\u4e2a\u533a\u95f4\uff0c\u4f8b\u5982\u539f\u6709\u5e8f\u5e8f\u5217\u662f $5\\ 4\\ 3\\ 2\\ 1$\uff0c\u7ffb\u8f6c\u533a\u95f4\u662f $[2,4]$ \u7684\u8bdd\uff0c\u7ed3\u679c\u662f $5\\ 2\\ 3\\ 4\\ 1$\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_32","title":"\u8f93\u5165\u683c\u5f0f","text":"<p>\u7b2c\u4e00\u884c\u4e24\u4e2a\u6b63\u6574\u6570 $n,m$\uff0c\u8868\u793a\u5e8f\u5217\u957f\u5ea6\u4e0e\u64cd\u4f5c\u4e2a\u6570\u3002\u5e8f\u5217\u4e2d\u7b2c $i$ \u9879\u521d\u59cb\u4e3a $i$\u3002 \u63a5\u4e0b\u6765 $m$ \u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6b63\u6574\u6570 $l,r$\uff0c\u8868\u793a\u7ffb\u8f6c\u7684\u533a\u95f4\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_33","title":"\u8f93\u51fa\u683c\u5f0f","text":"<p>\u8f93\u51fa\u4e00\u884c $n$ \u4e2a\u6b63\u6574\u6570\uff0c\u8868\u793a\u539f\u59cb\u5e8f\u5217\u7ecf\u8fc7 $m$ \u6b21\u53d8\u6362\u540e\u7684\u7ed3\u679c\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_34","title":"\u601d\u8def","text":"<p>Splay\u533a\u95f4\u64cd\u4f5c\u601d\u60f3\uff0c\u5982\u679c\u4fee\u6539\u533a\u95f4$[l,r]$\uff0c\u5219\u5c06$[l,r]$\u533a\u95f4\u653e\u5230\u4e00\u9897\u5b50\u6811\u4e0a\u3002 \u5c06$(l-1)$\u79fb\u5230\u6839\u90e8\uff0c$(r+1)$\u79fb\u52a8\u5230\u6839\u90e8\u7684\u53f3\u5b50\u6811\u4e0a\uff0c\u90a3\u4e48\u8981\u4fee\u6539\u7684\u6240\u6709\u533a\u95f4\u90fd\u5728\u4ed6\u7684\u5de6\u5b50\u6811\u4e0a\uff0c\u653e\u4e2a\u61d2\u6807\u8bb0\u4fee\u6539\u5c31\u597d\u3002  \u7531\u4e8e\u6d89\u53ca\u5230$l-1\u548cr+1$\u6240\u4ee5\u5c06$0\u548cN+1$\u52a0\u5165\u5230\u5b50\u6811\u4e2d $l=ith(l),r=ith(r+2)$ $l-1$\u7684\u6392\u540d\u5728\u7b2c$l$\u4f4d\u7f6e   ,$r+1$\u7684\u6392\u540d\u5728\u7b2c$r+2$\u4f4d\u7f6e   </p> <pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long \n#define int ll\n#define zuo p&lt;&lt;1\n#define you p&lt;&lt;1|1\n#define lowbit(x) ((x)&amp;(-x))\nconst int MaxN=1e6+100;\nint N,M,rt,tot;\nstruct point\n{\n    int s,fa,ch[2],v,lan;\n}tree[MaxN];\ninline void push_up(int x)\n{\n    tree[x].s=tree[tree[x].ch[0]].s+tree[tree[x].ch[1]].s+1;\n    // tree[tree[x].ch[0]].fa=x;\n    // tree[tree[x].ch[1]].fa=x;\n}\ninline void overturn(int x)\n{\n    swap(tree[x].ch[0],tree[x].ch[1]);\n    tree[x].lan^=1;\n}\ninline void push_down(int x)\n{\n    if(tree[x].lan)\n    {\n        if(tree[x].ch[0])\n        overturn(tree[x].ch[0]);\n        if(tree[x].ch[1])\n        overturn(tree[x].ch[1]);\n        tree[x].lan=0;\n    }\n}\ninline bool get(int x)\n{\n    return x==tree[tree[x].fa].ch[1];\n}\ninline void rotate(int x)\n{\n    int y=tree[x].fa,z=tree[y].fa,chk=get(x);\n    tree[y].ch[chk]=tree[x].ch[chk^1];\n    if(tree[x].ch[chk^1]) tree[tree[x].ch[chk^1]].fa=y;\n    tree[x].ch[chk^1]=y;\n    tree[y].fa=x;\n    tree[x].fa=z;\n    if(z) tree[z].ch[y==tree[z].ch[1]]=x;\n    push_up(y);\n    push_up(x);\n}\ninline void splay(int x,int k)\n{\n    for(int f=tree[x].fa;f=tree[x].fa,f!=k;rotate(x))\n        if(tree[f].fa!=k) rotate(get(x)==get(f)?f:x);\n    if(k==0)\n    rt=x;\n}\ninline int add1(int v)\n{\n    int x=++tot;\n    tree[x].s=1;\n    tree[x].ch[0]=0;\n    tree[x].ch[1]=0;\n    tree[x].v=v;\n    return x;\n}\nvoid ins(int v)\n{\n    if(!rt)\n    {\n        rt=add1(v);\n        push_up(rt);\n        return ;\n    }\n    int x=rt,f=0;\n    while(1)\n    {\n        push_down(x);\n        f=x;\n        if(v&lt;=tree[x].v)\n            x=tree[x].ch[0];\n        else\n            x=tree[x].ch[1];\n        if(!x)\n        {\n            x=add1(v);\n            tree[x].fa=f;\n            tree[f].ch[v&gt;tree[f].v]=x;\n            push_up(x);\n            push_up(f);\n            splay(x,0);\n            break;\n        }\n    }\n}\ninline int ith(int k)\n{\n    int x=rt;\n    while(x)\n    {\n        push_down(x);\n        if(tree[tree[x].ch[0]].s+1==k)\n            return x;\n        else if(tree[tree[x].ch[0]].s+1&gt;k)\n            x=tree[x].ch[0];\n        else if(tree[tree[x].ch[0]].s+1&lt;k)\n        {\n            k-=(tree[tree[x].ch[0]].s+1);\n            x=tree[x].ch[1];\n        }\n    }\n    return 0;\n}\ninline void change(int x,int y)\n{\n    int l=ith(x),r=ith(y+2);\n    splay(l,0);\n    splay(r,l);\n    int pos=tree[rt].ch[1];\n    overturn(tree[pos].ch[0]);\n}\ninline void dfs1(int x)\n{\n    push_down(x);\n    if(tree[x].ch[0]) dfs1(tree[x].ch[0]);\n    if(tree[x].v&amp;&amp;tree[x].v!=N+1)\n    qput(tree[x].v),putchar(' ');\n    if(tree[x].ch[1]) dfs1(tree[x].ch[1]);\n}\nsigned main()\n{\n    qread(N);qread(M);\n    for(int i=0;i&lt;=N+1;i++) ins(i);\n//  dfs1(rt);putchar('\\n');\n    for(int i=1;i&lt;=M;i++)\n    {\n        int x,y;qread(x);qread(y);\n        change(x,y);\n//      dfs1(rt);putchar('\\n');\n    }\n    dfs1(rt);\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_35","title":"\u6811\u72b6\u6570\u7ec4","text":"<pre><code>template &lt;typename T&gt;\nstruct Fenwick {\n    int n;\n    std::vector&lt;T&gt; a;\n\n    Fenwick(int n_ = 0) {\n        init(n_);\n    }\n\n    void init(int n_) {\n        n = n_;\n        a.assign(n + 1, T{});\n    }\n\n    void add(int x, const T &amp;v) {\n        for (int i = x; i &lt;= n; i += i &amp; -i) {\n            a[i] = a[i] + v;\n        }\n    }\n\n    T sum(int x) {\n        T ans{};\n        for (int i = x; i; i -= i &amp; -i) {\n            ans = ans + a[i];\n        }\n        return ans;\n    }\n\n    T sum(int l, int r) {\n        return sum(r) - sum(l - 1);\n    }\n\n    int select(const T &amp;k) {\n        int x = 0;\n        T cur{};\n        for (int i = 1 &lt;&lt; std::__lg(n); i; i /= 2) {\n            if (x + i &lt;= n &amp;&amp; cur + a[x + i] &lt;= k) {\n                x += i;\n                cur = cur + a[x];\n            }\n        }\n        return x;\n    }\n};\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_36","title":"\u7ebf\u6bb5\u6811","text":"<pre><code>struct Segment {\n    struct Point {\n        int sum, lsum, rsum, lans, rans, ans, segans;\n        Point (): sum(0), lsum(INF), rsum(0), lans(-INF), rans(-INF), segans(-INF) {};\n        void print() {\n            cerr &lt;&lt; sum &lt;&lt; ' ';\n            cerr &lt;&lt; lsum &lt;&lt; ' ';\n            cerr &lt;&lt; rsum &lt;&lt; ' ';\n            cerr &lt;&lt; lans &lt;&lt; ' ';\n            cerr &lt;&lt; rans &lt;&lt; ' ';\n            cerr &lt;&lt; ans &lt;&lt; ' ';\n        }\n    } tree[MaxN &lt;&lt; 2], ts;\n    inline Point pushup(Point L, Point R) {\n        Point now = Point();\n        now.sum = L.sum + R.sum;\n        now.lsum = min(L.lsum, L.sum + R.lsum);\n        now.rsum = max(R.rsum, L.rsum + R.sum);\n\n        now.lans = L.sum - R.lsum;\n        now.lans = max(now.lans, L.lans);\n        now.lans = max(now.lans, L.sum + R.lans);\n        now.lans = max(now.lans, L.segans - R.lsum);\n\n        now.rans = L.rsum - R.sum;\n        now.rans = max(now.rans, R.rans);\n        now.rans = max(now.rans, L.rsum + R.segans);\n        now.rans = max(now.rans, L.rans - R.sum);\n\n        now.segans = max({L.segans - R.sum, L.sum + R.segans, L.sum - R.sum});\n\n        now.ans = L.rsum - R.lsum;\n        now.ans = max(now.ans, L.rsum + R.lans);\n        now.ans = max(now.ans, L.ans);\n        now.ans = max(now.ans, R.ans);\n        now.ans = max(now.ans, L.rans - R.lsum);\n        return now;\n    }\n    void build(int p, int l, int r) {\n        if (l == r) {\n            tree[p].sum = a[l];\n            tree[p].lsum = a[l];\n            tree[p].rsum = a[l];\n            tree[p].lans = -INF;\n            tree[p].rans = -INF;\n            tree[p].ans = -INF;\n            tree[p].segans = -INF;\n            return;\n        }\n        int mid = (l + r) &gt;&gt; 1;\n        build(ls, l, mid);\n        build(rs, mid + 1, r);\n        tree[p] = pushup(tree[ls], tree[rs]);\n    }\n    void change(int p, int l, int r, int k, int v) {\n        if (l == r) {\n            tree[p].sum = v;\n            tree[p].lsum = v;\n            tree[p].rsum = v;\n            tree[p].lans = -INF;\n            tree[p].rans = -INF;\n            tree[p].ans = -INF;\n            tree[p].segans = -INF;\n            return;\n        }\n        int mid = (l + r) &gt;&gt; 1;\n        if (mid &gt;= k) change(ls, l, mid, k, v);\n        else change(rs, mid + 1, r, k, v);\n        tree[p] = pushup(tree[ls], tree[rs]);\n    }\n    Point query(int p, int l, int r, int x, int y) {\n        if (l &gt;= x &amp;&amp; r &lt;= y) {\n            return tree[p];\n        }\n        int mid = (l + r) &gt;&gt; 1;\n        if (mid &gt;= x &amp;&amp; mid &lt; y) {\n            return pushup(query(ls, l, mid, x, y), query(rs, mid + 1, r, x, y));\n        }\n        if (mid &gt;= x) return query(ls, l, mid, x, y);\n        if (mid &lt; y) return query(rs, mid + 1, r, x, y);\n        return Point();\n    }\n} TT;\n</code></pre> <pre><code>struct LazySegment {\n    struct Point {\n        int sum, lan, minn, v;\n    } tree[MaxN &lt;&lt; 2], ts;\n    inline void js(int p, int l, int r, int v) {\n        tree[p].sum += v * (r - l + 1);\n        tree[p].minn += v;\n        tree[p].lan += v;\n    }\n    inline void pushdown(int p, int l, int r) {\n        int mid{(l + r) &gt;&gt; 1};\n        js(ls, l, mid, tree[p].lan);\n        js(rs, mid + 1, r, tree[p].lan);\n        tree[p].lan = 0;\n    }\n    inline Point pushup(Point L, Point R) {\n        Point now = {};\n        now.sum = L.sum + R.sum;\n        now.minn = min(L.minn, R.minn);\n        return now;\n    }\n    void build(int p, int l, int r) {\n        if (l == r) {\n            tree[p] = {};\n            return;\n        }\n        int mid = (l + r) &gt;&gt; 1;\n        pushdown(p, l, r);\n        build(ls, l, mid);\n        build(rs, mid + 1, r);\n        tree[p] = pushup(tree[ls], tree[rs]);\n    }\n    void change(int p, int l, int r, int x, int y, int v) {\n        if (l &gt;= x &amp;&amp; r &lt;= y) {\n            js(p, l, r, v);\n            return;\n        }\n        int mid = (l + r) &gt;&gt; 1;\n        pushdown(p, l, r);\n        if (mid &gt;= x) change(ls, l, mid, x, y, v);\n        if (mid &lt; y) change(rs, mid + 1, r, x, y, v);\n        tree[p] = pushup(tree[ls], tree[rs]);\n    }\n    Point query(int p, int l, int r, int x, int y) {\n        if (l &gt;= x &amp;&amp; r &lt;= y) {\n            return tree[p];\n        }\n        int mid = (l + r) &gt;&gt; 1;\n        pushdown(p, l, r);\n        if (mid &gt;= x &amp;&amp; mid &lt; y) {\n            return pushup(query(ls, l, mid, x, y), query(rs, mid + 1, r, x, y));\n        }\n        if (mid &gt;= x) return query(ls, l, mid, x, y);\n        if (mid &lt; y) return query(rs, mid + 1, r, x, y);\n        return Point();\n    }\n} TT;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#introl","title":"Introl","text":"<pre><code>struct segment{\n    struct Tree{\n        int l, r;\n        int tag, sum, mex;\n    }t[MaxN&lt;&lt;2];\n    #define ls p&lt;&lt;1\n    #define rs p&lt;&lt;1|1\n    int midd(int p){\n        return (t[p].l + t[p].r) &gt;&gt; 1;\n    }\n    void push_up(int p){\n        t[p].sum = t[ls].sum + t[rs].sum;\n        t[p].mex = max(t[ls].mex,t[rs].mex);\n    }\n    void pls(int p, int k){\n        t[p].tag += k;\n        t[p].sum += (t[p].r - t[p].l + 1) * k;\n        t[p].mex += k;\n    }\n    void push_down(int p){\n        if(t[p].tag){\n            pls(ls, t[p].tag);\n            pls(rs, t[p].tag);\n            t[p].tag = 0;\n        }\n    }\n    void build(int p, int l, int r){\n        t[p].l = l, t[p].r = r;\n        if(l == r){\n            t[p].sum = a[l];\n            t[p].mex = a[l];\n            return ;\n        }\n        build(ls, l, midd(p));\n        build(rs, midd(p) + 1, r);\n        push_up(p);\n    }\n    void dfs(int p,int l,int r){\n        if(l==r){\n            a[l]=t[p].mex;\n        }\n        int mid=midd(p);\n        push_down(p);\n        dfs(ls,l,mid);\n        dfs(rs,mid+1,r);\n        push_up(p);\n    }\n    void change(int p, int nl, int nr, int k){\n        int l = t[p].l, r = t[p].r;\n        if(nl &lt;= l &amp;&amp;r &lt;= nr){\n            pls(p, k);\n            return ;\n        }\n        int mid = midd(p);\n        push_down(p);\n        if(nl &lt;= mid){\n            change(ls, nl, nr, k);\n        }\n        if(mid &lt; nr){\n            change(rs, nl, nr, k);\n        }\n        push_up(p);\n    }\n    int query_sum(int p, int nl, int nr){\n        int l = t[p].l, r = t[p].r;\n        if(nl &lt;= l &amp;&amp; r &lt;= nr){\n            return t[p].sum;\n        }\n        int mid = midd(p), ans = 0;\n        push_down(p);\n        if(nl &lt;= mid){\n            ans += query_sum(ls, nl, nr);\n        }\n        if(mid &lt; nr){\n            ans += query_sum(rs, nl, nr);\n        }\n        return ans;\n    }\n    int query_max(int p, int nl, int nr){\n        int l = t[p].l, r = t[p].r;\n        if(nl &lt;= l&amp;&amp; r &lt;= nr){\n            return t[p].mex;\n        }\n        int mid = midd(p), maxn = -INF;\n        push_down(p);\n        if(nl &lt;= mid){\n            maxn = max(maxn, query_max(ls, nl, nr));\n        }\n        if(mid &lt; nr){\n            maxn=max(maxn, query_max(rs, nl, nr));\n        }\n        return maxn;\n    }\n};\n</code></pre> <pre><code>struct segment{\n    struct Tree{\n        int l, r;\n        int add, sum, mex, mul = 1;\n    }t[MaxN&lt;&lt;2];\n    #define ls p&lt;&lt;1\n    #define rs p&lt;&lt;1|1\n    int midd(int p){\n        return (t[p].l + t[p].r) &gt;&gt; 1;\n    }\n    void push_up(int p){\n        t[p].sum = (t[ls].sum + t[rs].sum)%mod;\n        t[p].mex = max(t[ls].mex,t[rs].mex);\n    }\n    void push_down(int p){\n        t[ls].sum = (t[ls].sum * t[p].mul + t[p].add * (t[ls].r - t[ls].l + 1)) % mod;\n        t[rs].sum = (t[rs].sum * t[p].mul + t[p].add * (t[rs].r - t[rs].l + 1)) % mod;\n\n        t[ls].mex = (t[ls].mex * t[p].mul + t[p].add) % mod;\n        t[rs].mex = (t[rs].mex * t[p].mul + t[p].add) % mod;\n\n        t[ls].mul = (t[ls].mul * t[p].mul) % mod;\n        t[rs].mul = (t[rs].mul * t[p].mul) % mod;\n\n        t[ls].add = (t[ls].add * t[p].mul + t[p].add) % mod;\n        t[rs].add = (t[rs].add * t[p].mul + t[p].add) % mod;\n\n        t[p].add=0;\n        t[p].mul=1;\n    }\n    void build(int p, int l, int r){\n        t[p].l = l, t[p].r = r;\n        if(l == r){\n            t[p].sum = a[l];\n            t[p].mex = a[l];\n            return ;\n        }\n        build(ls, l, midd(p));\n        build(rs, midd(p) + 1, r);\n        push_up(p);\n    }\n    void dfs(int p,int l,int r){\n        if(l==r){\n            a[l]=t[p].mex;\n        }\n        int mid=midd(p);\n        push_down(p);\n        dfs(ls,l,mid);\n        dfs(rs,mid+1,r);\n        push_up(p);\n    }\n    void changeMul(int p, int nl, int nr, int k){\n        int l = t[p].l, r = t[p].r;\n        if(nl &lt;= l &amp;&amp; r &lt;= nr){\n            t[p].add = (t[p].add * k) % mod;\n            t[p].mul = (t[p].mul * k) % mod;\n            t[p].sum = (t[p].sum * k) % mod;\n            t[p].mex = (t[p].sum * k) % mod;\n            return ;\n        }\n        int mid = midd(p);\n        push_down(p);\n        if(nl &lt;= mid){\n            changeMul(ls, nl, nr, k);\n        }\n        if(mid &lt; nr){\n            changeMul(rs, nl, nr, k);\n        }\n        push_up(p);\n    }\n    void changeAdd(int p, int nl, int nr, int k){\n        int l = t[p].l, r = t[p].r;\n        if(nl &lt;= l &amp;&amp; r &lt;= nr){\n            t[p].add = (t[p].add + k) % mod;\n            t[p].sum = (t[p].sum + (t[p].r - t[p].l + 1) * k) % mod;\n            t[p].mex = (t[p].mex + k) % mod;\n            return ;\n        }\n        int mid = midd(p);\n        push_down(p);\n        if(nl &lt;= mid){\n            changeAdd(ls, nl, nr, k);\n        }\n        if(mid &lt; nr){\n            changeAdd(rs, nl, nr, k);\n        }\n        push_up(p);\n    }\n    int query_sum(int p, int nl, int nr){\n        int l = t[p].l, r = t[p].r;\n        if(nl &lt;= l &amp;&amp; r &lt;= nr){\n            return t[p].sum;\n        }\n        int mid = midd(p), ans = 0;\n        push_down(p);\n        if(nl &lt;= mid){\n            ans += query_sum(ls, nl, nr);\n        }\n        if(mid &lt; nr){\n            ans += query_sum(rs, nl, nr);\n        }\n        return ans;\n    }\n    int query_max(int p, int nl, int nr){\n        int l = t[p].l, r = t[p].r;\n        if(nl &lt;= l&amp;&amp; r &lt;= nr){\n            return t[p].mex;\n        }\n        int mid = midd(p), maxn = -INF;\n        push_down(p);\n        if(nl &lt;= mid){\n            maxn = max(maxn, query_max(ls, nl, nr));\n        }\n        if(mid &lt; nr){\n            maxn=max(maxn, query_max(rs, nl, nr));\n        }\n        return maxn;\n    }\n}Tree;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_37","title":"\u6743\u503c\u7ebf\u6bb5\u6811","text":"<pre><code>struct Segment {\n    struct Point {\n        int l, r, sum;\n    };\n    int tot;\n    vector&lt;Point&gt; tree;\n    Segment() {\n        init();\n    }\n    Segment(int _n) {\n        init(_n);\n    }\n    void init() {\n        tree.clear();\n        tot = 0;\n    }\n    void init(int _n) {\n        tree.clear();\n        tot = 0;\n        tree.assign(_n, {});\n    }\n\n    inline Point pushup(Point L, Point R) {\n        Point now = Point();\n        now.sum = L.sum + R.sum;\n        return now;\n    }\n\n    inline void pushup(int p) {\n        tree[p].sum = tree[tree[p].l].sum + tree[tree[p].r].sum;\n    }\n\n    int change(int p, int l, int r, int k, int v) {\n        while (tree.size() &lt;= tot + 10) tree.push_back({});\n        if (!p) {\n            p = ++tot;\n        }\n        if (l == r) {\n            tree[p].sum += v;\n            return p;\n        }\n        int mid = (l + r) &gt;&gt; 1;\n        if (mid &gt;= k) tree[p].l = change(tree[p].l, l, mid, k, v);\n        else tree[p].r = change(tree[p].r, mid + 1, r, k, v);\n        pushup(p);\n        return p;\n    }\n\n    int query(int p, int l, int r, int k) {\n        if (l == r) return l;\n        int now = tree[tree[p].l].sum;\n        int mid = (l + r) &gt;&gt; 1;\n        if (now &gt;= k) return query(tree[p].l, l, mid, k);\n        else return query(tree[p].r, mid + 1, r, k - now);\n    }\n} TT(MaxN);\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_38","title":"\u6811\u94fe\u5256\u5206","text":"<pre><code>struct TT {\n    int deep[MaxN], father[MaxN], siz[MaxN], son[MaxN];//deep-&gt;\u6df1\u5ea6 father-&gt;\u7236\u8282\u70b9 siz-&gt;\u5b50\u6811\u5927\u5c0f son-&gt;\u91cd\u513f\u5b50\n    int seg[MaxN], top[MaxN], rev[MaxN];\n    inline void dfs1(int x, int f) {\n        deep[x] = deep[f] + 1;\n        father[x] = f;\n        siz[x] = 1;\n        for (auto y : G1[x]) {\n            if (y == f) continue;\n            dfs1(y, x);\n            siz[x] += siz[y];\n            if (siz[son[x]] &lt; siz[y])\n                son[x] = y;\n        }\n    }\n    inline void dfs2(int x, int f) {\n        if (son[x]) {\n            seg[son[x]] = ++seg[0];\n            top[son[x]] = top[x];\n            rev[seg[0]] = son[x];\n            dfs2(son[x], x);\n        }\n        for (auto y : G1[x]) {\n            if (y != son[x] &amp;&amp; y != f) {\n                top[y] = y;\n                seg[y] = ++seg[0];\n                rev[seg[0]] = y;\n                dfs2(y, x);\n            }\n        }\n    }\n    void pre() {\n        dfs1(1, 0);\n        seg[0] = seg[1] = rev[1] = top[1] = 1;\n        dfs2(1, 0);\n    }\n    void print(int x){\n\n    }\n    struct Point {\n        int sum, lan, maxn;\n    } tree[MaxN &lt;&lt; 2];\n    inline void pushup(int p) {\n        tree[p].sum = tree[ls].sum + tree[rs].sum;\n        tree[p].maxn = max(tree[ls].maxn, tree[rs].maxn);\n    }\n    void build(int p, int l, int r) {\n        if (l == r) {\n            tree[p].sum = tree[p].maxn = deep[rev[l]];\n            return;\n        }\n        int mid = (l + r) &gt;&gt; 1;\n        build(ls, l, mid);\n        build(rs, mid + 1, r);\n        pushup(p);\n    }\n    inline void js(int p, int l, int r, int z) {\n        tree[p].sum += (r - l + 1) * z;\n        tree[p].lan += z;\n        tree[p].maxn += z;\n    }\n    inline void pushdown(int p, int l, int r) {\n        int mid = (l + r) &gt;&gt; 1;\n        js(ls, l, mid, tree[p].lan);\n        js(rs, mid + 1, r, tree[p].lan);\n        tree[p].lan = 0;\n    }\n    void change(int p, int l, int r, int x, int y, int z) {\n        if (l &gt;= x &amp;&amp; r &lt;= y) {\n            js(p, l, r, z);\n            return;\n        }\n        pushdown(p, l, r);\n        int mid = (l + r) &gt;&gt; 1;\n        if (mid &gt;= x) change(ls, l, mid, x, y, z);\n        if (mid &lt; y) change(rs, mid + 1, r, x, y, z);\n        pushup(p);\n    }\n    int query(int p, int l, int r, int x, int y) {\n        if (l &gt;= x &amp;&amp; r &lt;= y) {\n            return tree[p].maxn;\n        }\n        pushdown(p, l, r);\n        int mid = (l + r) &gt;&gt; 1;\n        int maxn = 0;\n        if (mid &gt;= x) maxn = max(maxn, query(ls, l, mid, x, y));\n        if (mid &lt; y) maxn = max(maxn, query(rs, mid + 1, r, x, y));\n        return maxn;\n    }\n    inline void change1(int x, int y, int z) { //x -&gt; y \u94fe\u4e0a\u503c+z\n        int fx = top[x], fy = top[y];\n        while (fx != fy) {\n            if (deep[fx] &lt; deep[fy]) swap(x, y), swap(fx, fy);\n            change(1, 1, seg[0], seg[fx], seg[x], 1);\n            x = father[fx];\n            fx = top[x];\n        }\n        if (deep[x] &lt; deep[y]) swap(x, y);\n        change(1, 1, seg[0], seg[y], seg[x], z);\n    }\n    inline void changeroot(int x, int z) {\n        int l = seg[x];\n        int r = seg[x] + siz[x] - 1;\n        change(1, 1, seg[0], l, r, z);\n    }\n    inline int query1(int x) { // x\u4e3a\u6839\u7684\u6700\u5927\u503c\n        int l = seg[x];\n        int r = seg[x] + siz[x] - 1;\n        int ans = query(1, 1, seg[0], l, r);\n        return ans;\n    }\n    inline int lca(int x, int y) {\n        int fx = top[x], fy = top[y];\n        while (fx != fy) {\n            if (deep[fx] &lt; deep[fy]) swap(x, y), swap(fx, fy);\n            x = father[fx];\n            fx = top[x];\n        }\n        return deep[x] &lt; deep[y] ? x : y;\n    }\n} TT;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#introl_1","title":"Introl","text":"<pre><code>struct TT{\n    int dep[MaxN],father[MaxN],siz[MaxN],son[MaxN];\n    //dep\u8868\u793a\u6df1\u5ea6\uff0cfather\u8868\u793a\u7236\u8282\u70b9\uff0csiz\u8868\u793a\u5b50\u6811\u5927\u5c0f\uff0cson\u8868\u793a\u91cd\u513f\u5b50\n    int dfn[MaxN],top[MaxN],rnk[MaxN];\n    //dfn\u8868\u793aDFS\u5e8f\uff0ctop\u8868\u793a\u91cd\u94fe\u7684\u9876\u90e8\u8282\u70b9\uff0crnk\u8868\u793aDFS\u5e8f\u8868\u793a\u7684\u8282\u70b9\u7f16\u53f7\uff0crnk(dfn(x))=x\n\n    void dfs1(int x,int fa){\n        dep[x]=dep[fa]+1;\n        father[x]=fa;\n        siz[x]=1;\n        for(auto y:G1[x]){\n            if(y==fa)continue;\n            dfs1(y,x);\n            siz[x]+=siz[y];\n            if(siz[son[x]]&lt;siz[y])\n                son[x]=y;\n        }\n    }\n    void dfs2(int x,int fa){\n        if(son[x]){\n            dfn[son[x]]=++dfn[0];\n            top[son[x]]=top[x];\n            rnk[dfn[0]]=son[x];\n            dfs2(son[x],x);\n        }\n        for(auto y:G1[x]){\n            if(y!=son[x]&amp;&amp;y!=fa){\n                top[y]=y;\n                dfn[y]=++dfn[0];\n                rnk[dfn[0]]=y;\n                dfs2(y,x);\n            }\n        }\n    }\n    void init(){\n        dfs1(1,0);\n        dfn[0]=dfn[1]=rnk[1]=top[1]=1;\n        dfs2(1,0);\n    }\n    void init(int root){\n        dfs1(root,0);\n        dfn[0]=dfn[root]=1;\n        top[root]=root;\n        rnk[1]=root;\n        dfs2(root,0);\n    }\n\n\n    void debug(int x){\n        cerr&lt;&lt;x&lt;&lt;\" \"&lt;&lt;dfn[x]&lt;&lt;endl;\n    }\n\n\n\n    struct Point{\n        int l,r;\n        int tag;\n        int sum,mex;\n    }t[MaxN&lt;&lt;2];\n    #define ls p&lt;&lt;1\n    #define rs p&lt;&lt;1|1\n    int midd(int p){\n        return (t[p].l+t[p].r)&gt;&gt;1;\n    }\n    void push_up(int p){\n        t[p].mex=max(t[ls].mex,t[rs].mex);\n        t[p].sum+=t[rs].sum;\n    }\n    void build(int p,int l,int r){\n        t[p].l=l,t[p].r=r;\n        if(l==r){\n            t[p].mex=t[p].sum=a[rnk[l]];\n            return;\n        }\n        int mid=midd(p);\n        build(ls,l,mid);\n        build(rs,mid+1,r);\n        push_up(p);\n    }\n    void pls(int p,int k){\n        t[p].sum+=(t[p].r-t[p].l+1)*k);\n        t[p].tag+=k;\n        t[p].mex+=k;\n    }\n    void push_down(int p){\n        if(t[p].tag){\n            pls(ls,t[p].tag);\n            pls(rs,t[p].tag);\n            t[p].tag=0;\n        }\n    }\n    void change(int p,int nl,int nr,int k){\n        int l=t[p].l,r=t[p].r;\n        if(nl&lt;=l&amp;&amp;r&lt;=nr){\n            pls(p,k);\n            return;\n        }\n        int mid=midd(p);\n        push_down(p); \n        if(nl&lt;=mid){\n            change(ls,nl,nr,k);\n        }\n        if(mid&lt;nr){\n            change(rs,nl,nr,k);\n        }\n        push_up(p);\n    }\n    int query_max(int p,int nl,int nr){\n        int l=t[p].l,r=t[p].r;\n        if(nl&lt;=l&amp;&amp;r&lt;=nr){\n            return t[p].mex;\n        }\n        int mid=midd(p),maxn=-INF;\n        push_down(p);\n        if(nl&lt;=mid){\n            maxn=max(maxn,query_max(ls,nl,nr));\n        }\n        if(mid&lt;nr){\n            maxn=max(maxn,query_max(rs,nl,nr));\n        }\n        return maxn;\n    }\n    int query_sum(int p,int nl,int nr){\n        int l=t[p].l,r=t[p].r;\n        if(nl&lt;=l&amp;&amp;r&lt;=nr){\n            return t[p].sum;\n        }\n        int mid=midd(p),res=0;\n        push_down(p);\n        if(nl&lt;=mid){\n            res+=query_sum(ls,nl,nr);\n        }\n        if(mid&lt;nr){\n            res+=query_sum(rs,nl,nr);\n        }\n        return res;\n    }\n\n\n    void treechange(int x,int y,int z){//(x-&gt;y)+z\n        int fx=top[x],fy=top[y];\n        while(fx!=fy){\n            if(dep[fx]&lt;dep[fy]){\n                swap(x,y);\n                swap(fx,fy);\n            }\n            change(1,dfn[fx],dfn[x],z);\n            x=father[fx];\n            fx=top[x];\n            // cnt++;\n            // cerr&lt;&lt;cnt&lt;&lt;endl;\n        }\n        if(dep[x]&gt;dep[y])swap(x,y);\n        change(1,dfn[x],dfn[y],z);\n    }\n    int treesum(int x,int y){\n        int fx=top[x],fy=top[y];\n        int res=0;\n        while(fx!=fy){\n            if(dep[fx]&lt;dep[fy])swap(x,y),swap(fx,fy);\n            res+=query_sum(1,dfn[fx],dfn[x]);\n            x=father[fx];\n            fx=top[x];\n        }   \n        if(dep[x]&gt;dep[y])swap(x,y);\n        res+=query_sum(1,dfn[x],dfn[y]);\n        return res;\n    }\n\n    void changeroot(int x,int z){\n        int l=dfn[x];\n        int r=dfn[x]+siz[x]-1;\n        // cerr&lt;&lt;dfn[x]&lt;&lt;\" \"&lt;&lt;dfn[x]+siz[x]-1&lt;&lt;endl;\n        // cerr&lt;&lt;query_sum(1,l,r)&lt;&lt;endl;\n\n        change(1,l,r,z);\n    }\n    int queryroot(int x){\n        int l=dfn[x];\n        int r=dfn[x]+siz[x]-1;\n        // debug(x);\n        int ans=query_sum(1,l,r);\n        // cerr&lt;&lt;\"debug\"&lt;&lt;rnk[dfn[x]]&lt;&lt;endl;\n        // cerr&lt;&lt;\"ans:\"&lt;&lt;query_sum(1,3,3)&lt;&lt;endl;\n        return ans;\n    }\n\n\n    int lca(int x,int y){\n        int fx=top[x],fy=top[y];\n        while(fx!=fy){\n            if(dep[fx]&lt;dep[fy])swap(x,y),swap(fx,fy);\n            x=father[fx];\n            fx=top[x];\n        }\n        return dep[x]&lt;dep[y]?x:y;\n    }\n\n}Tree;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_7","title":"\u3010\u6a21\u677f\u3011\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811 1\uff08\u53ef\u6301\u4e45\u5316\u6570\u7ec4\uff09","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_39","title":"\u9898\u76ee\u63cf\u8ff0","text":"<p>\u5982\u9898\uff0c\u4f60\u9700\u8981\u7ef4\u62a4\u8fd9\u6837\u7684\u4e00\u4e2a\u957f\u5ea6\u4e3a $ N $ \u7684\u6570\u7ec4\uff0c\u652f\u6301\u5982\u4e0b\u51e0\u79cd\u64cd\u4f5c</p> <ol> <li> <p>\u5728\u67d0\u4e2a\u5386\u53f2\u7248\u672c\u4e0a\u4fee\u6539\u67d0\u4e00\u4e2a\u4f4d\u7f6e\u4e0a\u7684\u503c</p> </li> <li> <p>\u8bbf\u95ee\u67d0\u4e2a\u5386\u53f2\u7248\u672c\u4e0a\u7684\u67d0\u4e00\u4f4d\u7f6e\u7684\u503c</p> </li> </ol> <pre><code>struct Segment {\n    struct Point {\n        int l, r, sum;\n    };\n    int tot;\n    vector&lt;Point&gt; tree;\n    Segment() {\n        init();\n    }\n    Segment(int _n) {\n        init(_n);\n    }\n    void init() {\n        tree.clear();\n        tot = 0;\n    }\n    void init(int _n) {\n        tree.clear();\n        tot = 0;\n        tree.assign(_n, {});\n    }\n\n    int change(int p, int l, int r, int k, int v) {\n        while (tree.size() &lt;= tot + 10) tree.push_back({});\n        tree[++tot] = tree[p];\n        p = tot;\n\n        if (l == r) {\n            tree[p].sum = v;\n            return p;\n        }\n\n        int mid = (l + r) &gt;&gt; 1;\n        if (mid &gt;= k) tree[p].l = change(tree[p].l, l, mid, k, v);\n        else tree[p].r = change(tree[p].r, mid + 1, r, k, v);\n        return p;\n    }\n\n    int query(int p, int l, int r, int k) {\n        if (l == r) return tree[p].sum;\n        int mid = (l + r) &gt;&gt; 1;\n        if (mid &gt;= k) return query(tree[p].l, l, mid, k);\n        else return query(tree[p].r, mid + 1, r, k);\n    }\n};\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#2","title":"\u3010\u6a21\u677f\u3011\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811 2(\u4e3b\u5e2d\u6811)","text":"<pre><code>struct Segment {\n    struct Point {\n        int l, r, sum;\n    };\n    int tot;\n    vector&lt;Point&gt; tree;\n    Segment() {\n        init();\n    }\n    Segment(int _n) {\n        init(_n);\n    }\n    void init() {\n        tree.clear();\n        tot = 0;\n    }\n    void init(int _n) {\n        tree.clear();\n        tot = 0;\n        tree.assign(_n, {});\n    }\n\n    int change(int p, int l, int r, int k, int v) {\n        while (tree.size() &lt;= tot + 10) tree.push_back({});\n        tree[++tot] = tree[p];\n        p = tot;\n\n        tree[p].sum += v;\n        if (l == r) return p;\n\n        int mid = (l + r) &gt;&gt; 1;\n        if (mid &gt;= k) tree[p].l = change(tree[p].l, l, mid, k, v);\n        else tree[p].r = change(tree[p].r, mid + 1, r, k, v);\n        return p;\n    }\n\n    int query(int p1, int p2, int l, int r, int k) { //\u7b2ck\u5c0f\n        if (l == r) return l;\n        int now = tree[tree[p2].l].sum - tree[tree[p1].l].sum;\n        int mid = (l + r) &gt;&gt; 1;\n        if (now &gt;= k) return query(tree[p1].l, tree[p2].l, l, mid, k);\n        else return query(tree[p1].r, tree[p2].r, mid + 1, r, k - now);\n    }\n};\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_40","title":"\u53ef\u6301\u4e45\u5316\u5e76\u67e5\u96c6","text":"<pre><code>int rt[MaxN];\nstruct PersistantUnionSet{\n    struct Point {\n        int l, r, f, dep;\n    };\n    int tot;\n    Point tree[MaxM];\n    PersistantUnionSet() {\n        init();\n    }\n    PersistantUnionSet(int _n) {\n        init(_n);\n    }\n    void init() {\n        // tree.clear();\n        tot = 0;\n    }\n    void init(int _n) {\n        // tree.clear();\n        tot = 0;\n        // tree.assign(_n, {});\n    }\n\n    int change(int p, int l, int r, int k, int f, int siz) {\n        // while (tree.size() &lt;= tot + 10) tree.push_back({});\n        tree[++tot] = tree[p];\n        p = tot;\n\n\n        if (l == r) {\n            tree[p].dep = siz;\n            tree[p].f = f;\n            return p;\n        }\n\n        int mid = (l + r) &gt;&gt; 1;\n        if (mid &gt;= k) tree[p].l = change(tree[p].l, l, mid, k, f, siz);\n        else tree[p].r = change(tree[p].r, mid + 1, r, k, f, siz);\n        return p;\n    }\n\n    Point query(int p, int l, int r, int k) { //\u7b2ck\u5c0f\n        if (l == r) return tree[p];\n        int mid = (l + r) &gt;&gt; 1;\n        if (mid &gt;= k) return query(tree[p].l, l, mid, k);\n        else return query(tree[p].r, mid + 1, r, k);\n    }\n\n    pair&lt;int, int&gt; queryFa(int p, int pos) {\n          auto [l, r, f, siz] = query(p, 1, N, pos);\n          if (f == pos) return { f, siz };\n          return queryFa(p, f);\n    }\n};\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#odt","title":"ODT","text":"<pre><code>struct ODT {\n    struct Point {\n        int l, r;\n        mutable int v;\n        Point (int l, int r, int v) : l(l), r(r), v(v) {}\n        inline bool operator&lt;(const Point &amp;aa) const {\n            return l &lt; aa.l;\n        }\n    };\n    set&lt;Point&gt; odt;\n    auto split(int x) { // [l, x) [x, r],\u6307\u5411\u540e\u8005 \n        if (x &gt; N) return odt.end();\n        auto it = --odt.upper_bound(Point(x, 0, 0));\n        if (it-&gt;l == x) return it;\n        auto [l, r, v] = *it;\n        odt.erase(it);\n        odt.insert(Point(l, x - 1, v));\n        return odt.insert(Point(x, r, v)).first;\n    }\n\n    void assign(int l, int r, int v) {\n        auto itr = split(r + 1), itl = split(l);\n        odt.erase(itl, itr);\n        odt.insert(Point(l, r, v));\n    }\n\n    void insert(int l, int r, int v) {\n        odt.insert(Point(l, r, v));\n    }\n\n    void performance(int l, int r) {\n        auto itr = split(r + 1), itl = split(l);\n        for (; itl != itr; ++itl) {\n            auto &amp;[l, r, v] = *itl;\n            // Perform Operations here\n        }\n    }\n};\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_41","title":"\u3010\u6a21\u677f\u3011\u5de6\u504f\u6811\uff08\u53ef\u5e76\u5806\uff09","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_42","title":"\u9898\u76ee\u63cf\u8ff0","text":"<p>\u5982\u9898\uff0c\u4e00\u5f00\u59cb\u6709 $n$ \u4e2a\u5c0f\u6839\u5806\uff0c\u6bcf\u4e2a\u5806\u5305\u542b\u4e14\u4ec5\u5305\u542b\u4e00\u4e2a\u6570\u3002\u63a5\u4e0b\u6765\u9700\u8981\u652f\u6301\u4e24\u79cd\u64cd\u4f5c\uff1a</p> <ol> <li> <p><code>1 x y</code>\uff1a\u5c06\u7b2c $x$ \u4e2a\u6570\u548c\u7b2c $y$ \u4e2a\u6570\u6240\u5728\u7684\u5c0f\u6839\u5806\u5408\u5e76\uff08\u82e5\u7b2c $x$ \u6216\u7b2c $y$ \u4e2a\u6570\u5df2\u7ecf\u88ab\u5220\u9664\u6216\u7b2c $x$ \u548c\u7b2c $y$ \u4e2a\u6570\u5728\u7528\u4e00\u4e2a\u5806\u5185\uff0c\u5219\u65e0\u89c6\u6b64\u64cd\u4f5c\uff09\u3002</p> </li> <li> <p><code>2 x</code>\uff1a\u8f93\u51fa\u7b2c $x$ \u4e2a\u6570\u6240\u5728\u7684\u5806\u6700\u5c0f\u6570\uff0c\u5e76\u5c06\u8fd9\u4e2a\u6700\u5c0f\u6570\u5220\u9664\uff08\u82e5\u6709\u591a\u4e2a\u6700\u5c0f\u6570\uff0c\u4f18\u5148\u5220\u9664\u5148\u8f93\u5165\u7684\uff1b\u82e5\u7b2c $x$ \u4e2a\u6570\u5df2\u7ecf\u88ab\u5220\u9664\uff0c\u5219\u8f93\u51fa $-1$ \u5e76\u65e0\u89c6\u5220\u9664\u64cd\u4f5c\uff09\u3002</p> </li> </ol>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_43","title":"\u8f93\u5165\u683c\u5f0f","text":"<p>\u7b2c\u4e00\u884c\u5305\u542b\u4e24\u4e2a\u6b63\u6574\u6570 $n, m$\uff0c\u5206\u522b\u8868\u793a\u4e00\u5f00\u59cb\u5c0f\u6839\u5806\u7684\u4e2a\u6570\u548c\u63a5\u4e0b\u6765\u64cd\u4f5c\u7684\u4e2a\u6570\u3002</p> <p>\u7b2c\u4e8c\u884c\u5305\u542b $n$ \u4e2a\u6b63\u6574\u6570\uff0c\u5176\u4e2d\u7b2c $i$ \u4e2a\u6b63\u6574\u6570\u8868\u793a\u7b2c $i$ \u4e2a\u5c0f\u6839\u5806\u521d\u59cb\u65f6\u5305\u542b\u4e14\u4ec5\u5305\u542b\u7684\u6570\u3002</p> <p>\u63a5\u4e0b\u6765 $m$ \u884c\u6bcf\u884c $2$ \u4e2a\u6216 $3$ \u4e2a\u6b63\u6574\u6570\uff0c\u8868\u793a\u4e00\u6761\u64cd\u4f5c\uff0c\u683c\u5f0f\u5982\u4e0b\uff1a</p> <p>\u64cd\u4f5c $1$\uff1a<code>1 x y</code></p> <p>\u64cd\u4f5c $2$\uff1a<code>2 x</code></p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_44","title":"\u8f93\u51fa\u683c\u5f0f","text":"<p>\u8f93\u51fa\u5305\u542b\u82e5\u5e72\u884c\u6574\u6570\uff0c\u5206\u522b\u4f9d\u6b21\u5bf9\u5e94\u6bcf\u4e00\u4e2a\u64cd\u4f5c $2$ \u6240\u5f97\u7684\u7ed3\u679c\u3002</p> <pre><code>int rt[MaxN], boo[MaxN];\nstruct LeftTree {\n    struct Point {\n        int d, l, r;\n        int v;\n        int s, sum;\n    } tree[MaxN];\n    void clear() {\n        for (int i = 1; i &lt;= N; i++) {\n            rt[i] = i;\n            tree[i].s = 1;\n        }\n        tree[0].d = -1;\n    }\n    int find1(int x) {\n        if (x == rt[x]) return x;\n        return rt[x] = find1(rt[x]);\n    }\n    inline void pushdown(int x) {}\n    inline void pushup(int x) {\n        tree[x].s = tree[tree[x].l].s + tree[tree[x].r].s + 1;\n        tree[x].sum = tree[tree[x].l].sum + tree[tree[x].r].sum + tree[x].v;\n    }\n    int hebin(int x, int y) {\n        if (!x || !y) return x + y;\n        if (tree[x].v &lt; tree[y].v) swap(x, y);\n        pushdown(x);\n        tree[x].r = hebin(tree[x].r, y);\n        if (tree[tree[x].l].d &lt; tree[tree[x].r].d) swap(tree[x].l, tree[x].r);\n        tree[x].d = tree[tree[x].r].d + 1;\n        pushup(x);\n        return x;\n    }\n    int get(int x) {\n        x = find1(x);\n        return tree[x].v;\n    }\n    void delet(int x) {\n        x = find1(x);\n        boo[x] = 1;\n        rt[tree[x].l] = rt[tree[x].r] = rt[x] = hebin(tree[x].l, tree[x].r);\n        tree[x].l = tree[x].r = tree[x].d = 0;\n        tree[x].s = tree[x].sum = 0;\n    }\n} TT;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_45","title":"\u3010\u6a21\u677f\u3011\u53ef\u6301\u4e45\u5316\u5e73\u8861\u6811","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_46","title":"\u9898\u76ee\u80cc\u666f","text":"<p>\u672c\u9898\u4e3a\u9898\u76ee \u666e\u901a\u5e73\u8861\u6811 \u7684\u53ef\u6301\u4e45\u5316\u52a0\u5f3a\u7248\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_47","title":"\u9898\u76ee\u63cf\u8ff0","text":"<p>\u60a8\u9700\u8981\u5199\u4e00\u79cd\u6570\u636e\u7ed3\u6784\uff08\u53ef\u53c2\u8003\u9898\u76ee\u6807\u9898\uff09\uff0c\u6765\u7ef4\u62a4\u4e00\u4e2a\u53ef\u91cd\u6574\u6570\u96c6\u5408\uff0c\u5176\u4e2d\u9700\u8981\u63d0\u4f9b\u4ee5\u4e0b\u64cd\u4f5c\uff08 \u5bf9\u4e8e\u5404\u4e2a\u4ee5\u5f80\u7684\u5386\u53f2\u7248\u672c \uff09\uff1a</p> <p>1\u3001 \u63d2\u5165 $x$</p> <p>2\u3001 \u5220\u9664 $x$\uff08\u82e5\u6709\u591a\u4e2a\u76f8\u540c\u7684\u6570\uff0c\u5e94\u53ea\u5220\u9664\u4e00\u4e2a\uff0c\u5982\u679c\u6ca1\u6709\u8bf7\u5ffd\u7565\u8be5\u64cd\u4f5c\uff09</p> <p>3\u3001 \u67e5\u8be2 $x$ \u7684\u6392\u540d\uff08\u6392\u540d\u5b9a\u4e49\u4e3a\u6bd4\u5f53\u524d\u6570\u5c0f\u7684\u6570\u7684\u4e2a\u6570 $+1$\uff09</p> <p>4\u3001\u67e5\u8be2\u6392\u540d\u4e3a $x$ \u7684\u6570</p> <p>5\u3001 \u6c42 $x$ \u7684\u524d\u9a71\uff08\u524d\u9a71\u5b9a\u4e49\u4e3a\u5c0f\u4e8e $x$\uff0c\u4e14\u6700\u5927\u7684\u6570\uff0c\u5982\u4e0d\u5b58\u5728\u8f93\u51fa $-2^{31}+1$ \uff09</p> <p>6\u3001\u6c42 $x$ \u7684\u540e\u7ee7\uff08\u540e\u7ee7\u5b9a\u4e49\u4e3a\u5927\u4e8e $x$\uff0c\u4e14\u6700\u5c0f\u7684\u6570\uff0c\u5982\u4e0d\u5b58\u5728\u8f93\u51fa $2^{31}-1$ \uff09</p> <p>\u548c\u539f\u672c\u5e73\u8861\u6811\u4e0d\u540c\u7684\u4e00\u70b9\u662f\uff0c\u6bcf\u4e00\u6b21\u7684\u4efb\u4f55\u64cd\u4f5c\u90fd\u662f\u57fa\u4e8e\u67d0\u4e00\u4e2a\u5386\u53f2\u7248\u672c\uff0c\u540c\u65f6\u751f\u6210\u4e00\u4e2a\u65b0\u7684\u7248\u672c\u3002\uff08\u64cd\u4f5c3, 4, 5, 6\u5373\u4fdd\u6301\u539f\u7248\u672c\u65e0\u53d8\u5316\uff09</p> <p>\u6bcf\u4e2a\u7248\u672c\u7684\u7f16\u53f7\u5373\u4e3a\u64cd\u4f5c\u7684\u5e8f\u53f7\uff08\u7248\u672c0\u5373\u4e3a\u521d\u59cb\u72b6\u6001\uff0c\u7a7a\u6811\uff09</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_48","title":"\u8f93\u5165\u683c\u5f0f","text":"<p>\u7b2c\u4e00\u884c\u5305\u542b\u4e00\u4e2a\u6b63\u6574\u6570 $n$ \uff0c\u8868\u793a\u64cd\u4f5c\u7684\u603b\u6570\u3002</p> <p>\u63a5\u4e0b\u6765 $n$ \u884c\uff0c\u6bcf\u884c\u5305\u542b\u4e09\u4e2a\u6574\u6570\uff0c\u7b2c $i$ \u884c\u8bb0\u4e3a $v_i, \\text{opt}_i, x_i$\u3002</p> <p>$v_i$ \u8868\u793a\u57fa\u4e8e\u7684\u8fc7\u53bb\u7248\u672c\u53f7\uff0c$\\text{opt}_i$ \u8868\u793a\u64cd\u4f5c\u7684\u5e8f\u53f7\uff0c $x_i$ \u8868\u793a\u53c2\u4e0e\u64cd\u4f5c\u7684\u6570\u503c</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_49","title":"\u8f93\u51fa\u683c\u5f0f","text":"<p>\u6bcf\u884c\u5305\u542b\u4e00\u4e2a\u6574\u6570\uff0c\u4f9d\u6b21\u4e3a\u5404\u4e2a $3,4,5,6$ \u64cd\u4f5c\u6240\u5bf9\u5e94\u7684\u7b54\u6848</p> <p>\u5bf9\u4e8e $100\\%$ \u7684\u6570\u636e\uff0c $ 1 \\leq n \\leq 5 \\times  10^5 $ , $|x_i| \\leq {10}^9$\uff0c$0 \\le v_i &lt; i$\uff0c$1\\le \\text{opt} \\le 6$\u3002</p> <pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long \n#define INF 2147483647\nconst int MaxN=5e5+100;\nconst int MaxM=5e7+100;\nint N,M;\nint a[MaxN],rt[MaxN],tot,t1,t2,t3;\nstruct point\n{\n    int x,l,r,v,p,s;\n}tree[MaxM];\ntemplate&lt;class T&gt;\ninline void qread(T &amp;sum)\n{\n    sum=0;int boo=1;\n    char x=getchar();\n    while(x&lt;'0'||x&gt;'9'){if(x=='-')boo=-1;x=getchar();}\n    while(x&gt;='0'&amp;&amp;x&lt;='9'){sum=(sum&lt;&lt;1)+(sum&lt;&lt;3)+x-'0';x=getchar();}\n    sum*=boo;\n}\ntemplate&lt;class T&gt;\nvoid qput(T x)\n{\n    if(x&lt;0) {x=-x;putchar('-');}\n    if(x&gt;9){qput(x/10);}\n    putchar(x%10+48);\n}\ninline int newnode(int v)\n{\n    int x=++tot;\n    tree[x].l=tree[x].r=0;\n    tree[x].p=rand();\n    tree[x].v=v;\n    tree[x].s=1;\n    return x;\n}\ninline void updata(int x)\n{\n    tree[x].s=tree[tree[x].l].s+tree[tree[x].r].s+1;\n}\ninline int hebin(int x,int y)\n{\n    if(!x||!y) return x+y;\n    if(tree[x].p&lt;tree[y].p)\n    {\n        int p=newnode(0);\n        tree[p]=tree[x];\n        tree[p].r=hebin(tree[p].r,y);\n        updata(p);\n        return p;\n    }\n    else\n    {\n        int p=newnode(0);\n        tree[p]=tree[y];\n        tree[p].l=hebin(x,tree[p].l);\n        updata(p);\n        return p;\n    }\n}\nvoid split(int x,int k,int &amp;l,int &amp;r)\n{\n    if(!x)\n    {\n        l=r=0;\n        return;\n    }\n    int p=newnode(0);\n    tree[p]=tree[x];\n    if(tree[p].v&lt;=k)\n    {\n        l=p;\n        split(tree[p].r,k,tree[p].r,r);\n    }\n    else\n    {\n        r=p;\n        split(tree[p].l,k,l,tree[p].l);\n    }\n    updata(p);\n}\nint ith(int x,int k)\n{\n    while(x)\n    {\n        if(k&lt;=tree[tree[x].l].s)\n        {\n            x=tree[x].l;\n        }\n        else if(k==tree[tree[x].l].s+1)\n        {\n            return tree[x].v;\n        }\n        else\n        {\n            k-=(tree[tree[x].l].s+1);\n            x=tree[x].r;\n        }\n    }\n    return 0;\n}\ninline int query1(int x)\n{\n    int ans=-INF;\n    while(x)\n    {\n        ans=max(ans,tree[x].v);\n        x=tree[x].r;\n    }\n    return ans;\n}\ninline int query2(int x)\n{\n    int ans=INF;\n    while(x)\n    {\n        ans=min(ans,tree[x].v);\n        x=tree[x].l;\n    }\n    return ans;\n}\nsigned main()\n{\n    qread(N);\n    for(int i=1;i&lt;=N;i++)\n    {\n        int v,opt,x;\n        qread(v);qread(opt);qread(x);\n        if(opt==1)\n        {\n            split(rt[v],x-1,t1,t2);\n            int p=newnode(x);\n            rt[i]=hebin(hebin(t1,p),t2);\n        }\n        if(opt==2)\n        {\n            split(rt[v],x,t1,t3);\n            split(t1,x-1,t1,t2);\n            t2=hebin(tree[t2].l,tree[t2].r);\n            rt[i]=hebin(hebin(t1,t2),t3);\n        }\n        if(opt==3)\n        {\n            rt[i]=rt[v];\n            split(rt[v],x-1,t1,t3);\n            int ans=tree[t1].s+1;\n            qput(ans);putchar('\\n');\n        }\n        if(opt==4)\n        {\n            rt[i]=rt[v];\n            int ans=ith(rt[i],x);\n            qput(ans);putchar('\\n');\n        }\n        if(opt==5)\n        {\n            rt[i]=rt[v];\n            split(rt[i],x-1,t1,t2);\n            int ans=query1(t1);\n            qput(ans);putchar('\\n');\n        }\n        if(opt==6)\n        {\n            rt[i]=rt[v];\n            split(rt[i],x,t1,t2);\n            int ans=query2(t2);\n            qput(ans);putchar('\\n');\n        }\n    }\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_50","title":"\u3010\u6a21\u677f\u3011\u53ef\u6301\u4e45\u5316\u6587\u827a\u5e73\u8861\u6811","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_51","title":"\u9898\u76ee\u63cf\u8ff0","text":"<p>\u60a8\u9700\u8981\u5199\u4e00\u79cd\u6570\u636e\u7ed3\u6784\uff0c\u6765\u7ef4\u62a4\u4e00\u4e2a\u5e8f\u5217\uff0c\u5176\u4e2d\u9700\u8981\u63d0\u4f9b\u4ee5\u4e0b\u64cd\u4f5c\uff08\u5bf9\u4e8e\u5404\u4e2a\u4ee5\u5f80\u7684\u5386\u53f2\u7248\u672c\uff09\uff1a</p> <ol> <li>\u5728\u7b2c $p$ \u4e2a\u6570\u540e\u63d2\u5165\u6570 $x$ \u3002</li> <li>\u5220\u9664\u7b2c $p$ \u4e2a\u6570\u3002</li> <li>\u7ffb\u8f6c\u533a\u95f4 $[l,r]$\uff0c\u4f8b\u5982\u539f\u5e8f\u5217\u662f ${5,4,3,2,1}$\uff0c\u7ffb\u8f6c\u533a\u95f4 $[2,4]$ \u540e\uff0c\u7ed3\u679c\u662f ${5,2,3,4,1}$\u3002</li> <li>\u67e5\u8be2\u533a\u95f4 $[l,r]$ \u4e2d\u6240\u6709\u6570\u7684\u548c\u3002</li> </ol> <p>\u548c\u539f\u672c\u5e73\u8861\u6811\u4e0d\u540c\u7684\u4e00\u70b9\u662f\uff0c\u6bcf\u4e00\u6b21\u7684\u4efb\u4f55\u64cd\u4f5c\u90fd\u662f\u57fa\u4e8e\u67d0\u4e00\u4e2a\u5386\u53f2\u7248\u672c\uff0c\u540c\u65f6\u751f\u6210\u4e00\u4e2a\u65b0\u7684\u7248\u672c\uff08\u64cd\u4f5c $4$ \u5373\u4fdd\u6301\u539f\u7248\u672c\u65e0\u53d8\u5316\uff09\uff0c\u65b0\u7248\u672c\u5373\u7f16\u53f7\u4e3a\u6b64\u6b21\u64cd\u4f5c\u7684\u5e8f\u53f7\u3002</p> <p>\u672c\u9898\u5f3a\u5236\u5728\u7ebf\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_52","title":"\u8f93\u5165\u683c\u5f0f","text":"<p>\u7b2c\u4e00\u884c\u5305\u542b\u4e00\u4e2a\u6574\u6570 $n$\uff0c\u8868\u793a\u64cd\u4f5c\u7684\u603b\u6570\u3002</p> <p>\u63a5\u4e0b\u6765 $n$ \u884c\uff0c\u6bcf\u884c\u524d\u4e24\u4e2a\u6574\u6570 $v_i, \\mathrm{opt}_i$\uff0c$v_i$ \u8868\u793a\u57fa\u4e8e\u7684\u8fc7\u53bb\u7248\u672c\u53f7\uff08$0 \\le v_i &lt; i$\uff09\uff0c$\\mathrm{opt}_i$ \u8868\u793a\u64cd\u4f5c\u7684\u5e8f\u53f7\uff08$1 \\le \\mathrm{opt}_i \\le 4$\uff09\u3002</p> <p>\u82e5 $\\mathrm{opt}_i=1$\uff0c\u5219\u63a5\u4e0b\u6765\u4e24\u4e2a\u6574\u6570 $p_i, x_i$\uff0c\u8868\u793a\u64cd\u4f5c\u4e3a\u5728\u7b2c $p_i$ \u4e2a\u6570\u540e\u63d2\u5165\u6570 $x$ \u3002 \u82e5 $\\mathrm{opt}_i=2$\uff0c\u5219\u63a5\u4e0b\u6765\u4e00\u4e2a\u6574\u6570 $p_i$\uff0c\u8868\u793a\u64cd\u4f5c\u4e3a\u5220\u9664\u7b2c $p_i$ \u4e2a\u6570\u3002 \u82e5 $\\mathrm{opt}_i=3$\uff0c\u5219\u63a5\u4e0b\u6765\u4e24\u4e2a\u6574\u6570 $l_i, r_i$\uff0c\u8868\u793a\u64cd\u4f5c\u4e3a\u7ffb\u8f6c\u533a\u95f4 $[l_i, r_i]$\u3002 \u82e5 $\\mathrm{opt}_i=4$\uff0c\u5219\u63a5\u4e0b\u6765\u4e24\u4e2a\u6574\u6570 $l_i, r_i$\uff0c\u8868\u793a\u64cd\u4f5c\u4e3a\u67e5\u8be2\u533a\u95f4 $[l_i, r_i]$ \u7684\u548c\u3002</p> <p>\u5f3a\u5236\u5728\u7ebf\u89c4\u5219\uff1a \u4ee4\u5f53\u524d\u64cd\u4f5c\u4e4b\u524d\u7684\u6700\u540e\u4e00\u6b21 $4$ \u64cd\u4f5c\u7684\u7b54\u6848\u4e3a $lastans$\uff08\u5982\u679c\u4e4b\u524d\u6ca1\u6709 $4$ \u64cd\u4f5c\uff0c\u5219 $lastans=0$\uff09\u3002 \u5219\u6b64\u6b21\u64cd\u4f5c\u7684 $p_i,x_i$ \u6216 $l_i,r_i$ \u5747\u6309\u4f4d\u5f02\u6216\u4e0a $lastans$ \u5373\u53ef\u5f97\u5230\u771f\u5b9e\u7684 $p_i,x_i$ \u6216 $l_i,r_i$\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_53","title":"\u8f93\u51fa\u683c\u5f0f","text":"<p>\u5bf9\u4e8e\u6bcf\u4e2a\u5e8f\u53f7\u4e3a $4$ \u7684\u67e5\u8be2\u64cd\u4f5c\uff0c\u8f93\u51fa\u4e00\u884c\u4e00\u4e2a\u6570\u8868\u793a\u533a\u95f4\u7684\u548c\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_54","title":"\u63d0\u793a","text":"<p>\u5f3a\u5236\u5728\u7ebf\uff1a\u4ee5\u4e0b\u9488\u5bf9 $p_i, x_i, l_i, r_i$ \u7684\u9650\u5236\u5747\u662f\u6309\u4f4d\u5f02\u6216 $lastans$ \u540e\u7684\u9650\u5236\u3002</p> <p>\u5bf9\u4e8e $100\\%$ \u7684\u6570\u636e\uff0c$1 \\le n \\le 2 \\times {10}^5$\uff0c$|x_i| &lt; {10}^6$\u3002</p> <pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long \n#define int ll\n#define ls p&lt;&lt;1\n#define rs p&lt;&lt;1|1\n#define lowbit(x) ((x)&amp;(-x))\nconst int MaxN=2e7+100;\nconst int INF=1e9;\nint N,M,T,tot,rt[MaxN],ans,t1,t2,t3;\nstruct point\n{\n    int s,l,r,sum,lan,p,v;\n}tree[MaxN];\ntemplate&lt;class T&gt;\ninline int newnode(int v)\n{\n    int x=++tot;\n    tree[x].l=tree[x].r=0;\n    tree[x].p=rand();\n    tree[x].v=v;\n    tree[x].sum=v;\n    tree[x].s=1;\n    return x;\n}\ninline void updata(int x)\n{\n    tree[x].s=tree[tree[x].l].s+tree[tree[x].r].s+1;\n    tree[x].sum=tree[tree[x].l].sum+tree[tree[x].r].sum+tree[x].v;\n}\ninline void overturn(int x)\n{\n    swap(tree[x].l,tree[x].r);\n    tree[x].lan^=1;\n}\ninline void pushdown(int x)\n{\n    if(!tree[x].lan) return;\n    if(tree[x].l)\n    {\n        int p=++tot;\n        tree[p]=tree[tree[x].l];\n        tree[x].l=p;\n        overturn(p);\n    }\n    if(tree[x].r)\n    {\n        int p=++tot;\n        tree[p]=tree[tree[x].r];\n        tree[x].r=p;\n        overturn(p);\n    }\n    tree[x].lan=0;\n}\ninline int hebin(int x,int y)\n{\n    if(!x||!y) return x+y;\n    if(tree[x].p&lt;tree[y].p)\n    {\n        int p=newnode(0);\n        tree[p]=tree[x];\n        pushdown(p);\n        tree[p].r=hebin(tree[p].r,y);\n        updata(p);\n        return p;\n    }\n    else\n    {\n        int p=newnode(0);\n        tree[p]=tree[y];\n        pushdown(p);\n        tree[p].l=hebin(x,tree[p].l);\n        updata(p);\n        return p;\n    }\n}\nvoid split(int x,int k,int &amp;l,int &amp;r)\n{\n    if(!x)\n    {\n        l=r=0;\n        return;\n    }\n    int p=newnode(0);\n    tree[p]=tree[x];\n    pushdown(p);\n    if(tree[tree[p].l].s+1&lt;=k)\n    {\n        l=p;\n        split(tree[p].r,k-(tree[tree[p].l].s+1),tree[p].r,r);\n    }\n    else\n    {\n        r=p;\n        split(tree[p].l,k,l,tree[p].l);\n    }\n    updata(p);\n}\nvoid print(int x)\n{\n    pushdown(x);\n    if(tree[x].l) print(tree[x].l);\n    qput(tree[x].v);putchar(' ');\n    if(tree[x].r) print(tree[x].r);\n}\ninline void Solve()\n{\n    qread(N);\n    for(int i=1;i&lt;=N;i++)\n    {\n        int v,opt;qread(v);qread(opt);\n        int x,y;\n        if(opt==1)\n        {\n            qread(x);qread(y);\n            x^=ans;y^=ans;\n            split(rt[v],x,t1,t3);\n            t2=newnode(y);\n            rt[i]=hebin(hebin(t1,t2),t3);\n        }\n        if(opt==2)\n        {\n            qread(x);\n            x^=ans;\n            split(rt[v],x,t1,t3);\n            split(t1,x-1,t1,t2);\n            rt[i]=hebin(t1,t3);\n        }\n        if(opt==3)\n        {\n            qread(x);qread(y);\n            x^=ans;y^=ans;\n            split(rt[v],y,t1,t3);\n            split(t1,x-1,t1,t2);\n            overturn(t2);\n            rt[i]=hebin(hebin(t1,t2),t3);\n        }\n        if(opt==4)\n        {\n            rt[i]=rt[v];\n            qread(x);qread(y);\n            x^=ans;y^=ans;\n            split(rt[i],y,t1,t3);\n            split(t1,x-1,t1,t2);\n            ans=tree[t2].sum;\n            qput(ans);putchar('\\n');\n        }\n//      print(rt[i]);putchar('\\n');\n    }\n}\nsigned main()\n{\n    T=1;\n    while(T--) Solve();\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#lca","title":"LCA","text":"<pre><code>struct LCA {\n    int dep[MaxN], fa[MaxN][21];\n    inline void dfs1(int x, int f) {\n        fa[x][0] = f;\n        dep[x] = dep[f] + 1;\n        for (int j = 1; j &lt;= 20; j++) {\n            fa[x][j] = fa[fa[x][j - 1]][j - 1];\n        }\n        for (int i = 0; i &lt; (int)G1[x].size(); i++) {\n            int y = G1[x][i];\n            if (y == f) continue;\n            dfs1(y, x);\n        }\n    }\n    int lca(int x, int y) {\n        if (dep[x] &lt; dep[y]) swap(x, y);\n        for (int i = 20; i &gt;= 0; i--) {\n            if (dep[fa[x][i]] &gt;= dep[y]) x = fa[x][i];\n            if (x == y) return x;\n        }\n        for (int i = 20; i &gt;= 0; i--) {\n            if (fa[x][i] != fa[y][i]) {\n                x = fa[x][i];\n                y = fa[y][i];\n            }\n        }\n        return fa[x][0];\n    }\n} LCA;\n</code></pre> <pre><code>struct LCA {\n    vector&lt;int&gt; dep, re, st, logn;\n    vector&lt;vector&lt;int&gt;&gt; F;\n    static const int LogN = 21;\n    int top;\n    void dfs1(int x, int f) {\n        dep[x] = dep[f] + 1;\n        st[++top] = x;\n        re[x] = top;\n        for (int i = 0; i &lt; (int)G1[x].size(); i++) {\n            int y = G1[x][i];\n            if (y == f) continue;\n            dfs1(y, x);\n            st[++top] = x;\n        }\n    }\n    int lca(int x, int y) {\n        int l = re[x];\n        int r = re[y];\n        if (l &gt; r) swap(l, r);\n        int k = logn[r - l + 1];\n        return dep[F[l][k]] &lt; dep[F[r - (1 &lt;&lt; k) + 1][k]]\n                ? F[l][k]\n                : F[r - (1 &lt;&lt; k) + 1][k];\n    }\n    inline void clear(int N) {\n        dep.assign(N, 0);\n        re.assign(N, 0);\n        st.assign(N, 0);\n        logn.assign(N, 0);\n        top = 0;\n        F.assign(N, vector&lt;int&gt;(LogN, 0));\n    }\n    inline void solve(int rt, int N) {\n        clear(2 * N + 1);\n        dfs1(rt, 0);\n        for (int i = 1; i &lt;= 2 * N; i++) {\n            F[i][0] = st[i];\n        }\n        for (int j = 1; j &lt; LogN; j++) {\n            for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= 2 * N; i++) {\n                F[i][j] = dep[F[i][j - 1]] &lt; dep[F[i + (1 &lt;&lt; (j - 1))][j - 1]]\n                            ? F[i][j - 1]\n                            : F[i + (1 &lt;&lt; (j - 1))][j - 1];\n            }\n        }\n\n        logn[0] = -1;\n        for (int i = 1; i &lt;= 2 * N; i++) {\n            logn[i] = logn[i / 2] + 1;\n        }\n    }\n} Lca;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#vani","title":"[Vani\u6709\u7ea6\u4f1a]\u96e8\u5929\u7684\u5c3e\u5df4 /\u3010\u6a21\u677f\u3011\u7ebf\u6bb5\u6811\u5408\u5e76","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_55","title":"\u9898\u76ee\u63cf\u8ff0","text":"<p>\u9996\u5148\u6751\u843d\u91cc\u7684\u4e00\u5171\u6709 $n$ \u5ea7\u623f\u5c4b\uff0c\u5e76\u5f62\u6210\u4e00\u4e2a\u6811\u72b6\u7ed3\u6784\u3002\u7136\u540e\u6551\u6d4e\u7cae\u5206 $m$ \u6b21\u53d1\u653e\uff0c\u6bcf\u6b21\u9009\u62e9\u4e24\u4e2a\u623f\u5c4b $(x,~y)$\uff0c\u7136\u540e\u5bf9\u4e8e $x$ \u5230 $y$ \u7684\u8def\u5f84\u4e0a(\u542b $x$ \u548c $y$)\u6bcf\u5ea7\u623f\u5b50\u91cc\u53d1\u653e\u4e00\u888b $z$ \u7c7b\u578b\u7684\u6551\u6d4e\u7cae\u3002</p> <p>\u7136\u540e\u6df1\u7ed8\u91cc\u60f3\u77e5\u9053\uff0c\u5f53\u6240\u6709\u7684\u6551\u6d4e\u7cae\u53d1\u653e\u5b8c\u6bd5\u540e\uff0c\u6bcf\u5ea7\u623f\u5b50\u91cc\u5b58\u653e\u7684\u6700\u591a\u7684\u662f\u54ea\u79cd\u6551\u6d4e\u7cae\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_56","title":"\u8f93\u5165\u683c\u5f0f","text":"<p>\u8f93\u5165\u7684\u7b2c\u4e00\u884c\u662f\u4e24\u4e2a\u7528\u7a7a\u683c\u9694\u5f00\u7684\u6b63\u6574\u6570\uff0c\u5206\u522b\u4ee3\u8868\u623f\u5c4b\u7684\u4e2a\u6570 $n$ \u548c\u6551\u6d4e\u7cae\u53d1\u653e\u7684\u6b21\u6570 $m$\u3002</p> <p>\u7b2c $2$ \u5230 \u7b2c $n$ \u884c\uff0c\u6bcf\u884c\u6709\u4e24\u4e2a\u7528\u7a7a\u683c\u9694\u5f00\u7684\u6574\u6570 $a,~b$\uff0c\u4ee3\u8868\u5b58\u5728\u4e00\u6761\u8fde\u63a5\u623f\u5c4b $a$ \u548c $b$ \u7684\u8fb9\u3002</p> <p>\u7b2c $(n + 1)$ \u5230\u7b2c $(n + m)$ \u884c\uff0c\u6bcf\u884c\u6709\u4e09\u4e2a\u7528\u7a7a\u683c\u9694\u5f00\u7684\u6574\u6570 $x,~y,~z$\uff0c\u4ee3\u8868\u4e00\u6b21\u6551\u6d4e\u7cae\u7684\u53d1\u653e\u662f\u4ece $x$ \u5230 $y$ \u8def\u5f84\u4e0a\u7684\u6bcf\u680b\u623f\u5b50\u53d1\u653e\u4e86\u4e00\u888b $z$ \u7c7b\u578b\u7684\u6551\u6d4e\u7cae\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_57","title":"\u8f93\u51fa\u683c\u5f0f","text":"<p>\u8f93\u51fa $n$ \u884c\uff0c\u6bcf\u884c\u4e00\u4e2a\u6574\u6570\uff0c\u7b2c $i$ \u884c\u7684\u6574\u6570\u4ee3\u8868 $i$ \u53f7\u623f\u5c4b\u5b58\u653e\u6700\u591a\u7684\u6551\u6d4e\u7cae\u7684\u79cd\u7c7b\uff0c\u5982\u679c\u6709\u591a\u79cd\u6551\u6d4e\u7cae\u90fd\u662f\u5b58\u653e\u6700\u591a\u7684\uff0c\u8f93\u51fa\u79cd\u7c7b\u7f16\u53f7\u6700\u5c0f\u7684\u4e00\u79cd\u3002</p> <p>\u5982\u679c\u67d0\u5ea7\u623f\u5c4b\u6ca1\u6709\u6551\u6d4e\u7cae\uff0c\u5219\u8f93\u51fa $0$\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_8","title":"\u6837\u4f8b #1","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_9","title":"\u6837\u4f8b\u8f93\u5165 #1","text":"<pre><code>5 3\n1 2\n3 1\n3 4\n5 3\n2 3 3\n1 5 2\n3 3 3\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_10","title":"\u6837\u4f8b\u8f93\u51fa #1","text":"<pre><code>2\n3\n3\n0\n2\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_58","title":"\u63d0\u793a","text":"<ul> <li>\u5bf9\u4e8e $20\\%$ \u7684\u6570\u636e\uff0c\u4fdd\u8bc1 $n, m \\leq 100$\u3002</li> <li>\u5bf9\u4e8e $50\\%$ \u7684\u6570\u636e\uff0c\u4fdd\u8bc1 $n, m \\leq 2 \\times 10^3$\u3002</li> <li>\u5bf9\u4e8e $100\\%$ \u6d4b\u8bd5\u6570\u636e\uff0c\u4fdd\u8bc1 $1 \\leq n, m \\leq 10^5$\uff0c$1 \\leq a,b,x,y \\leq n$\uff0c$1 \\leq z \\leq 10^5$\u3002  </li> </ul>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_59","title":"\u601d\u8def","text":"<p>\u5229\u7528\u6811\u4e0a\u5dee\u5206: \u60f3\u8981\u518d$(x,y)$\u533a\u95f4\u5185\u52a0v\uff1b \u5219$d[x]+=v;d[y]+=y;d[lca(x,y)]-=v;d[fa[lca(x,y)]]-=v;$ \u7136\u540e\u6700\u540e\u628a\u6570\u636e\u9012\u589e\u5230$root$\u4e0a   </p> <pre><code>struct TT {\n    struct Point {\n        int l, r, v;\n    } tree[MaxN * 40];\n    int tot = 0;\n    int change1(int p, int l, int r, int k, int v) {\n        int now = ++tot;\n        int mid = (l + r) &gt;&gt; 1;\n        tree[now] = tree[p];\n        if (l == r) {\n            tree[now].v += v;\n            return now;\n        }\n        if (k &lt;= mid)\n            tree[now].l = change1(tree[now].l, l, mid, k, v);\n        else\n            tree[now].r = change1(tree[now].r, mid + 1, r, k, v);\n        tree[now].v = max(tree[tree[now].l].v, tree[tree[now].r].v);\n        return now;\n    }\n    int hebin(int x, int y) {\n        if (!x || !y) return x + y;\n        tree[x].l = hebin(tree[x].l, tree[y].l);\n        tree[x].r = hebin(tree[x].r, tree[y].r);\n        if (!tree[x].l &amp;&amp; !tree[x].r) {\n            tree[x].v += tree[y].v;\n            return x;\n        }\n        tree[x].v = max(tree[tree[x].l].v, tree[tree[x].r].v);\n        return x;\n    }\n    int hebin(int x, int y) {\n        if (!x || !y) return x + y;\n        int p = ++tot;\n        tree[p].l = hebin(tree[x].l, tree[y].l);\n        tree[p].r = hebin(tree[x].r, tree[y].r);\n        if (!tree[p].l &amp;&amp; !tree[p].r) {\n            tree[p].sum = tree[x].sum + tree[y].sum;\n            tree[p].id = tree[x].id;\n            return p;\n        }\n        tree[p] = pushup(tree[tree[p].l], tree[tree[p].r], tree[p].l, tree[p].r);\n        return p;\n    }\n    int bina(int x, int l, int r) {\n        if (l == r) return l;\n        int mid = (l + r) &gt;&gt; 1;\n        if (tree[tree[x].l].v &gt;= tree[tree[x].r].v) return bina(tree[x].l, l, mid);\n        else return bina(tree[x].r, mid + 1, r);\n    }\n    void solve(int x, int f) {\n        for (auto y : G1[x]) {\n            if (y == f) continue;\n            solve(y, x);\n            rt[x] = hebin(rt[x], rt[y]);\n        }\n        if (!tree[rt[x]].v) ans[x] = 0;\n        else ans[x] = bina(rt[x], 1, INF);\n    }\n} TT;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_60","title":"\u3010\u6a21\u677f\u3011\u7ebf\u6bb5\u6811\u5206\u88c2","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_61","title":"\u9898\u76ee\u63cf\u8ff0","text":"<p>\u7ed9\u51fa\u4e00\u4e2a\u53ef\u91cd\u96c6 $a$\uff08\u7f16\u53f7\u4e3a $1$\uff09\uff0c\u5b83\u652f\u6301\u4ee5\u4e0b\u64cd\u4f5c\uff1a</p> <p><code>0 p x y</code>\uff1a\u5c06\u53ef\u91cd\u96c6 $p$ \u4e2d\u5927\u4e8e\u7b49\u4e8e $x$ \u4e14\u5c0f\u4e8e\u7b49\u4e8e $y$ \u7684\u503c\u79fb\u52a8\u5230\u4e00\u4e2a\u65b0\u7684\u53ef\u91cd\u96c6\u4e2d\uff08\u65b0\u53ef\u91cd\u96c6\u7f16\u53f7\u4e3a\u4ece $2$ \u5f00\u59cb\u7684\u6b63\u6574\u6570\uff0c\u662f\u4e0a\u4e00\u6b21\u4ea7\u751f\u7684\u65b0\u53ef\u91cd\u96c6\u7684\u7f16\u53f7+1\uff09\u3002</p> <p><code>1 p t</code>\uff1a\u5c06\u53ef\u91cd\u96c6 $t$ \u4e2d\u7684\u6570\u653e\u5165\u53ef\u91cd\u96c6 $p$\uff0c\u4e14\u6e05\u7a7a\u53ef\u91cd\u96c6 $t$\uff08\u6570\u636e\u4fdd\u8bc1\u5728\u6b64\u540e\u7684\u64cd\u4f5c\u4e2d\u4e0d\u4f1a\u51fa\u73b0\u53ef\u91cd\u96c6 $t$\uff09\u3002</p> <p><code>2 p x q</code>\uff1a\u5728 $p$ \u8fd9\u4e2a\u53ef\u91cd\u96c6\u4e2d\u52a0\u5165 $x$ \u4e2a\u6570\u5b57 $q$\u3002</p> <p><code>3 p x y</code>\uff1a\u67e5\u8be2\u53ef\u91cd\u96c6 $p$ \u4e2d\u5927\u4e8e\u7b49\u4e8e $x$ \u4e14\u5c0f\u4e8e\u7b49\u4e8e $y$ \u7684\u503c\u7684\u4e2a\u6570\u3002</p> <p><code>4 p k</code>\uff1a\u67e5\u8be2\u5728 $p$ \u8fd9\u4e2a\u53ef\u91cd\u96c6\u4e2d\u7b2c $k$ \u5c0f\u7684\u6570\uff0c\u4e0d\u5b58\u5728\u65f6\u8f93\u51fa <code>-1</code>\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_62","title":"\u8f93\u5165\u683c\u5f0f","text":"<p>\u7b2c\u4e00\u884c\u4e24\u4e2a\u6574\u6570 $n,m$\uff0c\u8868\u793a\u53ef\u91cd\u96c6\u4e2d\u7684\u6570\u5728 $1\\sim n$ \u7684\u8303\u56f4\u5185\uff0c\u6709 $m$ \u4e2a\u64cd\u4f5c\u3002</p> <p>\u63a5\u4e0b\u6765\u4e00\u884c $n$ \u4e2a\u6574\u6570\uff0c\u8868\u793a $1 \\sim n$ \u8fd9\u4e9b\u6570\u5728 $a$ \u4e2d\u51fa\u73b0\u7684\u6b21\u6570 $(a_{i} \\leq m)$\u3002</p> <p>\u63a5\u4e0b\u6765\u7684 $m$ \u884c\u6bcf\u884c\u82e5\u5e72\u4e2a\u6574\u6570\uff0c\u7b2c\u4e00\u4e2a\u6570\u4e3a\u64cd\u4f5c\u7684\u7f16\u53f7 $opt$\uff08$0 \\leq opt \\leq 4$\uff09\uff0c\u4ee5\u9898\u76ee\u63cf\u8ff0\u4e3a\u51c6\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_63","title":"\u8f93\u51fa\u683c\u5f0f","text":"<p>\u4f9d\u6b21\u8f93\u51fa\u6bcf\u4e2a\u67e5\u8be2\u64cd\u4f5c\u7684\u7b54\u6848\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_11","title":"\u6837\u4f8b #1","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_12","title":"\u6837\u4f8b\u8f93\u5165 #1","text":"<pre><code>5 12\n0 0 0 0 0\n2 1 1 1\n2 1 1 2\n2 1 1 3\n3 1 1 3\n4 1 2\n2 1 1 4\n2 1 1 5\n0 1 2 4\n2 2 1 4\n3 2 2 4\n1 1 2\n4 1 3\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_13","title":"\u6837\u4f8b\u8f93\u51fa #1","text":"<pre><code>3\n2\n4\n3\n</code></pre> <pre><code>struct TT {\n    struct Point {\n        int sum, l, r;\n    } tree[MaxM];\n    int tot = 0;\n    void del(int x) {\n        tree[x].sum = 0;\n        tree[x].l = tree[x].r = 0;\n    }\n    int newnode() {\n        int x = ++tot;\n        tree[x].sum = 0;\n        tree[x].l = tree[x].r = 0;\n        return x;\n    }\n    void pushup(int x) {\n        tree[x].sum = tree[tree[x].l].sum + tree[tree[x].r].sum;\n    }\n    void split(int x, int &amp;y, int k) {\n        if (!x) return;\n        y = newnode();\n        int v = tree[tree[x].l].sum;\n        if (k &gt; v) {\n            split(tree[x].r, tree[y].r, k - v);\n        } else {\n            swap(tree[x].r, tree[y].r);\n        }\n        if (k &lt; v) {\n            split(tree[x].l, tree[y].l, k);\n        }\n        tree[y].sum = tree[x].sum - k;\n        tree[x].sum = k;\n    }\n    int hebin(int x, int y) {\n        if (!x || !y) return x + y;\n        tree[x].l = hebin(tree[x].l, tree[y].l);\n        tree[x].r = hebin(tree[x].r, tree[y].r);\n        if (!tree[x].l &amp;&amp; !tree[x].r) {\n            tree[x].sum += tree[y].sum;\n            return x;\n        }\n        tree[x].sum = tree[tree[x].l].sum + tree[tree[x].r].sum;\n        del(y);\n        return x;\n    }\n    int query(int p, int l, int r, int k) { //\u5de6\u7559k\u4e2a\n        if (l == r) {\n            return l;\n        }\n        int mid = (l + r) &gt;&gt; 1;\n        if (tree[tree[p].l].sum &gt;= k)\n            return query(tree[p].l, l, mid, k);\n        else\n            return query(tree[p].r, mid + 1, r, k - tree[tree[p].l].sum);\n    }\n    int query1(int p, int l, int r, int x, int y) {\n        if (l &gt;= x &amp;&amp; r &lt;= y) {\n            return tree[p].sum;\n        }\n        int mid = (l + r) &gt;&gt; 1;\n        int ans = 0;\n        if (mid &gt;= x) ans += query1(tree[p].l, l, mid, x, y);\n        if (mid &lt; y) ans += query1(tree[p].r, mid + 1, r, x, y);\n        return ans;\n    }\n    int change(int p, int l, int r, int k, int v) {\n        if (!p) p = newnode();\n        if (l == r) {\n            tree[p].sum += v;\n            return p;\n        }\n        int mid = (l + r) &gt;&gt; 1;\n        if (mid &gt;= k)\n            tree[p].l = change(tree[p].l, l, mid, k, v);\n        else\n            tree[p].r = change(tree[p].r, mid + 1, r, k, v);\n        pushup(p);\n        return p;\n    }\n} TT;\ninline void Solve() {\n    cin &gt;&gt; N &gt;&gt; M;\n    int num = 1;\n    for (int i = 1; i &lt;= N; i++) {\n        cin &gt;&gt; a[i];\n        rt[1] = TT.change(rt[1], 1, N, i, a[i]);\n    }\n    for (int i = 1; i &lt;= M; i++) {\n        int opt, x, y, p;\n        cin &gt;&gt; opt;\n        if (opt == 0) {\n            cin &gt;&gt; p &gt;&gt; x &gt;&gt; y;\n            int k1 = TT.query1(rt[p], 1, N, 1, y);\n            int k2 = TT.query1(rt[p], 1, N, x, y);\n            int tt = 0;\n            TT.split(rt[p], rt[++num], k1 - k2);\n            TT.split(rt[num], tt, k2);\n            rt[p] = TT.hebin(rt[p], tt);\n        } else if (opt == 1) {\n            cin &gt;&gt; p &gt;&gt; x;\n            rt[p] = TT.hebin(rt[p], rt[x]);\n\n        } else if (opt == 2) {\n            cin &gt;&gt; p &gt;&gt; x &gt;&gt; y;\n            rt[p] = TT.change(rt[p], 1, N, y, x);\n        } else if (opt == 3) {\n            cin &gt;&gt; p &gt;&gt; x &gt;&gt; y;\n            int ans = TT.query1(rt[p], 1, N, x, y);\n            cout &lt;&lt; ans &lt;&lt; endl;\n        } else if (opt == 4) {\n            cin &gt;&gt; p &gt;&gt; x;\n            int ans = -1;\n            if (TT.tree[rt[p]].sum &gt;= x) ans = TT.query(rt[p], 1, N, x);\n            cout &lt;&lt; ans &lt;&lt; endl;\n        }\n    }\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_64","title":"\u6811\u5957\u6811","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1fhq-treap","title":"1.\u7ebf\u6bb5\u6811\u5957FHQ-treap","text":"<p>\u6bcf\u4e2a\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e00\u4e2a\u5bf9\u5e94\u533a\u95f4\u7684\u5e73\u8861\u6811 </p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_65","title":"\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_66","title":"\u9898\u76ee\u63cf\u8ff0","text":"<p>\u60a8\u9700\u8981\u5199\u4e00\u79cd\u6570\u636e\u7ed3\u6784\uff08\u53ef\u53c2\u8003\u9898\u76ee\u6807\u9898\uff09\uff0c\u6765\u7ef4\u62a4\u4e00\u4e2a\u6709\u5e8f\u6570\u5217\uff0c\u5176\u4e2d\u9700\u8981\u63d0\u4f9b\u4ee5\u4e0b\u64cd\u4f5c\uff1a</p> <ol> <li> <p>\u67e5\u8be2 $k$ \u5728\u533a\u95f4\u5185\u7684\u6392\u540d</p> </li> <li> <p>\u67e5\u8be2\u533a\u95f4\u5185\u6392\u540d\u4e3a $k$ \u7684\u503c</p> </li> <li> <p>\u4fee\u6539\u67d0\u4e00\u4f4d\u503c\u4e0a\u7684\u6570\u503c</p> </li> <li> <p>\u67e5\u8be2 $k$ \u5728\u533a\u95f4\u5185\u7684\u524d\u9a71\uff08\u524d\u9a71\u5b9a\u4e49\u4e3a\u4e25\u683c\u5c0f\u4e8e $x$\uff0c\u4e14\u6700\u5927\u7684\u6570\uff0c\u82e5\u4e0d\u5b58\u5728\u8f93\u51fa <code>-2147483647</code>\uff09</p> </li> <li> <p>\u67e5\u8be2 $k$ \u5728\u533a\u95f4\u5185\u7684\u540e\u7ee7\uff08\u540e\u7ee7\u5b9a\u4e49\u4e3a\u4e25\u683c\u5927\u4e8e $x$\uff0c\u4e14\u6700\u5c0f\u7684\u6570\uff0c\u82e5\u4e0d\u5b58\u5728\u8f93\u51fa <code>2147483647</code>\uff09</p> </li> </ol>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_67","title":"\u8f93\u5165\u683c\u5f0f","text":"<p>\u7b2c\u4e00\u884c\u4e24\u4e2a\u6570 $n,m$\uff0c\u8868\u793a\u957f\u5ea6\u4e3a $n$ \u7684\u6709\u5e8f\u5e8f\u5217\u548c $m$ \u4e2a\u64cd\u4f5c\u3002</p> <p>\u7b2c\u4e8c\u884c\u6709 $n$ \u4e2a\u6570\uff0c\u8868\u793a\u6709\u5e8f\u5e8f\u5217\u3002</p> <p>\u4e0b\u9762\u6709 $m$ \u884c\uff0c$opt$ \u8868\u793a\u64cd\u4f5c\u6807\u53f7\u3002</p> <p>\u82e5 $opt=1$\uff0c\u5219\u4e3a\u64cd\u4f5c $1$\uff0c\u4e4b\u540e\u6709\u4e09\u4e2a\u6570 $l~r~k$\uff0c\u8868\u793a\u67e5\u8be2 $k$ \u5728\u533a\u95f4 $[l,r]$ \u7684\u6392\u540d\u3002</p> <p>\u82e5 $opt=2$\uff0c\u5219\u4e3a\u64cd\u4f5c $2$\uff0c\u4e4b\u540e\u6709\u4e09\u4e2a\u6570 $l~r~k$\uff0c\u8868\u793a\u67e5\u8be2\u533a\u95f4 $[l,r]$ \u5185\u6392\u540d\u4e3a    $k$ \u7684\u6570\u3002</p> <p>\u82e5 $opt=3$\uff0c\u5219\u4e3a\u64cd\u4f5c $3$\uff0c\u4e4b\u540e\u6709\u4e24\u4e2a\u6570 $pos~k$\uff0c\u8868\u793a\u5c06 $pos$ \u4f4d\u7f6e\u7684\u6570\u4fee\u6539\u4e3a $k$\u3002</p> <p>\u82e5 $opt=4$\uff0c\u5219\u4e3a\u64cd\u4f5c $4$\uff0c\u4e4b\u540e\u6709\u4e09\u4e2a\u6570 $l~r~k$\uff0c\u8868\u793a\u67e5\u8be2\u533a\u95f4 $[l,r]$ \u5185 $k$ \u7684\u524d\u9a71\u3002</p> <p>\u82e5 $opt=5$\uff0c\u5219\u4e3a\u64cd\u4f5c $5$\uff0c\u4e4b\u540e\u6709\u4e09\u4e2a\u6570 $l~r~k$\uff0c\u8868\u793a\u67e5\u8be2\u533a\u95f4 $[l,r]$ \u5185 $k$ \u7684\u540e\u7ee7\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_68","title":"\u8f93\u51fa\u683c\u5f0f","text":"<p>\u5bf9\u4e8e\u64cd\u4f5c $1,2,4,5$\uff0c\u5404\u8f93\u51fa\u4e00\u884c\uff0c\u8868\u793a\u67e5\u8be2\u7ed3\u679c\u3002</p> <p>\u6b64\u6570\u636e\u4e3a\u6d1b\u8c37\u539f\u521b\u3002\uff08\u7279\u522b\u63d0\u9192\uff1a\u6b64\u6570\u636e\u4e0d\u4fdd\u8bc1\u64cd\u4f5c 4\u30015 \u4e00\u5b9a\u5b58\u5728\uff0c\u6545\u8bf7\u52a1\u5fc5\u8003\u8651\u4e0d\u5b58\u5728\u7684\u60c5\u51b5\u3002\uff09 1. \u5728\u5bf9\u5e94\u7ebf\u6bb5\u6811\u7684\u8303\u56f4\u5185\u627e\u6709\u591a\u5c11\u4e2a\u5c0f\u4e8ek\u7684\u6570</p> <ol> <li> <p>\u5728\u533a\u95f4\u5185\u4e8c\u5206\u67e5\u627e\uff0c\u5bf9\u7ed3\u679c1\u8fdb\u884c\u67e5\u627e</p> </li> <li> <p>\u628a\u7ebf\u6bb5\u6811\u5bf9\u5e94\u7684\u5e73\u8861\u6811\uff0c\u5220\u9664\u4e00\u4e2a\u6570\uff0c\u589e\u52a0\u4e00\u4e2a\u6570</p> </li> <li> <p>\u5bf9\u4e8e\u6240\u6709\u6bd4k\u5c0f\u7684\u6570\u53d6max</p> </li> <li> <p>\u5bf9\u4e8e\u6240\u6709\u6bd4k\u5927\u7684\u6570\u53d6min  </p> </li> </ol> <pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long \n#define int ll\n#define zuo p&lt;&lt;1\n#define you p&lt;&lt;1|1\n#define INF 2147483647\nconst int MaxN=2e6+100;\nint N,M,tot,t1,t2,t3;\nint a[MaxN];\nstruct point\n{\n    int v;\n}xds[MaxN];\nstruct node\n{\n    int l,r,p,s,v,c;\n}tree[MaxN];\ninline int newnode(int v)\n{\n    int x=++tot;\n    tree[x].l=tree[x].r=0;\n    tree[x].v=v;\n    tree[x].s=tree[x].c=1;\n    tree[x].p=rand();\n    return x;\n}\ninline void updata(int x)\n{\n    tree[x].s=tree[tree[x].l].s+tree[tree[x].r].s+tree[x].c;\n}\nvoid split(int x,int k,int &amp;l,int &amp;r)\n{\n    if(!x)\n    {\n        l=r=0;\n        return;\n    }\n    if(tree[x].v&lt;=k)\n    {\n        l=x;\n        split(tree[x].r,k,tree[x].r,r);\n    }\n    else\n    {\n        r=x;\n        split(tree[x].l,k,l,tree[x].l);\n    }\n    updata(x);\n}\nint hebin(int x,int y)\n{\n    if(!x||!y) return x+y;\n    if(tree[x].p&lt;tree[y].p)\n    {\n        tree[x].r=hebin(tree[x].r,y);\n        updata(x);\n        return x;\n    }\n    else\n    {\n        tree[y].l=hebin(x,tree[y].l);\n        updata(y);\n        return y;\n    }\n}\nint rebuild(int l,int r)\n{\n    int rt=0;\n    for(int i=l;i&lt;=r;i++)\n    {\n        split(rt,a[i],t1,t3);\n        split(t1,a[i]-1,t1,t2);\n        if(t2)\n        {\n            tree[t2].c++;tree[t2].s++;\n            rt=hebin(hebin(t1,t2),t3);\n        }\n        else\n        rt=hebin(hebin(t1,newnode(a[i])),t3);\n    }\n    return rt;\n}\nvoid build(int p,int l,int r)\n{\n    xds[p].v=rebuild(l,r);\n    if(l==r)\n    {\n        return;\n    }\n    int mid=(l+r)&gt;&gt;1;\n    build(zuo,l,mid);\n    build(you,mid+1,r);\n}\nint ith(int x,int v)\n{\n    int ans=0;\n    while(x)\n    {\n        if(tree[x].v==v)\n        {\n            ans+=tree[tree[x].l].s;\n//          qput(ans);putchar('\\n');\n            return ans;\n        }\n        if(tree[x].v&lt;v)\n        {\n            ans+=tree[tree[x].l].s+tree[x].c;\n            x=tree[x].r;\n        }\n        else if(tree[x].v&gt;v)\n        {\n            x=tree[x].l;\n        }\n    }\n//  qput(ans);putchar('\\n');\n    return ans;\n}\nint query(int p,int l,int r,int x,int y,int k)\n{\n    if(r&lt;=y&amp;&amp;l&gt;=x)\n    {\n        return ith(xds[p].v,k);\n    }\n    int mid=(l+r)&gt;&gt;1;\n    int ans=0;\n    if(mid&gt;=x) ans+=query(zuo,l,mid,x,y,k);\n    if(mid&lt;y) ans+=query(you,mid+1,r,x,y,k);\n    return ans;\n}\nint pre(int x,int v)\n{\n    int ans=-INF;\n    while(x)\n    {\n        if(tree[x].v&lt;v)\n        {\n            ans=max(ans,tree[x].v);\n            x=tree[x].r;\n        }\n        if(tree[x].v&gt;=v)\n        {\n            x=tree[x].l;\n        }\n    }\n    return ans;\n}\nint query1(int p,int l,int r,int x,int y,int k)\n{\n    if(r&lt;=y&amp;&amp;l&gt;=x)\n    {\n        return pre(xds[p].v,k);\n    }\n    int mid=(l+r)&gt;&gt;1;\n    int ans=-INF;\n    if(mid&gt;=x) ans=max(ans,query1(zuo,l,mid,x,y,k));\n    if(mid&lt;y) ans=max(ans,query1(you,mid+1,r,x,y,k));\n    return ans;\n}\nint ne(int x,int v)\n{\n    int ans=INF;\n    while(x)\n    {\n        if(tree[x].v&gt;v)\n        {\n            ans=min(ans,tree[x].v);\n            x=tree[x].l;\n        }\n        if(tree[x].v&lt;=v)\n        {\n            x=tree[x].r;\n        }\n    }\n    return ans;\n}\nint query2(int p,int l,int r,int x,int y,int k)\n{\n    if(r&lt;=y&amp;&amp;l&gt;=x)\n    {\n        return ne(xds[p].v,k);\n    }\n    int mid=(l+r)&gt;&gt;1;\n    int ans=INF;\n    if(mid&gt;=x) ans=min(ans,query2(zuo,l,mid,x,y,k));\n    if(mid&lt;y) ans=min(ans,query2(you,mid+1,r,x,y,k));\n    return ans;\n}\nvoid delet(int &amp;x,int k)\n{\n    split(x,k,t1,t3);\n    split(t1,k-1,t1,t2);\n    if(tree[t2].s&gt;1)\n    {\n        tree[t2].s--;tree[t2].c--;\n        x=hebin(hebin(t1,t2),t3);\n    }\n    else\n    {\n        x=hebin(t1,t3);\n    }\n}\nvoid add1(int &amp;x,int k)\n{\n    split(x,k,t1,t3);\n    split(t1,k-1,t1,t2);\n    if(t2)\n    {\n        tree[t2].s++;tree[t2].c++;\n        x=hebin(hebin(t1,t2),t3);\n    }\n    else\n    {\n        x=hebin(hebin(t1,newnode(k)),t3);\n    }\n}\nvoid change(int p,int l,int r,int pos,int k)\n{\n    if(r&gt;=pos&amp;&amp;l&lt;=pos)\n    {\n//      xds[p].v=rebuild(l,r);\n        delet(xds[p].v,a[pos]);\n        add1(xds[p].v,k);\n    }\n    if(l==r) return;\n    int mid=(l+r)&gt;&gt;1;\n    if(mid&gt;=pos) change(zuo,l,mid,pos,k);\n    if(mid&lt;pos) change(you,mid+1,r,pos,k);\n}\ninline int js(int x,int y,int k)\n{\n    int l=0,r=1e8;\n    while(l&lt;=r)\n    {\n        int mid=(l+r)&gt;&gt;1;\n        if(query(1,1,N,x,y,mid)+1&gt;k) r=mid-1;\n        else l=mid+1;\n    }\n    return r;\n}\nsigned main()\n{\n    qread(N);qread(M);\n    for(int i=1;i&lt;=N;i++) qread(a[i]);\n    build(1,1,N);\n    for(int i=1;i&lt;=M;i++)\n    {\n        int opt;qread(opt);\n        int l,r,k,pos;\n        if(opt==1)\n        {\n            qread(l);qread(r);qread(k);\n            int ans=query(1,1,N,l,r,k);\n            qput(ans+1);putchar('\\n');\n        }\n        if(opt==2)\n        {\n            qread(l);qread(r);qread(k);\n            int ans=js(l,r,k);\n            qput(ans);putchar('\\n');\n        }\n        if(opt==3)\n        {\n            qread(pos);qread(k);\n//          a[pos]=k;\n            change(1,1,N,pos,k);\n            a[pos]=k;\n        }\n        if(opt==4)\n        {\n            qread(l);qread(r);qread(k);\n            int ans=query1(1,1,N,l,r,k);\n            qput(ans);putchar('\\n');\n        }\n        if(opt==5)\n        {\n            qread(l);qread(r);qread(k);\n            int ans=query2(1,1,N,l,r,k);\n            qput(ans);putchar('\\n');\n        }\n        // for(int i=1;i&lt;=N;i++)\n        // qput(a[i]),putchar(' ');putchar('\\n');\n    }\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#2_1","title":"2.\u6811\u72b6\u6570\u7ec4\u5957\u4e3b\u5e2d\u6811","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_69","title":"\u9898\u76ee\u63cf\u8ff0","text":"<ul> <li><code>Q l r k</code> \u8868\u793a\u67e5\u8be2\u4e0b\u6807\u5728\u533a\u95f4 $[l,r]$ \u4e2d\u7684\u7b2c $k$ \u5c0f\u7684\u6570  </li> <li><code>C x y</code> \u8868\u793a\u5c06 $a_x$ \u6539\u4e3a $y$</li> </ul> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define ls p &lt;&lt; 1\n#define rs p &lt;&lt; 1 | 1\n#define lowbit(x) ((x) &amp; (-x))\nconst int MaxN = 1e5 + 100;\nconst int MAXN = 1e5 + 100;\nconst int MaxM = 3e7 + 3e6;\nconst int INF = 1e9;\nint T, N, M, K, tot, n;\nint a[MaxN], b[MaxN &lt;&lt; 1], top;\nint tree1[MaxN], rt[MaxN];\nint temp1[MaxN], temp2[MaxN];\nint t1[MaxN], t2[MaxN], t3[MaxN];\nchar pd[MaxN];\nint cnt1, cnt2;\nstruct point\n{\n    int l, r, sum;\n}tree[MaxM];\nint ef(int x)\n{\n    int l = 1, r = n;\n    while(l &lt;= r)\n    {\n        int mid = (l + r) &gt;&gt; 1;\n        if (b[mid] &gt;= x) r = mid - 1;\n        else l = mid + 1;\n    }\n    return l;\n}\nint add1(int p, int l, int r, int v, int k)\n{\n    int x = ++tot;\n    tree[x] = tree[p];\n    tree[x].sum += v;\n    if (l == r)\n    {\n        return x;\n    }\n    int mid = (l + r)&gt;&gt;1;\n    if (mid &gt;= k) tree[x].l = add1(tree[x].l, l, mid, v, k);\n    else tree[x].r = add1(tree[x].r, mid + 1, r, v, k);\n    return x;\n}\ninline void add(int x, int v)\n{\n    int t = ef(a[x]);\n    for (; x &lt;= N; x += lowbit(x))\n    {\n        rt[x] = add1(rt[x], 1, n, v, t);\n    }\n}\nint query1(int l, int r, int k)\n{\n    if (l == r) return l;\n    int sum = 0;\n    int mid = (l + r) &gt;&gt; 1;\n    for (int i = 1; i &lt;= cnt1; i++)\n    {\n        sum -= tree[tree[temp1[i]].l].sum;\n    }\n    for (int i = 1; i &lt;= cnt2; i++)\n    {\n        sum += tree[tree[temp2[i]].l].sum;\n    }\n    if (sum &gt;= k)\n    {\n        for (int i = 1; i &lt;= cnt1; i++)\n        {\n            temp1[i] = tree[temp1[i]].l;\n        }\n        for (int i = 1; i &lt;= cnt2; i++)\n        {\n            temp2[i] = tree[temp2[i]].l;\n        }\n        return query1(l, mid, k);\n    }\n    else\n    {\n        for (int i = 1; i &lt;= cnt1; i++)\n        {\n            temp1[i] = tree[temp1[i]].r;\n        }\n        for (int i = 1; i &lt;= cnt2; i++)\n        {\n            temp2[i] = tree[temp2[i]].r;\n        }\n        return query1(mid + 1, r, k - sum);\n    }\n}\ninline int query(int l, int r, int k)\n{\n    cnt1 = 0;\n    cnt2 = 0;\n    for (int i = l - 1; i; i -= lowbit(i))\n    {\n        temp1[++cnt1] = rt[i];\n    }\n    for (int i = r; i; i -= lowbit(i))\n    {\n        temp2[++cnt2] = rt[i];\n    }\n    return query1(1, n, k);\n}\ninline void Solve()\n{\n    cin &gt;&gt; N &gt;&gt; M;\n    for (int i = 1; i &lt;= N; i++)\n    {\n        cin &gt;&gt; a[i];\n        b[++top] = a[i];\n    }\n    for (int i = 1; i &lt;= M; i++)\n    {\n        char opt;\n        int x, y, z;\n        cin &gt;&gt; opt;\n        pd[i] = opt;\n        if (opt == 'C')\n        {\n            cin &gt;&gt; x &gt;&gt; y;\n            t1[i] = x;\n            t2[i] = y;\n            b[++top] = y;\n        }\n        else\n        {\n            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n            t1[i] = x;\n            t2[i] = y;\n            t3[i] = z;\n        }\n    }\n    sort(b + 1, b + 1 + top);\n    n = unique(b + 1, b + 1 + top) - (b + 1);\n    for (int i = 1; i &lt;= N; i++)\n    {\n        add(i, 1);\n    }\n    for (int i = 1; i &lt;= M; i++)\n    {\n        char opt;\n        int x, y, z;\n        opt = pd[i];\n        if (opt == 'C')\n        {\n            x = t1[i];\n            y = t2[i];\n            add(x, -1);\n            a[x] = y;\n            add(x, 1);\n        }\n        else\n        {\n            x = t1[i];\n            y = t2[i];\n            z = t3[i];\n            int ans = query(x, y, z);\n            cout &lt;&lt; b[ans] &lt;&lt; endl;\n        }\n    }\n}\nsigned main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    Solve();\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_70","title":"\u6743\u503c\u7ebf\u6bb5\u6811\u5957\u6743\u503c\u7ebf\u6bb5\u6811(\u4e8c\u7ef4\u5355\u70b9\u4fee\u6539\uff0c\u77e9\u5f62\u67e5\u8be2)","text":"<pre><code>int n1, n2;\nstruct Segment {\n    struct Point {\n        int l, r;\n        ll sum;\n    } tree[MaxM];\n    int tot;\n    Segment() {\n        init();\n    }\n    Segment(int _n) {\n        init(_n);\n    }\n    void init() {\n        // tree.clear();\n        // tree.push_back({});\n        tot = 0;\n    }\n    void init(int _n) {\n        // tree.clear();\n        tot = 0;\n        // tree.assign(_n, {});\n    }\n\n    inline Point pushup(Point L, Point R) {\n        Point now = Point();\n        now.sum = L.sum + R.sum;\n        return now;\n    }\n\n    inline void pushup(int p) {\n        tree[p].sum = tree[tree[p].l].sum + tree[tree[p].r].sum;\n    }\n\n    int change(int p, int l, ll r, int k, int v) {\n        // while (tree.size() &lt;= tot + 1) tree.push_back({});\n        if (!p) {\n            p = ++tot;\n        }\n        if (l == r) {\n            tree[p].sum += v;\n            return p;\n        }\n        int mid = (l + r) &gt;&gt; 1;\n        if (mid &gt;= k) tree[p].l = change(tree[p].l, l, mid, k, v);\n        else tree[p].r = change(tree[p].r, mid + 1, r, k, v);\n        pushup(p);\n        return p;\n    }\n\n    ll query(int p, int l, ll r, int x, int y) {\n        if (p &gt; tot) return 0;\n        if (l &gt;= x &amp;&amp; r &lt;= y) {\n            return tree[p].sum;\n        }\n        int mid = (l + r) &gt;&gt; 1;\n        ll ans = 0;\n        if (mid &gt;= x) ans += query(tree[p].l, l, mid, x, y);\n        if (mid &lt; y) ans += query(tree[p].r, mid + 1, r, x, y);\n        return ans;\n    }\n};\nstruct Segment2 {\n    Segment segment;\n    struct Point {\n        int l, r, rt;\n    } tree[MaxN * 10];\n    int tot;\n    Segment2() {\n        init();\n    }\n    Segment2(int _n) {\n        init(_n);\n    }\n    void init() {\n        // tree.clear();\n        // tree.push_back({});\n        tot = 0;\n        segment.init(MaxN * 400);\n    }\n    void init(int _n) {\n        // tree.clear();\n        tot = 0;\n        // tree.assign(_n, {});\n    }\n\n\n    int change(int p, int l, ll r, int k, int k2, int v) {\n        // while (tree.size() &lt;= tot + 10) tree.push_back({});\n        if (!p) {\n            p = ++tot;\n        }\n        tree[p].rt = segment.change(tree[p].rt, 1, n2, k2, v);\n        if (l == r) {\n            return p;\n        }\n        int mid = (l + r) &gt;&gt; 1;\n        if (mid &gt;= k) tree[p].l = change(tree[p].l, l, mid, k, k2, v);\n        else tree[p].r = change(tree[p].r, mid + 1, r, k, k2, v);\n        return p;\n    }\n\n    ll query(int p, int l, ll r, int x, int y, int x2, int y2) {\n        if (p &gt; tot) return 0;\n        if (l &gt;= x &amp;&amp; r &lt;= y) {\n            return segment.query(tree[p].rt, 1, n2, x2, y2);\n        }\n        int mid = (l + r) &gt;&gt; 1;\n        ll ans = 0;\n        if (mid &gt;= x) ans += query(tree[p].l, l, mid, x, y, x2, y2);\n        if (mid &lt; y) ans += query(tree[p].r, mid + 1, r, x, y, x2, y2);\n        return ans;\n    }\n};\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#link-cut-tree","title":"\u3010\u6a21\u677f\u3011\u52a8\u6001\u6811\uff08Link Cut Tree\uff09","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_71","title":"\u9898\u76ee\u63cf\u8ff0","text":"<p>\u7ed9\u5b9a $n$ \u4e2a\u70b9\u4ee5\u53ca\u6bcf\u4e2a\u70b9\u7684\u6743\u503c\uff0c\u8981\u4f60\u5904\u7406\u63a5\u4e0b\u6765\u7684 $m$ \u4e2a\u64cd\u4f5c\u3002 \u64cd\u4f5c\u6709\u56db\u79cd\uff0c\u64cd\u4f5c\u4ece $0$ \u5230 $3$ \u7f16\u53f7\u3002\u70b9\u4ece $1$ \u5230 $n$ \u7f16\u53f7\u3002</p> <ul> <li><code>0 x y</code> \u4ee3\u8868\u8be2\u95ee\u4ece $x$ \u5230 $y$ \u7684\u8def\u5f84\u4e0a\u7684\u70b9\u7684\u6743\u503c\u7684 $\\text{xor}$ \u548c\u3002\u4fdd\u8bc1 $x$ \u5230 $y$ \u662f\u8054\u901a\u7684\u3002</li> <li><code>1 x y</code> \u4ee3\u8868\u8fde\u63a5 $x$ \u5230 $y$\uff0c\u82e5 $x$ \u5230 $y$ \u5df2\u7ecf\u8054\u901a\u5219\u65e0\u9700\u8fde\u63a5\u3002</li> <li><code>2 x y</code> \u4ee3\u8868\u5220\u9664\u8fb9 $(x,y)$\uff0c\u4e0d\u4fdd\u8bc1\u8fb9 $(x,y)$ \u5b58\u5728\u3002</li> <li><code>3 x y</code> \u4ee3\u8868\u5c06\u70b9 $x$ \u4e0a\u7684\u6743\u503c\u53d8\u6210 $y$\u3002</li> </ul>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_72","title":"\u8f93\u5165\u683c\u5f0f","text":"<p>\u7b2c\u4e00\u884c\u4e24\u4e2a\u6574\u6570\uff0c\u5206\u522b\u4e3a $n$ \u548c $m$\uff0c\u4ee3\u8868\u70b9\u6570\u548c\u64cd\u4f5c\u6570\u3002</p> <p>\u63a5\u4e0b\u6765 $n$ \u884c\uff0c\u6bcf\u884c\u4e00\u4e2a\u6574\u6570\uff0c\u7b2c $(i + 1)$ \u884c\u7684\u6574\u6570 $a_i$ \u8868\u793a\u8282\u70b9 $i$ \u7684\u6743\u503c\u3002</p> <p>\u63a5\u4e0b\u6765 $m$ \u884c\uff0c\u6bcf\u884c\u4e09\u4e2a\u6574\u6570\uff0c\u5206\u522b\u4ee3\u8868\u64cd\u4f5c\u7c7b\u578b\u548c\u64cd\u4f5c\u6240\u9700\u7684\u91cf\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_73","title":"\u8f93\u51fa\u683c\u5f0f","text":"<p>\u5bf9\u4e8e\u6bcf\u4e00\u4e2a $0$ \u53f7\u64cd\u4f5c\uff0c\u4f60\u987b\u8f93\u51fa\u4e00\u884c\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a $x$ \u5230 $y$ \u7684\u8def\u5f84\u4e0a\u70b9\u6743\u7684 $\\text{xor}$ \u548c\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_14","title":"\u6837\u4f8b #1","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_15","title":"\u6837\u4f8b\u8f93\u5165 #1","text":"<pre><code>3 3 \n1\n2\n3\n1 1 2\n0 1 2 \n0 1 1\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_16","title":"\u6837\u4f8b\u8f93\u51fa #1","text":"<pre><code>3\n1\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#2_2","title":"\u6837\u4f8b #2","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#2_3","title":"\u6837\u4f8b\u8f93\u5165 #2","text":"<pre><code>5 14\n114\n514\n19\n19\n810\n1 1 2\n0 1 2\n2 1 2\n1 1 2\n1 2 3\n2 1 3\n1 1 3\n1 4 5\n1 2 5\n0 3 5\n0 3 4\n3 5 233333\n0 1 5\n0 2 5\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#2_4","title":"\u6837\u4f8b\u8f93\u51fa #2","text":"<pre><code>624\n315\n296\n232709\n232823\n</code></pre> <p>\u52a8\u6001\u6811lct\u6a21\u677f  </p> <pre><code>struct LCT {\n    struct Point {\n        int s, fa, ch[2], v, lan, sum;\n    } tree[MaxN];\n    inline void pushup(int x) {\n        tree[x].s = tree[tree[x].ch[0]].s + tree[tree[x].ch[1]].s + 1;\n        tree[x].sum = tree[tree[x].ch[0]].sum ^ tree[tree[x].ch[1]].sum ^ tree[x].v;\n    }\n    inline bool isroot(int x) {\n        return tree[tree[x].fa].ch[0] != x &amp;&amp; tree[tree[x].fa].ch[1] != x;\n    }\n    inline void overturn(int x) {\n        swap(tree[x].ch[0], tree[x].ch[1]);\n        tree[x].lan ^= 1;\n    }\n    inline void pushdown(int x) {\n        if (tree[x].lan) {\n            overturn(tree[x].ch[0]);\n            overturn(tree[x].ch[1]);\n            tree[x].lan = 0;\n        }\n    }\n    inline void updata(int x) {\n        if (!isroot(x)) updata(tree[x].fa);\n        pushdown(x);\n    }\n    inline bool get(int x) {\n        return x == tree[tree[x].fa].ch[1];\n    }\n    inline void rotate(int x) {\n        int y = tree[x].fa, z = tree[y].fa, k = get(x);\n        if (!isroot(y)) tree[z].ch[tree[z].ch[1] == y] = x;\n        tree[y].ch[k] = tree[x].ch[k ^ 1];\n        tree[tree[x].ch[k ^ 1]].fa = y;\n        tree[x].ch[k ^ 1] = y;\n        tree[y].fa = x;\n        tree[x].fa = z;\n        pushup(y); pushup(x);\n    }\n    inline void splay(int x) {\n        updata(x);\n        for (int f; f = tree[x].fa, !isroot(x); rotate(x)) {\n            if (!isroot(f)) rotate(get(f) == get(x)? f : x);\n        }\n    }\n    inline int access(int x) {\n        int p;\n        for (p = 0; x; p = x, x = tree[x].fa) {\n            splay(x); tree[x].ch[1] = p; pushup(x);\n        }\n        return p;\n    }\n    inline void makeroot(int p) {\n        access(p); splay(p);\n        overturn(p);\n    }\n    inline int find(int x) {\n        access(x);\n        splay(x);\n        while (tree[x].ch[0]) {\n            pushdown(x);\n            x = tree[x].ch[0];\n        }\n        splay(x);\n        return x;\n    }\n    inline bool link(int x, int y) {\n        makeroot(x);\n        if (find(y) == x) return 0;\n        tree[x].fa = y; \n        return 1;\n    }\n    inline void split(int x, int y) {\n        makeroot(x);\n        access(y);\n        splay(y);\n    }\n    inline void cut(int x, int y) {\n        makeroot(x);\n        if (find(y) == x &amp;&amp; tree[y].fa == x &amp;&amp; tree[y].ch[0] == 0) {\n            tree[y].fa = tree[x].ch[1] = 0;\n            pushup(x);\n        }\n    }\n    inline int findf(int x) {\n        while (tree[x].ch[1]) {\n            pushdown(x);\n            x = tree[x].ch[1];\n        }\n        return x;\n    }\n    inline void cutTree(int x, int y) { // \u4ee5x\u4e3a\u6839\uff0c\u5206\u79bby\u548cfa[y]\n        split(x, y);\n        x = findf(tree[y].ch[0]);\n        cut(x, y);\n    }\n    inline int lca(int x, int y) {\n        access(x);\n        return access(y);\n    }\n    inline bool lt(int x, int y) { // \u662f\u5426\u8054\u901a\n        makeroot(x);\n        if (find(y) == x) return 1;\n        return 0;\n    }\n} TT;\n\ninline void Solve() {\n    cin &gt;&gt; N &gt;&gt; M;\n    for (int i = 1; i &lt;= N; i++) {\n        cin &gt;&gt; TT.tree[i].v;\n    }\n    for (int i = 1; i &lt;= M; i++) {\n        int opt, x, y;\n        cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;\n        if (opt == 0) {\n            TT.split(x, y);\n            int ans = TT.tree[y].sum;\n            cout &lt;&lt; ans &lt;&lt; endl;\n        }\n        else if (opt == 1) {\n            TT.link(x, y);\n        }\n        else if (opt == 2) {\n            TT.cut(x, y);\n        }\n        else {\n            TT.splay(x); TT.tree[x].v = y;\n            TT.pushup(x);\n        }\n    }\n}\n\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_74","title":"\u7ef4\u62a4\u5b50\u6811\u5927\u5c0f","text":"<pre><code>    makeroot(1);\n    access(now);\n    splay(now);\n    // ans = \u81ea\u5df1\u865a\u6811\u503c + \u81ea\u5df1\u7684\u503c + \u53f3\u5b50\u6811\u7684\u503c\n    return TT.tree[now].t + TT.tree[now].v + TT.tree[TT.tree[now].ch[1]].sum;\n    inline void pushup(int x) {\n        tree[x].s = tree[tree[x].ch[0]].s + tree[tree[x].ch[1]].s + 1 + tree[x].sum;\n        // tree[x].sum = tree[tree[x].ch[0]].sum ^ tree[tree[x].ch[1]].sum ^ tree[x].v;\n    }\n    inline int access(int x) {\n        int p;\n        for (p = 0; x; p = x, x = tree[x].fa) {\n            splay(x);\n            tree[x].sum += tree[tree[x].ch[1]].s;\n            tree[x].sum -= tree[p].s;\n            tree[x].ch[1] = p;\n            pushup(x);\n        }\n        return p;\n    }\n    inline bool link(int x, int y) {\n        makeroot(x);\n        if (find(y) == x) return 0;\n        access(y);\n        splay(y);\n        tree[x].fa = y;\n        tree[y].sum += tree[x].s; \n        return 1;\n    }\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#makeroot","title":"\u65e0makeroot","text":"<pre><code>    inline void link(int x, int y) {\n        access(y);\n        splay(y);\n        tree[x].fa = y;\n        tree[y].t += tree[x].sum; \n        pushup(y);\n    }\n    inline void cut(int x) {\n        access(x);\n        splay(x);\n        tree[tree[x].ch[0]].fa = 0;\n        tree[x].ch[0] = 0;\n        pushup(x);\n    }\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_75","title":"\u4e58\u6cd5\u52a0\u6cd5\u6df7\u5408","text":"<pre><code>struct LCT {\n    struct Point {\n        int s, fa, ch[2], lan;\n        Z v, sum;\n        Z add, mul = 1;\n    } tree[MaxN];\n    inline void pushup(int x) {\n        tree[x].s = tree[tree[x].ch[0]].s + tree[tree[x].ch[1]].s + 1;\n        tree[x].sum = tree[tree[x].ch[0]].sum + tree[tree[x].ch[1]].sum + tree[x].v;\n    }\n    inline bool isroot(int x) {\n        return tree[tree[x].fa].ch[0] != x &amp;&amp; tree[tree[x].fa].ch[1] != x;\n    }\n    inline void overturn(int x) {\n        swap(tree[x].ch[0], tree[x].ch[1]);\n        tree[x].lan ^= 1;\n    }\n    void changeadd(int x, Z v) {\n        tree[x].v += v;\n        tree[x].sum += v * tree[x].s;\n        tree[x].add += v;\n    }\n    void changemul(int x, Z v) {\n        tree[x].mul *= v;\n        tree[x].v *= v;\n        tree[x].add *= v;\n        tree[x].sum *= v;\n    }\n    inline void pushdown(int x) {\n        if (tree[x].lan) {\n            overturn(tree[x].ch[0]);\n            overturn(tree[x].ch[1]);\n            tree[x].lan = 0;\n        }\n\n        if (tree[x].ch[0]) changemul(tree[x].ch[0], tree[x].mul);\n        if (tree[x].ch[1]) changemul(tree[x].ch[1], tree[x].mul);\n\n        tree[x].mul = 1;\n\n        if (tree[x].ch[0]) changeadd(tree[x].ch[0], tree[x].add);\n        if (tree[x].ch[1]) changeadd(tree[x].ch[1], tree[x].add);\n        tree[x].add = 0;\n\n    }\n    inline void updata(int x) {\n        if (!isroot(x)) updata(tree[x].fa);\n        pushdown(x);\n    }\n    inline bool get(int x) {\n        return x == tree[tree[x].fa].ch[1];\n    }\n    inline void rotate(int x) {\n        int y = tree[x].fa, z = tree[y].fa, k = get(x);\n        if (!isroot(y)) tree[z].ch[tree[z].ch[1] == y] = x;\n        tree[y].ch[k] = tree[x].ch[k ^ 1];\n        tree[tree[x].ch[k ^ 1]].fa = y;\n        tree[x].ch[k ^ 1] = y;\n        tree[y].fa = x;\n        tree[x].fa = z;\n        pushup(y); pushup(x);\n    }\n    inline void splay(int x) {\n        updata(x);\n        for (int f; f = tree[x].fa, !isroot(x); rotate(x)) {\n            if (!isroot(f)) rotate(get(f) == get(x)? f : x);\n        }\n    }\n    inline int access(int x) {\n        int p;\n        for (p = 0; x; p = x, x = tree[x].fa) {\n            splay(x); tree[x].ch[1] = p; pushup(x);\n        }\n        return p;\n    }\n    inline void makeroot(int p) {\n        access(p); splay(p);\n        overturn(p);\n    }\n    inline int find(int x) {\n        access(x);\n        splay(x);\n        while (tree[x].ch[0]) {\n            pushdown(x);\n            x = tree[x].ch[0];\n        }\n        splay(x);\n        return x;\n    }\n    inline bool link(int x, int y) {\n        makeroot(x);\n        if (find(y) == x) return 0;\n        tree[x].fa = y; \n        return 1;\n    }\n    inline void split(int x, int y) {\n        makeroot(x);\n        access(y);\n        splay(y);\n    }\n    inline void cut(int x, int y) {\n        makeroot(x);\n        if (find(y) == x &amp;&amp; tree[y].fa == x &amp;&amp; tree[y].ch[0] == 0) {\n            tree[y].fa = tree[x].ch[1] = 0;\n            pushup(x);\n        }\n    }\n    inline int findf(int x) {\n        while (tree[x].ch[1]) {\n            pushdown(x);\n            x = tree[x].ch[1];\n        }\n        return x;\n    }\n    inline void cutTree(int x, int y) { // \u4ee5x\u4e3a\u6839\uff0c\u5206\u79bby\u548cfa[y]\n        split(x, y);\n        x = findf(tree[y].ch[0]);\n        cut(x, y);\n    }\n    inline int lca(int x, int y) {\n        access(x);\n        return access(y);\n    }\n} TT;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#k-d-tree","title":"K-D Tree","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_76","title":"\u7b80\u5355\u9898","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_77","title":"\u9898\u76ee\u63cf\u8ff0","text":"<p>\u4f60\u6709\u4e00\u4e2a$N \\times N$\u7684\u68cb\u76d8\uff0c\u6bcf\u4e2a\u683c\u5b50\u5185\u6709\u4e00\u4e2a\u6574\u6570\uff0c\u521d\u59cb\u65f6\u7684\u65f6\u5019\u5168\u90e8\u4e3a $0$\uff0c\u73b0\u5728\u9700\u8981\u7ef4\u62a4\u4e24\u79cd\u64cd\u4f5c\uff1a</p> <ul> <li><code>1 x y A</code>    $1\\le x,y\\le N$\uff0c$A$ \u662f\u6b63\u6574\u6570\u3002\u5c06\u683c\u5b50<code>x</code>,<code>y</code>\u91cc\u7684\u6570\u5b57\u52a0\u4e0a $A$\u3002</li> <li><code>2 x1 y1 x2 y2</code>    $1 \\le x_1 \\le x_2 \\le N$\uff0c$1 \\le y_1\\le y_2 \\le N$\u3002\u8f93\u51fa $x_1, y_1, x_2, y_2$ \u8fd9\u4e2a\u77e9\u5f62\u5185\u7684\u6570\u5b57\u548c</li> <li><code>3</code>    \u65e0 \u7ec8\u6b62\u7a0b\u5e8f</li> </ul>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_78","title":"\u8f93\u5165\u683c\u5f0f","text":"<p>\u8f93\u5165\u6587\u4ef6\u7b2c\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570 $N$\u3002</p> <p>\u63a5\u4e0b\u6765\u6bcf\u884c\u4e00\u4e2a\u64cd\u4f5c\u3002\u6bcf\u6761\u547d\u4ee4\u9664\u7b2c\u4e00\u4e2a\u6570\u5b57\u4e4b\u5916\uff0c\u5747\u8981\u5f02\u6216\u4e0a\u4e00\u6b21\u8f93\u51fa\u7684\u7b54\u6848 <code>last_ans</code>\uff0c\u521d\u59cb\u65f6 <code>last_ans</code> $=0$\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_79","title":"\u8f93\u51fa\u683c\u5f0f","text":"<p>\u5bf9\u4e8e\u6bcf\u4e2a $2$ \u64cd\u4f5c\uff0c\u8f93\u51fa\u4e00\u4e2a\u5bf9\u5e94\u7684\u7b54\u6848\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_17","title":"\u6837\u4f8b #1","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_18","title":"\u6837\u4f8b\u8f93\u5165 #1","text":"<pre><code>4\n1 2 3 3\n2 1 1 3 3\n1 1 1 1\n2 1 1 0 7\n3\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_19","title":"\u6837\u4f8b\u8f93\u51fa #1","text":"<pre><code>3\n5\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_80","title":"\u63d0\u793a","text":"<p>$1\\leq N\\leq 5\\times 10^5$\uff0c\u64cd\u4f5c\u6570\u4e0d\u8d85\u8fc7 $2\\times 10^5$ \u4e2a\uff0c\u5185\u5b58\u9650\u5236 $20\\texttt{MB}$\uff0c\u4fdd\u8bc1\u7b54\u6848\u5728 int \u8303\u56f4\u5185\u5e76\u4e14\u89e3\u7801\u4e4b\u540e\u6570\u636e\u4ecd\u5408\u6cd5\u3002</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define ld long double\n#define ls p &lt;&lt; 1\n#define rs p &lt;&lt; 1 | 1\n#define lowbit(x) ((x) &amp; (-x))\nconst int MaxN = 2e5 + 100;\nconst int INF = 1e9;\nint T, N, M, K, lastans, tot, rt;\nint st[MaxN], top;\nld api = 0.7;\nint xl, yl, xr, yr;\nstruct point\n{\n    int x, y, z;\n} a[MaxN];\nstruct edge\n{\n    int L, R, U, D;\n    int l, r, d;\n    int sum, s;\n} tree[MaxN];\nvoid maintain(int x)\n{\n    tree[x].sum = tree[tree[x].l].sum + tree[tree[x].r].sum + a[x].z;\n    tree[x].s = tree[tree[x].l].s + tree[tree[x].r].s + 1;\n    tree[x].L = tree[x].R = a[x].x;\n    tree[x].U = tree[x].D = a[x].y;\n    if (tree[x].l)\n    {\n        tree[x].L = min(tree[x].L, tree[tree[x].l].L);\n        tree[x].R = max(tree[x].R, tree[tree[x].l].R);\n        tree[x].U = max(tree[x].U, tree[tree[x].l].U);\n        tree[x].D = min(tree[x].D, tree[tree[x].l].D);\n    }\n    if (tree[x].r)\n    {\n        tree[x].L = min(tree[x].L, tree[tree[x].r].L);\n        tree[x].R = max(tree[x].R, tree[tree[x].r].R);\n        tree[x].U = max(tree[x].U, tree[tree[x].r].U);\n        tree[x].D = min(tree[x].D, tree[tree[x].r].D);\n    }\n}\ninline bool cmp1(int x, int y)\n{\n    return a[x].x &lt; a[y].x;\n}\ninline bool cmp2(int x, int y)\n{\n    return a[x].y &lt; a[y].y;\n}\nint build(int l, int r)\n{\n    if (l &gt; r) return 0;\n    int mid = (l + r) &gt;&gt; 1;\n    ld ave1 = 0, ave2 = 0, fc1 = 0, fc2 = 0;\n    for (int i = l; i &lt;= r; i++)\n    {\n        ave1 += a[st[i]].x;\n        ave2 += a[st[i]].y;\n    }\n    ave1 /= (r - l + 1);\n    ave2 /= (r - l + 1);\n    for (int i = l; i &lt;= r; i++)\n    {\n        fc1 += (a[st[i]].x - ave1) * (a[st[i]].x - ave1);\n        fc2 += (a[st[i]].y - ave2) * (a[st[i]].y - ave2);\n    }\n    if (fc1 &gt; fc2)\n    {\n        nth_element(st + l, st + mid, st + r + 1, cmp1);\n        tree[st[mid]].d = 1;\n    }\n    else\n    {\n        nth_element(st + l, st + mid, st + r + 1, cmp2);\n        tree[st[mid]].d = 2;\n    }\n    tree[st[mid]].l = build(l, mid - 1);\n    tree[st[mid]].r = build(mid + 1, r);\n    maintain(st[mid]);\n    return st[mid];\n}\ninline bool bad(int x)\n{\n    return api * tree[x].s &lt;= max(tree[tree[x].l].s, tree[tree[x].r].s);\n}\nvoid print(int x)\n{\n    if (tree[x].l)\n        print(tree[x].l);\n    st[++top] = x;\n    if (tree[x].r)\n        print(tree[x].r);\n}\nvoid rebuild(int &amp;x)\n{\n    top = 0;\n    print(x);\n    x = build(1, top);\n}\nvoid insert(int &amp;x, int k)\n{\n    if (!x)\n    {\n        x = k;\n        maintain(x);\n        return;\n    }\n    if (tree[x].d == 1)\n    {\n        if (a[k].x &lt;= a[x].x)\n            insert(tree[x].l, k);\n        else\n            insert(tree[x].r, k);\n    }\n    else\n    {\n        if (a[k].y &lt;= a[x].y)\n            insert(tree[x].l, k);\n        else\n            insert(tree[x].r, k);\n    }\n    maintain(x);\n    if (bad(x)) rebuild(x);\n\n}\nint query(int x)\n{\n    if (!x || tree[x].L &gt; xr || tree[x].R &lt; xl || tree[x].U &lt; yl || tree[x].D &gt; yr) \n        return 0;\n    if (tree[x].L &gt;= xl &amp;&amp; tree[x].R &lt;= xr &amp;&amp; tree[x].U &lt;= yr &amp;&amp; tree[x].D &gt;= yl) \n        return  tree[x].sum;\n    int res = 0;\n    if (a[x].x &gt;= xl &amp;&amp; a[x].x &lt;= xr &amp;&amp; a[x].y &gt;= yl &amp;&amp; a[x].y &lt;= yr)\n    {\n        res += a[x].z;\n    }\n    return query(tree[x].l) + query(tree[x].r) + res;\n}\ninline void Solve()\n{\n    cin &gt;&gt; N;\n    int opt;\n    while (cin &gt;&gt; opt)\n    {\n        if (opt == 3)\n            break;\n        if (opt == 1)\n        {\n            int x, y, z;\n            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n            x ^= lastans;\n            y ^= lastans;\n            z ^= lastans;\n            tot++;\n            a[tot].x = x;\n            a[tot].y = y;\n            a[tot].z = z;\n            insert(rt, tot);\n        }\n        else\n        {\n            cin &gt;&gt; xl &gt;&gt; yl &gt;&gt; xr &gt;&gt; yr;\n            xl ^= lastans;\n            xr ^= lastans;\n            yl ^= lastans;\n            yr ^= lastans;\n            lastans = query(rt);\n            cout &lt;&lt; lastans &lt;&lt; '\\n';\n        }\n    }\n}\nsigned main()\n{\n    Solve();\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_81","title":"\u6570\u8bba","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#sqrt","title":"sqrt\u6c42\u6839\u53f7","text":"<pre><code>int safe_sqrt(int x) {\n    int ans = sqrtf(x);\n    while ((ans + 1) * (ans + 1) &lt;= x) ans++;\n    while (ans * ans &gt; x) ans--;\n    return ans;\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_82","title":"\u8d28\u6570\u7b5b","text":"<pre><code>inline void pre() {\n    for (int i = 2; i &lt;= N; i++) {\n        if (!vis[i]) {\n            vis[i] = i;\n            prime[++tot] = i;\n        }\n        for (int j = 1; j &lt;= tot; j++) {\n            if (prime[j] &gt; N / i || prime[j] &gt; vis[i]) break;\n            vis[prime[j] * i] = prime[j];\n        }\n    }\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#exgcd","title":"exgcd\u6c42\u9006\u5143","text":"<pre><code>void exgcd(int a, int b, int &amp;d, int &amp;x, int &amp;y) {\n    int t;\n    if (b == 0) {\n        d = a; x = 1; y = 0;\n    } else {\n        exgcd(b, a % b, d, x ,y);\n        t = x; x = y; y = t - (a / b) * y;\n    }\n}\nint ny(int a, int P) {\n    int x, y, d;\n    exgcd(a, P, d, x, y);\n    return (x % P + P) % P;\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_83","title":"\u7ec4\u5408\u6570","text":"<pre><code>struct Math {\n    int jc[MaxN], ijc[MaxN], ip[MaxN];\n    int ksm(int x, int y) {\n        int res = 1;\n        while (y) {\n            if (y &amp; 1) res = res * x % P;\n            x = x * x % P;\n            y &gt;&gt;= 1;\n        }\n        return res;\n    }\n    inline void pre(int N) {\n        jc[0] = ijc[0] = 1;\n        for (int i = 1; i &lt;= N; i++) {\n            jc[i] = jc[i - 1] * i % P;\n        }\n        ijc[N] = ksm(jc[N], P - 2);\n        for (int i = N; i &gt;= 1; i--) {\n            ijc[i - 1] = ijc[i] * i % P;\n        }\n    }\n    inline void pre1(int N) {\n        jc[0] = ijc[0] = 1;\n        for (int i = 1; i &lt;= N; i++) {\n            jc[i] = jc[i - 1] * i % P;\n        }\n        ip[1] = 1;\n        for (int i = 2; i &lt;= N; i++) {\n            ip[i] = (P - P / i) * ip[P % i] % P;\n        }\n        for (int i = 1; i &lt;= N; i++) {\n            ijc[i] = ijc[i - 1] * ip[i] % P;\n        }\n    }\n    inline int C(int n, int m) {\n        if (m &gt; n) return 0;\n        return jc[n] * ijc[m] % P * ijc[n - m] % P;\n    }\n    int lucas(int n, int m) {\n        if(m == 0) return 1;\n        return lucas(n / P, m / P) * C(n % P, m % P) % P;\n    }\n    int js(int n, int m) {// n\u4e2a\u76f8\u540c\u7684\u5c0f\u7403\u653e\u5165m\u4e2a\u4e0d\u540c\u7684\u7bb1\u5b50\u4e2d\n        return C(n + m - 1, m - 1);\n    }\n} TT;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#excrt","title":"\u3010\u6a21\u677f\u3011\u6269\u5c55\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\uff08EXCRT\uff09","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_84","title":"\u9898\u76ee\u63cf\u8ff0","text":"<p>\u7ed9\u5b9a  $n$ \u7ec4\u975e\u8d1f\u6574\u6570  $a_i, b_i$ \uff0c\u6c42\u89e3\u5173\u4e8e  $x$ \u7684\u65b9\u7a0b\u7ec4\u7684\u6700\u5c0f\u975e\u8d1f\u6574\u6570\u89e3\u3002 $$\\begin{cases} x \\equiv b_1\\ ({\\rm mod}\\ a_1) \\ x\\equiv b_2\\ ({\\rm mod}\\ a_2) \\ ... \\ x \\equiv b_n\\ ({\\rm mod}\\ a_n)\\end{cases}$$</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_85","title":"\u8f93\u5165\u683c\u5f0f","text":"<p>\u8f93\u5165\u7b2c\u4e00\u884c\u5305\u542b\u6574\u6570 $n$\u3002</p> <p>\u63a5\u4e0b\u6765 $n$ \u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u975e\u8d1f\u6574\u6570 $a_i, b_i$\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_86","title":"\u8f93\u51fa\u683c\u5f0f","text":"<p>\u8f93\u51fa\u4e00\u884c\uff0c\u4e3a\u6ee1\u8db3\u6761\u4ef6\u7684\u6700\u5c0f\u975e\u8d1f\u6574\u6570 $x$\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_20","title":"\u6837\u4f8b #1","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_21","title":"\u6837\u4f8b\u8f93\u5165 #1","text":"<pre><code>3\n11 6\n25 9\n33 17\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_22","title":"\u6837\u4f8b\u8f93\u51fa #1","text":"<pre><code>809\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_87","title":"\u63d0\u793a","text":"<p>\u5bf9\u4e8e $100 \\%$ \u7684\u6570\u636e\uff0c$1 \\le n \\le {10}^5$\uff0c$1 \\le b_i,a_i \\le {10}^{12}$\uff0c\u4fdd\u8bc1\u6240\u6709 $a_i$ \u7684\u6700\u5c0f\u516c\u500d\u6570\u4e0d\u8d85\u8fc7 ${10}^{18}$\u3002</p> <p>\u8bf7\u6ce8\u610f\u7a0b\u5e8f\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u8fdb\u884c\u4e58\u6cd5\u8fd0\u7b97\u65f6\u7ed3\u679c\u53ef\u80fd\u6709\u6ea2\u51fa\u7684\u98ce\u9669\u3002</p> <p>\u6570\u636e\u4fdd\u8bc1\u6709\u89e3\u3002   </p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_88","title":"\u9898\u89e3\uff1a","text":"<p>\u4e0e\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\u7684\u533a\u522b\u5728$b$\u4e0d\u4e92\u8d28\u4e0a \u53ef\u4ee5\u8003\u8651\u6570\u5b66\u5f52\u7eb3\u6cd5\uff0c\u5df2\u7ecf\u6c42\u51fa\u524d$k-1$\u4e2a\u65b9\u7a0b\u7684\u89e3$ans$ \u8bb0$M=lcm(m_1,m_2,...,m_{k-1})$ \u8003\u8651\u6c42\u7b2ck\u4e2a\u65b9\u7a0b\u6c42\u51fa\u4e00\u4e2a$x$\u4f7f\u5f97$ans+x \\cdot M\\equiv a_k(\\bmod m_k)$ \u8be5\u65b9\u7a0b\u7b49\u4ef7\u4e8e$x \\cdot M\\equiv a_k-ans(\\bmod m_k)$  \u4ee4$c=a_k-ans$ \u5219\u6c42$x \\cdot M+m_k \\cdot y=c$ \u5229\u7528$exgcd(M,b_i,d,x,y)$\u53ef\u6c42\u51fax;  $x=x \\cdot \\frac{c}{d}$ ; \u5219$ans'=ans+x \\cdot M$</p> <pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long \n#define int ll\nconst int MaxN=1e5+100;\nint N,M=1;\nint a[MaxN],b[MaxN];\ntemplate&lt;class T&gt;\ninline void qread(T &amp;sum)\n{\n    sum=0;int boo=1;\n    char x=getchar();\n    while(x&lt;'0'||x&gt;'9'){if(x=='-')boo=-1;x=getchar();}\n    while(x&gt;='0'&amp;&amp;x&lt;='9'){sum=(sum&lt;&lt;1)+(sum&lt;&lt;3)+x-'0';x=getchar();}\n    sum*=boo;\n}\ntemplate&lt;class T&gt;\nvoid qput(T x)\n{\n    if(x&lt;0) {x=-x;putchar('-');}\n    if(x&gt;9){qput(x/10);}\n    putchar(x%10+48);\n}\nvoid exgcd(int a,int b,int &amp;d,int &amp;x,int &amp;y)\n{\n    if(!b)\n    {\n        d=a;x=1;y=0;\n        return;\n    }\n    exgcd(b,a%b,d,x,y);\n    int t=x;\n    x=y;y=t-a/b*y;\n}\nint mul(int x,int y,int p)//\u9f9f\u901f\u4e58\n{\n    int res=0;\n    while(y)\n    {\n        if(y&amp;1) res=(res+x)%p;\n        x=(x+x)%p;\n        y&gt;&gt;=1;\n    }\n    return res;\n}\nint excrt()\n{\n    int ans=a[1],M=b[1];\n    for(int i=2;i&lt;=N;i++)\n    {\n        int d,x,y,ts,c=((a[i]-ans)%b[i]+b[i])%b[i];\n        exgcd(M,b[i],d,x,y);\n        if(c%d!=0) return -1;\n        ts=b[i]/d;\n        x=mul(x,c/d,ts);\n//      x=x*c/d%ts;\n        ans+=x*M;\n        M=M*ts;\n        ans=(ans%M+M)%M;\n    }\n    return ans;\n}\nsigned main()\n{\n    qread(N);\n    for(int i=1;i&lt;=N;i++)\n    qread(b[i]),qread(a[i]);\n    int ans=excrt();\n    qput(ans);\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#pollard-rho","title":"\u3010\u6a21\u677f\u3011Pollard-Rho\u7b97\u6cd5","text":"<p>\u6ce8\u610f\uff1a1\u548c\u8d28\u6570\u7684\u60c5\u51b5\uff0c\u90fd\u4f1a\u4f7f\u7528dfs\u6b7b\u5faa\u73af</p> <pre><code>struct PollardRho {\n    vector&lt;ll&gt; G1; \n    inline ll mul(ll a, ll b, ll p) { //\u5feb\u901f\u4e58 \n        ll x = (long double)a / p * b;\n        return ((ull)a * b - (ull)x * p + p) % p;\n    }\n    inline ll ksm(ll x, ll y, ll p) {\n        ll res = 1;\n        while (y) {\n            if (y &amp; 1) res = mul(res, x, p);\n            x = mul(x, x, p);\n            y &gt;&gt;= 1;\n        }\n        return res;\n    }\n    ll gcd(ll x, ll y) {\n        if (y == 0) return x;\n        return gcd(y, x % y);\n    }\n    inline bool check(ll x) {\n        if (x == 0 || x == 1) return 0;\n        if (x == 2) return 1;\n        if (x % 2 == 0) return 0;\n        ll p = x - 1, q = 0;\n        while (p % 2 == 0)\n            q++, p /= 2;\n        for (int i = 1; i &lt;= 10; i++) {\n            int a = rand() % (x - 1) + 1;\n            ll v = ksm(a, p, x);\n            if (v == 1) continue;\n            int j;\n            for (j = 1; j &lt;= q; j++) {\n                if (v == x - 1) break;\n                v = mul(v, v, x);\n            }\n            if (j &gt; q) return 0;\n        }\n        return 1;\n    }\n    inline ll f(ll x, ll c, ll p) { return (mul(x, x, p) + c) % p; }\n    inline ll PR(ll n) {\n        if (n == 4) return 2;\n        ll x = rand() % (n - 1) + 1, y = x, c = rand() % (n - 1) + 1;\n        x = f(x, c, n), y = f(f(y, c, n), c, n);\n        for (int i = 1; x != y; i = min(i &lt;&lt; 1, 128ll)) {\n            ll cnt = 1;\n            for (int j = 0; j &lt; i; j++) {\n                cnt = mul(cnt, abs(x - y), n)   ;\n                if (!cnt) break;\n                x = f(x, c, n), y = f(f(y, c, n), c, n);\n            }\n            ll d = gcd(cnt, n);\n            if (d != 1) return d;\n        }\n        return n;\n    }\n    void dfs(ll n) {\n        ll d = PR(n);\n        while (d == n) d = PR(n);\n        ll d2 = n / d;\n        if (check(d)) G1.push_back(d);\n        else dfs(d);\n        if (check(d2)) G1.push_back(d2);\n        else dfs(d2);\n    }\n    inline vector&lt;ll&gt; solve(ll x) {\n        G1.clear();\n        if (check(x)) G1.push_back(x);\n        else dfs(x);\n        sort(G1.begin(), G1.end());\n        return G1;\n    }\n    inline vector&lt;pair&lt;int, int&gt; &gt; solve1(ll x) { // \u6bcf\u4e2a\u8d28\u6570\u4ee5\u53ca\u51fa\u73b0\u7684\u6570\u91cf\n        vector&lt;ll&gt; G1 = solve(x);\n        vector&lt;pair&lt;int, int&gt; &gt; ans;\n        int cnt = 0;\n        for (int i = 0; i &lt; (int)G1.size(); i++) {\n            cnt++;\n            if (i == (int)G1.size() - 1 || G1[i] != G1[i + 1]) {\n                ans.push_back(make_pair(G1[i], cnt));\n                cnt = 0;\n            }\n        }\n        return ans;\n    } \n} PR;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_89","title":"\u5b57\u7b26\u4e32","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#trie","title":"Trie","text":"<pre><code>struct trie{\n    int nex[MaxN][26],cnt;\n    bool exist[MaxN];\n    inline void insert(string s){\n        int p=0;\n        for(int i=0;i&lt;s.size();i++){\n            int c=s[i]-'a';\n            if(!nex[p][c]){\n                nex[p][c]=++cnt;\n            }\n            p=nex[p][c];\n        }\n        exist[p]=1;\n    }\n    inline bool find(string s){\n        int p=0;\n        for(int i=0;i&lt;s.size();i++){\n            int c=s[i]-'a';\n            if(!nex[p][c]){\n                return 0;\n            }\n            p=nex[p][c];\n        }\n        return exist[p];\n    }\n};\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#kmp","title":"kmp","text":"<pre><code>struct KMP {\n    vector&lt;int&gt; getP(string s1) { //\u4e0b\u68071\u5f00\u59cb\n        int n = s1.size() - 1;\n        int j = 0;\n        vector&lt;int&gt; p(n + 1);\n        for (int i = 1; i &lt; n; i++) {\n            while (j &gt; 0 &amp;&amp; s1[i + 1] != s1[j + 1]) j = p[j];\n            if (s1[i + 1] == s1[j + 1]) j++;\n            p[i + 1] = j;\n        }\n        return p;\n    }\n    int solve(string s1, string s2) { //\u4e0b\u6807\u4ece0\u5f00\u59cb\n        s1 = \" \" + s1;\n        s2 = \" \" + s2;\n        int n = s1.size() - 1;\n        int m = s2.size() - 1;\n        vector&lt;int&gt; p = getP(s2);\n        int j = 0;\n        int res = 0;\n        for (int i = 0; i &lt; n; i++) {\n            while (j &gt; 0 &amp;&amp; s1[i + 1] != s2[j + 1]) j = p[j];\n            if (s1[i + 1] == s2[j + 1]) j++;\n            if (j == m) {\n                res += 1;\n                j = p[j];\n            }\n        }\n        return res;\n    }\n} kmp;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#manacher","title":"Manacher","text":"<pre><code>struct Manacher {\n    int d1[MaxN], d2[MaxN], d[MaxN];\n    char s1[MaxN];\n    void solve(string ss) {\n        int N = ss.size() - 1;\n        for (int i = 1; i &lt;= 2 * N; i++) {\n            d1[i] = d2[i] = 0;\n        }\n        s1[1] = '#';\n        for (int i = 1; i &lt;= N; i++) {\n            s1[i &lt;&lt; 1] = ss[i];\n            s1[i &lt;&lt; 1 | 1] = '#';\n        }\n        N = 2 * N + 1;\n        for (int i = 1, l = 1, r = 0; i &lt;= N; i++) {\n            int k = (i &gt; r) ? 1 : min(d[l + r - i], r - i + 1);\n            while (1 &lt;= i - k &amp;&amp; i + k &lt;= N &amp;&amp; s1[i - k] == s1[i + k])\n                k++;\n            d[i] = k--;\n            if (i + k &gt; r) {\n                l = i - k;\n                r = i + k;\n            }\n        }\n        for (int i = 2; i &lt;= N; i++) {\n            if (i % 2 == 0) {\n                int t = (d[i] / 2 - 1) * 2 + 1;\n                d1[i / 2] = t;\n            } else {\n                int t = (d[i] - 1);\n                d2[i / 2 + 1] = t;\n            }\n        }\n    }\n} Manacher;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#kmpz","title":"\u3010\u6a21\u677f\u3011\u6269\u5c55 KMP\uff08Z \u51fd\u6570\uff09","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_90","title":"\u9898\u76ee\u63cf\u8ff0","text":"<p>\u7ed9\u5b9a\u4e24\u4e2a\u5b57\u7b26\u4e32 $a,b$\uff0c\u4f60\u8981\u6c42\u51fa\u4e24\u4e2a\u6570\u7ec4\uff1a</p> <ul> <li>$b$ \u7684 $z$ \u51fd\u6570\u6570\u7ec4 $z$\uff0c\u5373 $b$ \u4e0e $b$ \u7684\u6bcf\u4e00\u4e2a\u540e\u7f00\u7684 LCP \u957f\u5ea6\u3002</li> <li>$b$ \u4e0e $a$ \u7684\u6bcf\u4e00\u4e2a\u540e\u7f00\u7684 LCP \u957f\u5ea6\u6570\u7ec4 $p$\u3002</li> </ul> <p>\u5bf9\u4e8e\u4e00\u4e2a\u957f\u5ea6\u4e3a $n$ \u7684\u6570\u7ec4 $a$\uff0c\u8bbe\u5176\u6743\u503c\u4e3a $\\operatorname{xor}_{i=1}^n i \\times (a_i + 1)$\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_91","title":"\u8f93\u5165\u683c\u5f0f","text":"<p>\u4e24\u884c\u4e24\u4e2a\u5b57\u7b26\u4e32 $a,b$\u3002 $z[i]$\u8868\u793a\u4ece$i$\u5f00\u59cb\u548c\u4ece\u5934\u5f00\u59cb\u5339\u914d\uff0c\u4e00\u6837\u7684\u90e8\u5206\u6709\u591a\u957f\u3002 </p> <pre><code>inline void getz()\n{\n    z[1]=len2;\n    int l=0,r=0;\n    for(int i=2;i&lt;=len2;i++)\n    {\n        if(i&gt;r)\n        {\n            while(s2[z[i]+1]==s2[z[i]+i]) z[i]++;\n            l=i;r=z[i]+i-1;\n        }\n        else if(z[i-l+1]&lt;r-i+1)\n        {\n            z[i]=z[i-l+1];\n        }\n        else\n        {\n            z[i]=r-i;\n            while(s2[z[i]+1]==s2[z[i]+i]) z[i]++;\n            l=i;r=z[i]+i-1;\n        }\n    }\n}\ninline void getp()\n{\n    int l=0,r=0;\n    for(int i=1;i&lt;=len1;i++)\n    {\n        if(i&gt;r)\n        {\n            while(p[i]+1&lt;=len2&amp;&amp;p[i]+i&lt;=len1&amp;&amp;\n            s2[p[i]+1]==s1[p[i]+i]) p[i]++;\n            l=i;r=p[i]+i-1;\n        }\n        else if(z[i-l+1]&lt;r-i+1)\n        {\n            p[i]=z[i-l+1];\n        }\n        else\n        {\n            p[i]=r-i;\n            while(p[i]+1&lt;=len2&amp;&amp;\n            p[i]+i&lt;=len1&amp;&amp;s2[p[i]+1]==s1[p[i]+i]) p[i]++;\n            l=i;r=p[i]+i-1;\n        }\n    }\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_92","title":"\u540e\u7f00\u6570\u7ec4","text":"<pre><code>struct SA {\n    int sa[MaxN], rk[MaxN], oldrk[MaxN &lt;&lt; 1], id[MaxN], key1[MaxN], cnt[MaxN], height[MaxN];\n    int st[MaxN][25], logn[MaxN];\n    int n;\n    void init(string s1, int _n) {\n        n = _n;\n        for (int i = 0; i &lt;= max(n + 1, 127); i++) {\n            sa[i] = 0;\n            rk[i] = 0;\n            oldrk[i] = 0;\n            id[i] = 0;\n            key1[i] = 0;\n            cnt[i] = 0;\n            height[i] = 0;\n        }\n        getsa(s1);\n        getheight(s1);\n    }\n    bool cmp(int x, int y, int w) {\n        return oldrk[x] == oldrk[y] &amp;&amp; oldrk[x + w] == oldrk[y + w];\n    }\n    inline void getsa(string s) {\n        int i, m = 127, p, w;\n        // sa[i]\u8868\u793a\u540e\u7f00\u6392\u5e8f\u7b2ci\u5c0f\u7684\u7f16\u53f7\n        // rk[i]\u8868\u793a\u540e\u7f00i\u7684\u6392\u540d\n        for (i = 1; i &lt;= n; ++i) ++cnt[rk[i] = s[i]];\n        for (i = 1; i &lt;= m; ++i) cnt[i] += cnt[i - 1];\n        for (i = n; i &gt;= 1; --i) sa[cnt[rk[i]]--] = i;\n\n        for (w = 1;; w &lt;&lt;= 1, m = p) { // m=p \u5c31\u662f\u4f18\u5316\u8ba1\u6570\u6392\u5e8f\u503c\u57df\n            for (p = 0, i = n; i &gt; n - w; --i) id[++p] = i;\n            for (i = 1; i &lt;= n; ++i) \n                if (sa[i] &gt; w) id[++p] = sa[i] - w;\n            memset(cnt, 0, (m + 1) * sizeof(int));\n            for (i = 1; i &lt;= n; ++i) ++cnt[key1[i] = rk[id[i]]];\n            // \u6ce8\u610f\u8fd9\u91ccpx[i] != i\uff0c\u56e0\u4e3ark\u6ca1\u6709\u66f4\u65b0\uff0c\u662f\u4e0a\u4e00\u8f6e\u7684\u6392\u540d\u6570\u7ec4\n\n            for (i = 1; i &lt;= m; ++i) cnt[i] += cnt[i - 1];\n            for (i = n; i &gt;= 1; --i) sa[cnt[key1[i]]--] = id[i];\n            memcpy(oldrk + 1, rk + 1, n * sizeof(int));\n            for (p = 0, i = 1; i &lt;= n; ++i) rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;\n            if (p == n) break;\n        }\n    }\n    inline void getheight(string s){\n        // height[i]=lcp(sa[i],sa[i-1])\n        int i, k;\n        for (i = 1, k = 0; i &lt;= n; ++i) {\n            if (rk[i] == 0) continue;\n            if (k) --k;\n            while (i + k &lt;= n &amp;&amp; sa[rk[i] - 1] + k &lt;= n &amp;&amp; s[i + k] == s[sa[rk[i] - 1] + k]) ++k;\n            height[rk[i]] = k;\n        }\n    }\n    inline void pre() {\n        logn[0] = -1;\n        for (int i = 1; i &lt;= n; i++) logn[i] = logn[i / 2] + 1;\n        for (int i = 1; i &lt;= n; i++) st[i][0] = height[i];\n        for (int j = 1; j &lt;= 20; j++) {\n            int pj = 1 &lt;&lt; (j - 1);\n            for (int i = 1; i &lt;= n; i++) {\n                if (i + pj &lt;= n)\n                    st[i][j] = min(st[i][j - 1], st[i + pj][j - 1]);\n                else\n                    st[i][j] = st[i][j - 1];\n            }\n        }\n    }\n    inline int lcp(int l, int r) {\n        if (l == r) return n - l + 1;\n        l = rk[l];\n        r = rk[r];\n        if (l &gt; r) swap(l, r);\n        l++;\n        int lp = r - l + 1;\n        int n = 1 &lt;&lt; logn[lp];\n        return min(st[l][logn[lp]], st[r - n + 1][logn[lp]]);\n    }\n} SA;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#sam","title":"\u3010\u6a21\u677f\u3011\u540e\u7f00\u81ea\u52a8\u673a\uff08SAM\uff09","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_93","title":"\u9898\u76ee\u63cf\u8ff0","text":"<p>\u7ed9\u5b9a\u4e00\u4e2a\u53ea\u5305\u542b\u5c0f\u5199\u5b57\u6bcd\u7684\u5b57\u7b26\u4e32 $S$\u3002</p> <p>\u8bf7\u4f60\u6c42\u51fa $S$ \u7684\u6240\u6709\u51fa\u73b0\u6b21\u6570\u4e0d\u4e3a $1$ \u7684\u5b50\u4e32\u7684\u51fa\u73b0\u6b21\u6570\u4e58\u4e0a\u8be5\u5b50\u4e32\u957f\u5ea6\u7684\u6700\u5927\u503c\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_94","title":"\u8f93\u5165\u683c\u5f0f","text":"<p>\u4e00\u884c\u4e00\u4e2a\u4ec5\u5305\u542b\u5c0f\u5199\u5b57\u6bcd\u7684\u5b57\u7b26\u4e32 $S$\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_95","title":"\u8f93\u51fa\u683c\u5f0f","text":"<p>\u4e00\u4e2a\u6574\u6570\uff0c\u4e3a\u6240\u6c42\u7b54\u6848\u3002</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_23","title":"\u6837\u4f8b #1","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_24","title":"\u6837\u4f8b\u8f93\u5165 #1","text":"<pre><code>abab\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#1_25","title":"\u6837\u4f8b\u8f93\u51fa #1","text":"<pre><code>4\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#sam_1","title":"\u540e\u7f00\u81ea\u52a8\u673a(SAM)","text":"<pre><code>struct SAM {\n    struct Point { // 2 * MaxN\n        int ch[26];\n        int len, fa;\n        int firstPos;\n    } tree[MaxN];\n    int tot = 1, last = 1, F[MaxN], id[MaxN];\n    inline void clear() {\n        for (int i = 0; i &lt;= tot; i++) {\n            F[i] = 0;\n            tree[i].len = tree[i].fa = tree[i].firstPos = 0;\n            memset(tree[i].ch, 0, sizeof(tree[i].ch));\n        }\n        tot = 1; last = 1;\n    }\n    void add1(int c) {\n        int p = last, np = last = ++tot;\n        F[tot] = 1;\n        tree[np].len = tree[p].len + 1;\n        tree[np].firstPos = tree[np].len - 1;\n        for (; p &amp;&amp; !tree[p].ch[c]; p = tree[p].fa) {\n            tree[p].ch[c] = np;\n        } \n        if (!p) {\n            tree[np].fa = 1;\n        } else {\n            int q = tree[p].ch[c]; \n            if (tree[q].len == tree[p].len + 1) {\n                tree[np].fa = q;\n            } else {\n                int nq = ++tot;\n                tree[nq] = tree[q];\n                tree[nq].len = tree[p].len + 1;\n                tree[q].fa = tree[np].fa = nq;\n                for (; p &amp;&amp; tree[p].ch[c] == q; p = tree[p].fa) {\n                    tree[p].ch[c] = nq;\n                }\n            }\n        }\n    }\n    void sort1() {\n        vector&lt;int&gt; vis(tot + 1);\n        for (int i = 1; i &lt;= tot; i++) vis[tree[i].len]++;\n        for (int i = 1; i &lt;= tot; i++) vis[i] += vis[i - 1];\n        for (int i = tot; i &gt;= 1; i--) id[vis[tree[i].len]--] = i;\n    }\n    void insert(string s1) {\n        for (auto x : s1) {\n            add1(x - 'A');\n        }\n    }\n    int getF() { //\u51fa\u73b0\u6b21\u6570\n        int ans = 0;\n        sort1();\n        for (int i = tot; i &gt;= 1; i--) {\n            int t = id[i];\n            F[tree[t].fa] += F[t];\n            if (F[t] &gt; 1) ans = max(ans, F[t] * tree[t].len);\n        }\n        return ans;\n    }\n    pair&lt;int, int&gt; getMinOne() { //\u51fa\u73b0\u4e00\u6b21\u6700\u77ed\u7684\u5b57\u7b26\u4e32\u957f\u5ea6\u548c\u4f4d\u7f6e\n        getF();\n        int len = INF, p = 0;\n        for (int i = tot; i &gt;= 1; i--) {\n            int x = id[i], f = tree[x].fa;\n            if (F[x] != 1) continue;\n            if (tree[f].len + 1 &lt; len) {\n                len = tree[f].len + 1;\n                p = tree[x].firstPos;\n            } else if (tree[f].len + 1 == len) {\n                p = min(p, tree[x].firstPos);\n            }\n        }\n        return make_pair(len, p);\n    }\n} SAM;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#exsam","title":"EXSAM","text":"<pre><code>struct EXSAM {\n    struct Point { // 2 * MaxN\n        int ch[26];\n        int len, fa;\n    } tree[MaxN];\n    int tot = 1, F[MaxN], id[MaxN];\n    int vis[MaxN][10];\n    inline void clear() {\n        for (int i = 0; i &lt;= tot; i++) {\n            F[i] = 0;\n            tree[i].len = tree[i].fa = 0;\n            memset(tree[i].ch, 0, sizeof(tree[i].ch));\n        }\n        tot = 1;\n        T = 0;\n    }\n    int add1(int last, int c) {\n        int p = tree[last].fa, np = tree[last].ch[c];\n        if (tree[np].len) return np;\n        tree[np].len = tree[last].len + 1;\n        for (; p &amp;&amp; !tree[p].ch[c]; p = tree[p].fa) {\n            tree[p].ch[c] = np;\n        } \n        if (!p) {\n            tree[np].fa = 1;\n        } else {\n            int q = tree[p].ch[c]; \n            if (tree[q].len == tree[p].len + 1) {\n                tree[np].fa = q;\n            } else {\n                int nq = ++tot;\n                tree[nq] = tree[q];\n                for (int i = 0; i &lt; 26; ++i)\n                    tree[nq].ch[i] = tree[tree[q].ch[i]].len? tree[q].ch[i] : 0;\n                tree[nq].len = tree[p].len + 1;\n                tree[q].fa = tree[np].fa = nq;\n                for (; p &amp;&amp; tree[p].ch[c] == q; p = tree[p].fa) {\n                    tree[p].ch[c] = nq;\n                }\n            }\n        }\n        return np;\n    }\n    int insertTire(int x, int c) {\n        if (!tree[x].ch[c]) tree[x].ch[c] = ++tot;\n        vis[tree[x].ch[c]][T] = 1;\n        return tree[x].ch[c];\n    }\n    void insert(string s1) {\n        int root = 1;\n        for (auto x : s1) {\n            root = insertTire(root, x - 'a');\n        }\n        T++;\n    }\n    void build() {\n        queue&lt;pair&lt;int, int&gt;&gt; q;\n        for (int i = 0; i &lt; 26; i++) {\n            if (tree[1].ch[i]) q.push(make_pair(i, 1));\n        }\n        while (!q.empty()) {\n            auto now = q.front(); q.pop();\n            auto last = add1(now.second, now.first);\n            for (int i = 0; i &lt; 26; i++) {\n                if (tree[last].ch[i]) q.push(make_pair(i, last));\n            }\n        }\n    }\n    void sort1() {\n        vector&lt;int&gt; vis(tot + 1);\n        for (int i = 1; i &lt;= tot; i++) vis[tree[i].len]++;\n        for (int i = 1; i &lt;= tot; i++) vis[i] += vis[i - 1];\n        for (int i = tot; i &gt;= 1; i--) id[vis[tree[i].len]--] = i;\n    }\n    int solve() {\n        int ans = 0;\n        sort1();\n        for (int t = tot; t &gt;= 1; t--) {\n            int i = id[t], now = tree[i].len - tree[tree[i].fa].len;\n            for (int j = 0; j &lt; T; j++) {\n                vis[tree[i].fa][j] += vis[i][j];\n                now *= vis[i][j];\n            }\n            ans += now;\n        }\n        return ans;\n    }\n} EXSAM;\n</code></pre> <pre><code>struct EXSAM {\n    struct Point { // 2 * MaxN\n        map&lt;int, int&gt; ch;\n        int len, fa;\n    } tree[MaxN];\n    int tot = 1, F[MaxN], id[MaxN];\n    int vis[MaxN][10];\n    inline void clear() {\n        for (int i = 0; i &lt;= tot; i++) {\n            F[i] = 0;\n            tree[i].len = tree[i].fa = 0;\n            tree[i].ch.clear();\n        }\n        tot = 1;\n    }\n    int add1(int last, int c) {\n        int p = last, np = last = ++tot;\n        F[tot] = 1;\n        tree[np].len = tree[p].len + 1;\n        for (; p &amp;&amp; !tree[p].ch[c]; p = tree[p].fa) {\n            tree[p].ch[c] = np;\n        } \n        if (!p) {\n            tree[np].fa = 1;\n        } else {\n            int q = tree[p].ch[c]; \n            if (tree[q].len == tree[p].len + 1) {\n                tree[np].fa = q;\n            } else {\n                int nq = ++tot;\n                tree[nq] = tree[q];\n                tree[nq].len = tree[p].len + 1;\n                tree[q].fa = tree[np].fa = nq;\n                for (; p &amp;&amp; tree[p].ch[c] == q; p = tree[p].fa) {\n                    tree[p].ch[c] = nq;\n                }\n            }\n        }\n        return np;\n    }\n    void insert(string s1) {\n        int root = 1;\n        for (auto x : s1) {\n            root = add1(root, x);\n        }\n    }\n    void sort1() {\n        vector&lt;int&gt; vis(tot + 1);\n        for (int i = 1; i &lt;= tot; i++) vis[tree[i].len]++;\n        for (int i = 1; i &lt;= tot; i++) vis[i] += vis[i - 1];\n        for (int i = tot; i &gt;= 1; i--) id[vis[tree[i].len]--] = i;\n    }\n    int solve() {\n        int ans = 0;\n        // sort1();\n        for (int i = tot; i &gt;= 2; i--) {\n            int t = i;\n            ans += tree[t].len - tree[tree[t].fa].len;\n        }\n        return ans;\n    }\n} EXSAM;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_96","title":"\u6700\u957f\u516c\u5171\u5b50\u4e32","text":"<pre><code>    void build() {\n        sort1();\n        for (int i = 1; i &lt;= tot; i++) {\n            minn[i] = INF;\n        }\n    }\n    // \u6c42\u591a\u4e2a\u5b57\u7b26\u4e32\u6700\u957f\u516c\u5171\u5b57\u4e32\uff0c\u5c06\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e32\u5efaSAM\uff0c\u5176\u4f59solve\uff0c\u6700\u540e\u4e00\u4e2a\u4e3a\u7b54\u6848\n    int solve(string s1) {\n        int x = 1, len = 0;\n        for (auto c : s1) {\n            while (1) {\n                if (tree[x].ch[c]) {\n                    x = tree[x].ch[c];\n                    len++;\n                    break;\n                }\n                if (!len) break;;\n                if (--len == tree[tree[x].fa].len) {\n                    x = tree[x].fa;\n                }\n            }\n            if (x) {\n                maxn[x] = max(maxn[x], len);\n            }\n        }\n        int ans = 0;\n        for (int i = tot; i &gt;= 1; i--) {\n            int x = id[i], fa = tree[x].fa;\n            maxn[fa] = max(maxn[fa], min(tree[fa].len, maxn[x]));\n            minn[x] = min(minn[x], maxn[x]);\n            maxn[x] = 0;\n            ans = max(ans, minn[x]);\n        }\n        return ans;\n    }\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_97","title":"\u56de\u6587\u81ea\u52a8\u673a\uff08\u56de\u6587\u6811\uff09","text":"<pre><code>struct Pam {\n    int sz, tot, last;\n    int cnt[MaxN], ch[MaxN][26], len[MaxN], fail[MaxN];\n    char s[MaxN];\n    int node(int l) {  // \u5efa\u7acb\u4e00\u4e2a\u65b0\u8282\u70b9\uff0c\u957f\u5ea6\u4e3a l\n        sz++;\n        memset(ch[sz], 0, sizeof(ch[sz]));\n        len[sz] = l;\n        fail[sz] = cnt[sz] = 0;\n        return sz;\n    }\n\n    void clear() {  // \u521d\u59cb\u5316\n        sz = -1;\n        last = 0;\n        s[tot = 0] = '$';\n        node(0);\n        node(-1);\n        fail[0] = 1;\n    }\n\n    int getfail(int x) {  // \u627e\u540e\u7f00\u56de\u6587\n        while (s[tot - len[x] - 1] != s[tot]) x = fail[x];\n        return x;\n    }\n\n    void insert(char c) {  // \u5efa\u6811\n        s[++tot] = c;\n        int now = getfail(last);\n        if (!ch[now][c - 'a']) {\n            int x = node(len[now] + 2);\n            fail[x] = ch[getfail(fail[now])][c - 'a'];\n            ch[now][c - 'a'] = x;\n        }\n        last = ch[now][c - 'a'];\n        cnt[last]++;\n    }\n\n    int Solve() {\n        for (int i = sz; i &gt;= 0; i--) {\n            cnt[fail[i]] += cnt[i];\n        }\n        int ans = 0;\n        for (int i = 1; i &lt;= sz; i++) {\n            ans = max(ans, cnt[i] * len[i]);\n        }\n        return ans;\n    }\n} pam;\n\nstruct Pam {\n    int sz, tot, last, num;\n    int cnt[MaxN], len[MaxN], fail[MaxN];\n    int fir[MaxN], nex[MaxN], go[MaxN], w[MaxN];\n    int pos[MaxN];\n    char s[MaxN];\n    inline void add1(int x, int y, int z) {\n        nex[++num] = fir[x];\n        fir[x] = num;\n        go[num] = y;\n        w[num] = z;\n    }\n    inline int get(int x ,int y) {\n        for (int i = fir[x]; i; i = nex[i]) {\n            if (go[i] == y) return w[i];\n        }\n        return 0;\n    }\n    int node(int l) {  // \u5efa\u7acb\u4e00\u4e2a\u65b0\u8282\u70b9\uff0c\u957f\u5ea6\u4e3a l\n        sz++;\n        len[sz] = l;\n        fail[sz] = cnt[sz] = 0;\n        return sz;\n    }\n    void clear() {  // \u521d\u59cb\u5316\n        sz = -1;\n        last = 0;\n        s[tot = 0] = '$';\n        node(0);\n        node(-1);\n        fail[0] = 1;\n        memset(fir, 0, sizeof fir);\n        num = 0;\n    }\n\n    int getfail(int x) {  // \u627e\u540e\u7f00\u56de\u6587\n        while (s[tot - len[x] - 1] != s[tot]) x = fail[x];\n        return x;\n    }\n\n    void insert(char c) {  // \u5efa\u6811\n        s[++tot] = c;\n        int now = getfail(last);\n        if (!get(now, c - 'a')) {\n            int x = node(len[now] + 2);\n            fail[x] = get(getfail(fail[now]), c - 'a');\n            add1(now, c - 'a', x);\n        }\n        last = get(now, c - 'a');\n        cnt[last] = cnt[fail[last]] + 1;\n        pos[tot] = cnt[last];\n    }\n} pam;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#acacm","title":"AC\u81ea\u52a8\u673a(ACM)","text":"<pre><code>struct ACM {\n    // flag: \u8fd9\u4e2a\u70b9\u548c\u4ed6\u7684nex\u5305\u542b\u4e0d\u5305\u542b\u6a21\u5f0f\u4e32\n    // bo: \u8fd9\u4e2a\u70b9\u5305\u542b\u54ea\u51e0\u4e2a\u5b57\u7b26\u4e32\n    // vis \u5bf9\u5e94\u4e32\u51fa\u73b0\u6b21\u6570\n    // rev: \u7b2ci\u4e2a\u5b57\u7b26\u4e32\u5bf9\u5e94\u7684\u8282\u70b9\n    struct Point {\n        int nex;\n        vector&lt;int&gt; bo;\n        int ch[26];\n    } tree[MaxN];\n    int flag[MaxN], in[MaxN], ans[MaxN], rev[MaxN], vis[MaxN];\n    int cnt;\n    void clear() {\n        for (int i = 0; i &lt;= cnt; i++) {\n            tree[i].nex = 0;\n            tree[i].bo.clear();\n            memset(tree[i].ch, 0, sizeof tree[i].ch);\n            flag[i] = 0;\n            in[i] = 0;\n            rev[i] = 0;\n            vis[i] = 0;\n            ans[i] = 0;\n        }\n        cnt = 1;\n    }\n    void insert(string s1, int num) {\n        int u = 1;\n        for (int i = 0; i &lt; (int)s1.size(); i++) {\n            int c = s1[i] - 'a';\n            if (!tree[u].ch[c]) {\n                tree[u].ch[c] = ++cnt;\n            }\n            u = tree[u].ch[c];\n        }\n        tree[u].bo.push_back(num);\n        rev[num] = u;\n        flag[u] = 1;\n    }\n    void bfs() {\n        for (int i = 0; i &lt; 26; i++) {\n            tree[0].ch[i] = 1;\n        }\n        queue&lt;int&gt; q;\n        q.push(1);\n        tree[1].nex = 0;\n        while (!q.empty()) {\n            auto u = q.front(); q.pop();\n            for (int i = 0; i &lt; 26; i++) {\n                if (!tree[u].ch[i]) tree[u].ch[i] = tree[tree[u].nex].ch[i];\n                else {\n                    q.push(tree[u].ch[i]);\n                    int v = tree[u].nex;\n                    tree[tree[u].ch[i]].nex = tree[v].ch[i];\n                    flag[tree[u].ch[i]] += flag[tree[v].ch[i]];\n                    in[tree[v].ch[i]]++;\n                }\n            }\n        }\n    }\n    void topu() {\n        vector&lt;int&gt; indeg(cnt + 1);\n        queue&lt;int&gt; q;\n        for (int i = 1; i &lt;= cnt; i++) {\n            indeg[i] = in[i];\n            if (!indeg[i]) q.push(i);\n        }\n        while (!q.empty()) {\n            int x = q.front(); q.pop();\n            int y = tree[x].nex;\n            for (auto t : tree[x].bo) {\n                vis[t] = ans[x];\n            }\n\n            ans[y] += ans[x];\n            indeg[y]--;\n            if (!indeg[y]) {\n                q.push(y);\n            }\n\n        }\n    }\n    void query(string ss) {\n        int u = 1;\n        for (int i = 0; i &lt; ss.size(); i++) {\n            int c = ss[i] - 'a';\n            u = tree[u].ch[c];\n            ans[u]++;\n        }\n    }\n\n} ACM;\ninline void Solve() {\n    cin &gt;&gt; N;\n    ACM.clear();\n    for (int i = 1; i &lt;= N; i++) {\n        cin &gt;&gt; s1;\n        ACM.insert(s1, i);\n    }\n    ACM.bfs();\n    cin &gt;&gt; s1;\n    ACM.query(s1);\n    ACM.topu();\n    for (int i = 1; i &lt;= N; i++) {\n        cout &lt;&lt; ACM.vis[i] &lt;&lt; endl;\n    }\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_98","title":"\u56fe\u8bba","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#tarjan","title":"tarjan","text":"<pre><code>int st[MaxN], top, col, co[MaxN], num, dfn[MaxN], low[MaxN];\nvector&lt;int&gt; G1[MaxN], G2[MaxN];\nstruct Point {\n    int x, y;\n} b[MaxN]; // \u6ce8\u610f\u8fb9\u9700\u8981\u5b58\u5230b\u91cc\u9762\nint F[MaxN], ans[MaxN];\ninline void tarjan(int x) {\n    dfn[x] = low[x] = ++num;\n    st[++top] = x;\n    for (int i = 0; i &lt; (int)G1[x].size(); i++) {\n        int y = G1[x][i];\n        if (!dfn[y]) {\n            tarjan(y);\n            low[x] = min(low[x], low[y]);\n        }\n        else if (!co[y]) {\n            low[x] = min(low[x], dfn[y]);\n        }\n    }\n    if (low[x] == dfn[x]) {\n        co[x] = ++col;\n        while (st[top] != x) {\n            co[st[top]] = col;\n            top--;\n        }\n        top--;\n    }\n}\ninline void solve() {\n    for (int i = 1; i &lt;= N; i++) {\n        if (!dfn[i]) tarjan(i);\n    }\n    for (int i = 1; i &lt;= M; i++) {\n        auto [x, y] = b[i];\n        if (co[x] != co[y]) {\n            G2[co[y]].push_back(co[x]);\n            in[co[x]]++;\n        }\n    }\n    for (int i = 1; i &lt;= N; i++) {\n        c[co[i]] += a[i];\n        sum[co[i]]++;\n    }\n    queue&lt;int&gt; q;\n    for (int i = 1; i &lt;= col; i++) {\n        if (!in[i]) q.push(i);\n    }\n\n    while (!q.empty()) {\n        int x = q.front(); q.pop();\n        for (auto y : G2[x]) {\n            in[y]--;\n            if (!in[y]) {\n                q.push(y);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_99","title":"\u6a21\u677f\u3011\u5355\u6e90\u6700\u77ed\u8def\u5f84\uff08\u6807\u51c6\u7248\uff09","text":"<pre><code>struct Dijkstra{\n    int d[MaxN], vis[MaxN];\n    struct Point {\n        int id, x;\n        inline bool operator&lt;(const Point &amp;aa)const {\n            return x &gt; aa.x;\n        }\n    };\n    priority_queue&lt;Point&gt;q;\n    inline void solve(int S) {\n        for(int i = 1; i &lt;= N; i++) d[i] = INF, vis[i] = 0;\n\n        d[S] = 0;\n        q.push((Point){ S, 0 });\n        while(!q.empty()) {\n            auto [x, w] = q.top(); q.pop();\n            if (vis[x]) continue;\n            vis[x] = 1;\n            for(auto it : G1[x]) {\n                int y = it.first;\n                int z = it.second;\n                if(d[x] + z &lt; d[y]) {\n                    d[y] = d[x] + z;\n                    if(!vis[y])  q.push((Point){ y, d[y] });\n                }\n            }\n        }\n    }\n} dij;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#ek","title":"EK\u8d39\u7528\u6d41\u5904\u7406\u8d1f\u73af","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\n#define lowbit(x) (x)&amp;(-x)\n#define zuo p&lt;&lt;1\n#define you p&lt;&lt;1|1\n#define INF 9187201950435737471\nconst int MaxN=1e5+100;\nint a[51][51],N,M,s,t,K,st,tt;\nint fir[MaxN],nex[MaxN],go[MaxN],tot=1,w[MaxN],v[MaxN];\nint ans,incf[MaxN],d[MaxN],vis[MaxN],pre[MaxN],maxn,ts,ans1,total[MaxN];\ntemplate&lt;class T&gt;\ninline void qread(T &amp;sum)\n{\n    sum=0;int boo=1;\n    char x=getchar();\n    while(x&lt;'0'||x&gt;'9'){if(x=='-')boo=-1;x=getchar();}\n    while(x&gt;='0'&amp;&amp;x&lt;='9'){sum=(sum&lt;&lt;1)+(sum&lt;&lt;3)+x-'0';x=getchar();}\n    sum*=boo;\n}\ntemplate&lt;class T&gt;\nvoid qput(T x)\n{\n    if(x&lt;0) {x=-x;putchar('-');}\n    if(x&gt;9){qput(x/10);}\n    putchar(x%10+48);\n}\ninline void add1(int x,int y,int z,int k)\n{\n    nex[++tot]=fir[x];fir[x]=tot;go[tot]=y;w[tot]=z;v[tot]=k;\n    nex[++tot]=fir[y];fir[y]=tot;go[tot]=x;w[tot]=0;v[tot]=-k;\n}\ninline bool spfa(int s,int t)\n{\n    queue&lt;int&gt;q;\n    memset(d,127,sizeof d);\n    memset(vis,0,sizeof v);\n    q.push(s);d[s]=0;vis[s]=1;\n    incf[s]=INF;\n    while(!q.empty())\n    {\n        int x=q.front();q.pop();\n        vis[x]=0;\n        for(int i=fir[x];i;i=nex[i])\n        {\n            int y=go[i],z=w[i],k=v[i];\n            if(z&amp;&amp;d[x]+k&lt;d[y])\n            {\n                d[y]=d[x]+k;\n                incf[y]=min(incf[x],z);\n                pre[y]=i;\n                if(!vis[y])\n                {\n                    vis[y]=1;\n                    q.push(y);\n                }\n            }\n        }\n    }\n    if(d[t]&gt;=INF) return 0;\n    return 1;\n}\ninline void updata(int s,int t)\n{\n    int x=t;\n    ans=0;\n    while(x!=s)\n    {\n        int i=pre[x];\n        ans+=v[i];\n        w[i]-=incf[t];\n        w[i^1]+=incf[t];\n        x=go[i^1];\n    }\n    maxn+=incf[t]*ans;\n    ans1+=incf[t];\n}\nsigned main()\n{\n    qread(N);qread(M);\n    qread(s);qread(t);\n    st=N+1;tt=N+2;\n    for(int i=1;i&lt;=M;i++)\n    {\n        int x,y,z,k;\n        qread(x);qread(y);qread(z);qread(k);\n        if(k&gt;=0)\n        add1(x,y,z,k);\n        else\n        {\n            add1(y,x,z,-k);\n            total[x]-=z;total[y]+=z;\n            maxn+=k*z;\n        }\n    }\n    for(int i=1;i&lt;=N;i++)\n    {\n        if(!total[i]) continue;\n        if(total[i]&gt;0)\n        {\n            add1(st,i,total[i],0);\n        }\n        else\n        {\n            add1(i,tt,-total[i],0);\n        }\n    }\n    while(spfa(st,tt)) updata(st,tt);\n    ans1=0;\n    while(spfa(s,t)) updata(s,t);\n    qput(ans1);putchar(' ');\n    qput(maxn);putchar('\\n');\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#dinic","title":"\u6700\u5927\u6d41\uff08dinic\uff09","text":"<pre><code>struct wll {\n    int  s, t;\n    int fir[MaxN], nex[MaxN], go[MaxN], w[MaxN] , tot = 1;\n    int d[MaxN], v[MaxN], cur[MaxN];\n    void clear() {\n        for (int i = s; i &lt;= t; i++) {\n            fir[i] = 0;\n        }\n        tot = 1;\n    }\n    void add1(int x, int y, int z) {\n        nex[++tot] = fir[x]; fir[x] = tot; go[tot] = y; w[tot] = z;\n        nex[++tot] = fir[y]; fir[y] = tot; go[tot] = x; w[tot] = 0;\n    }\n    inline bool bfs() {\n        for (int i = s; i &lt;= t; i++) {\n            d[i] = 0;\n        }\n        queue&lt;int&gt; q;\n        q.push(s); d[s] = 1;\n        cur[s] = fir[s];\n        while (!q.empty()) {\n            int x = q.front(); q.pop();\n            for (int i = fir[x]; i; i = nex[i]) {\n                int y = go[i], z = w[i];\n                if (z &amp;&amp; !d[y]) {\n                    cur[y] = fir[y];\n                    d[y] = d[x] + 1;\n                    q.push(y);\n                    if (y == t) return 1;\n                }\n            }\n        }\n        return 0;\n    }\n    int dinic(int x, int flow) {\n        if (x == t) return flow;\n        int rest = flow, k;\n        for (int i = cur[x]; i &amp;&amp; rest; i = nex[i]) {\n            int y = go[i], z = w[i];\n            cur[x] = i;\n            if (z &amp;&amp; d[y] == d[x] + 1) {\n                k = dinic(y, min(rest, w[i]));\n                if (!k) d[y] = 0;\n                w[i] -= k;\n                w[i ^ 1] += k;\n                rest -= k;\n            }\n        }\n        return flow - rest;\n    }\n    vector&lt;int&gt; vis1, vis2;\n    void dfs1(int x) {\n        vis1[x] = 1; \n        for (int i = fir[x]; i; i = nex[i]) {\n            int y = go[i], z = w[i];\n            if (vis1[y]) continue;\n            if (z) {\n                dfs1(y);\n            }\n        }\n    }\n    void dfs2(int x) {\n        vis2[x] = 1; \n        for (int i = fir[x]; i; i = nex[i]) {\n            int y = go[i], z = w[i];\n            if (vis2[y]) continue;\n            if (!z) {\n                dfs2(y);\n            }\n        }\n    }\n    int solve() {\n        int ans = 0, flow;\n        while (bfs()) {\n            while (flow = dinic(s, INF)) ans += flow;\n        }\n        return ans;\n    }\n} di;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_100","title":"\u8d39\u7528\u6d41","text":"<pre><code>struct fyl {\n    int fir[MaxN], nex[MaxN], go[MaxN], w[MaxN], v[MaxN], tot = 1;\n    int d[MaxN], vis[MaxN], incf[MaxN], pre[MaxN];\n    int s, t;\n    int minn, ans; // \u6d41\u91cf\uff0c \u8d39\u7528\n    inline void add1(int x, int y, int z, int k) {\n        nex[++tot] = fir[x]; fir[x] = tot; go[tot] = y; w[tot] = z; v[tot] = k;\n        nex[++tot] = fir[y]; fir[y] = tot; go[tot] = x; w[tot] = 0; v[tot] = -k;\n    }\n    inline bool bfs() {\n        queue&lt;int&gt; q;\n        memset(d, 127, sizeof d);\n        memset(vis, 0, sizeof vis);\n        q.push(s);\n        d[s] = 0;\n        vis[s] = 1;\n        incf[s] = INF;\n        while (!q.empty()) {\n            int x = q.front(); q.pop();\n            vis[x] = 0;\n            for (int i = fir[x]; i; i = nex[i]) {\n                int y = go[i], z = w[i], k = v[i];\n                if (z &amp;&amp; d[x] + k &lt; d[y]) {\n                    d[y] = d[x] + k;\n                    incf[y] = min(incf[x], z);\n                    pre[y] = i;\n                    if (!vis[y]) {\n                        vis[y] = 1;\n                        q.push(y);\n                    }\n                }\n            }\n        }\n        if (d[t] == INF) return 0;\n        return 1;\n    }\n    inline void updata() {\n        int x = t;\n        int sum = 0;\n        while (x != s) {\n            int i = pre[x];\n            sum += v[i];\n            w[i] -= incf[t];\n            w[i ^ 1] += incf[t];\n            x = go[i ^ 1];\n        }\n        ans += sum * incf[t];\n        minn += incf[t];\n    }\n    inline pair&lt;int, int&gt; solve() {\n        while (bfs()) updata();\n        return make_pair(minn, ans);\n    }\n} fyl;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#2-sat","title":"2-SAT","text":"<pre><code>struct TwoSat {\n    int st[MaxN], top, col, co[MaxN], num, dfn[MaxN], low[MaxN];\n    vector&lt;int&gt; G1[MaxN];\n    int N;\n    void clear(int n) {\n        col = top = num = 0;\n        for (int i = 0; i &lt;= 2 * n; i++) {\n            st[i] = co[i] = dfn[i] = low[i] = 0;\n            G1[i].clear();\n        }\n    }\n    void init(int n) {\n        clear(n);\n        N = n;\n    }\n\n    inline void tarjan(int x) {\n        dfn[x] = low[x] = ++num;\n        st[++top] = x;\n        for (auto y : G1[x]) {\n            if (!dfn[y]) {\n                tarjan(y);\n                low[x] = min(low[x], low[y]);\n            }\n            else if (!co[y]) {\n                low[x] = min(low[x], dfn[y]);\n            }\n        }\n        if (low[x] == dfn[x]) {\n            co[x] = ++col;\n            while (st[top] != x) {\n                co[st[top]] = col;\n                top--;\n            }\n            top--;\n        }\n    }\n    int inv(int x) {\n        if (x &gt; N) return x - N;\n        return x + N;\n    }\n    void insert(int x, int y) {\n        G1[x].push_back(y);\n    }\n    void add1(int x, int y) { //\u8574\u542b\u5173\u7cfb\n        G1[x].push_back(y);\n        G1[inv(y)].push_back(inv(x));\n    }\n    void equal(int x, int y) {\n        add1(x, y);\n        add1(inv(x), inv(y));\n    }\n    void unequal(int x, int y) {\n        add1(x, inv(y));\n        add1(inv(x), y);\n    }\n    void either(int x, int y) {\n        G1[inv(x)].push_back(y);\n        G1[inv(y)].push_back(x);\n    }\n    void equalTrue(int x) { //\u8bbex\u4e3a\u771f\n        G1[inv(x)].push_back(x);\n    }\n    bool run() {\n        for (int i = 1; i &lt;= 2 * N; i++) {\n            if (!dfn[i]) tarjan(i);\n        }\n        for (int i = 1; i &lt;= N; i++) {\n            if (co[i] == co[i + N]) return 0;\n        }\n        return 1;\n    }\n    vector&lt;int&gt; query() {\n        vector&lt;int&gt; now(N);\n        for (int i = 1; i &lt;= N; i++) {\n            now[i - 1] = co[i] &lt; co[inv(i)];\n        }\n        return now;\n    }\n} TS;\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#dp","title":"dp","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_101","title":"\u659c\u7387\u4f18\u5316","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define lowbit(x) (x)&amp;(-x)\n#define zuo p&lt;&lt;1\n#define you p&lt;&lt;1|1\n#define INF 2147483647\nconst int MaxN=1e6+100;\nint N,M,l,r;\nll a,b,c,sum[MaxN],F[MaxN],q[MaxN];\ndouble js(int x,int y)\n{\n    double sum1=-b*sum[y]+a*sum[y]*sum[y]+F[y]-\n    (-b*sum[x]+a*sum[x]*sum[x]+F[x]);\n    double sum2=sum[y]-sum[x];\n    return sum1/sum2;\n}\nint main()\n{\n    qread(N);\n    qread(a);qread(b);qread(c);\n    memset(F,-127,sizeof F);\n    F[0]=0;\n    for(int i=1;i&lt;=N;i++)\n    {\n        qread(sum[i]);\n        sum[i]+=sum[i-1];\n    }\n    l=r=1;\n    q[l]=0;\n    for(int i=1;i&lt;=N;i++)\n    {\n        while(l&lt;r&amp;&amp;js(q[l],q[l+1])&gt;2*a*sum[i]) l++;\n        int j=q[l];\n        F[i]=F[j]+a*(sum[i]-sum[j])*(sum[i]-sum[j])+\n        b*(sum[i]-sum[j])+c;\n        while(l&lt;r&amp;&amp;js(q[r-1],q[r])&lt;js(q[r],i)) r--;\n        q[++r]=i;\n    }\n    qput(F[N]);\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_102","title":"\u8ba1\u7b97\u51e0\u4f55","text":"<pre><code>const ld eps = 1e-12;\nstruct Point {\n    ld x, y;\n    inline ld Rand() {\n        return rand() / (ld)RAND_MAX;\n    }\n    inline void shake() {\n        x += (Rand() - 0.5) * eps;\n        y += (Rand() - 0.5) * eps;\n    }\n    inline bool operator &lt;(const Point &amp;aa) const{\n        if (x != aa.x) return x &lt; aa.x;\n        return y &lt; aa.y; \n    }\n    inline double operator*(const Point &amp;aa) const {\n        return x * aa.x + y * aa.y;\n    }\n    inline ld operator /(const Point &amp;aa) const {\n        return x * aa.y - y * aa.x;\n    }\n    inline Point operator +(const Point &amp;aa) const {\n        return (Point){aa.x + x, aa.y + y};\n    }\n    inline Point operator -(const Point &amp;aa) const {\n        return (Point){x - aa.x, y - aa.y};\n    }\n    inline Point operator ^(const ld k) const {\n        return (Point){x * k, y * k};\n    }\n    inline Point xz() {\n        if (x &gt;= 0 &amp;&amp; y &gt;= 0)\n            return (Point){-y, x};\n        else if (x &lt; 0 &amp;&amp; y &gt; 0)\n            return (Point){-y, x};\n        else if (x &lt; 0 &amp;&amp; y &lt; 0)\n            return (Point){-y, x};\n        else\n            return (Point){-y, x};\n    }\n    inline ld len() {\n        return sqrt(x * x + y * y);\n    }\n};\n\ninline bool same(ld x, ld y) { //\u5224\u65ad\u76f8\u7b49\n    if (fabs(x - y) &lt; eps) return 1;\n    return 0;\n}\ninline bool cmp2(Point x, Point y) { //\u6781\u89d2\u6392\u5e8f\n    if (same(x / y, 0)) {\n        return x.len() &lt; y.len();\n    }\n    return x / y &gt; 0;\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_103","title":"\u4e8c\u7ef4\u51f8\u5305","text":"<pre><code>int st[MaxN], top;\nvector&lt;Point&gt; tubao(vector&lt;Point&gt; a) {\n    vector&lt;Point&gt; b;\n    if (a.size() == 0) return b;\n    for (int i = 0; i &lt; (int)a.size(); i++) {\n        used[i] = 0;\n    }\n    sort(a.begin(), a.end());\n    top = 0;\n    st[++top] = 0;\n    for (int i = 1; i &lt; (int)a.size(); i++) {\n        while (top &gt;= 2 &amp;&amp; (a[st[top]] - a[st[top - 1]]) / (a[i] - a[st[top]]) &lt;= 0) {\n            used[st[top--]] = 0;\n        }\n        used[i] = 1;\n        st[++top] = i;\n    }\n    int tmp = top;\n    for (int i = a.size() - 2; i &gt;= 0; i--) {\n        if (!used[i]) {\n            while (top &gt; tmp &amp;&amp; (a[st[top]] - a[st[top - 1]]) / (a[i] - a[st[top]]) &lt;= 0) {\n                used[st[top--]] = 0;\n            }\n            used[i] = 1;\n            st[++top] = i;\n        }\n    }\n    for (int i = 1; i &lt;= top; i++) {\n        b.push_back(a[st[i]]);\n    }\n    return b;\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_104","title":"\u4e24\u76f4\u7ebf\u4ea4\u70b9","text":"<pre><code>Point add1(Point a1, Point a2, Point b1, Point b2) {\n    Point t1 = a2 - a1;\n    Point t2 = b2 - b1;\n    Point t3 = b1 - a1;\n    if (fabs(t2 / t1) &lt; esp) return (Point){ -1e9 , -1e9 };\n    ld t = (t2 / t3) / (t2 / t1);\n    t = max(t, -t);\n    return a1 + (t1 ^ t);\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_105","title":"\u5224\u65ad\u5728\u51f8\u5305\u5185","text":"<pre><code>int in(Point x) {\n    if (x / A[2] &gt; 0 || A[tot] / x &gt; 0) return 0;\n    int ps = lower_bound(A + 1, A + 1 + tot, x, cmp2) - (A + 1);\n    if (same((x - A[ps]) / (A[ps % tot + 1] - A[ps]), 0) &amp;&amp; ps == tot) {\n        return x.len() &lt;= A[ps].len();\n    }\n    return (x - A[ps]) / (A[ps % tot + 1] - A[ps]) &lt;= 0;\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_106","title":"\u591a\u8fb9\u5f62\u9762\u79ef","text":"<pre><code>ld CalaS() {\n    ld res = 0;\n    for (int i = 3; i &lt;= top; i++) {\n        res += (a[i - 1]  - a[1]) / (a[i] - a[1]);\n    }\n    return res / 2;\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_107","title":"\u5224\u65ad\u5706\u548c\u7ebf\u6bb5\u6709\u51e0\u4e2a\u4ea4\u70b9","text":"<pre><code>inline int check(Point x) { // 1 out\n    ld len = (x - a[0]).len();\n    if (same(len, K)) return 0;\n    if (len &gt; K) return 1;\n    if (len &lt; K) return -1;\n    return 0;\n}\ninline int js(Point x, Point y) { //a[0] \u662f\u5706\u7684\u5750\u6807\uff0c K\u662f\u534a\u5f84\n    ld dis = (a[0] - x) / (a[0] - y);\n    dis = fabs(dis);\n    dis /= (x - y).len();\n    ld t1 = pd(x, y, a[0]);\n    ld t2 = pd(y, x, a[0]);\n    if (same(dis, K)) {\n        if (t1 &lt; 0 || t2 &lt; 0) {\n            return 0;\n        }\n        return 1;\n    }\n    if (dis &gt; K) return 0;\n    if (check(x) == -1 &amp;&amp; check(y) == -1) return 0;\n    if (check(x) &gt;= 0 &amp;&amp; check(y) &gt;= 0) {\n        if (t1 &lt; 0 || t2 &lt; 0) return 0;\n        int ans = 2;\n        if (same((x - a[0]).len(), K) == 1) ans--;\n        if (same((y - a[0]).len(), K) == 1) ans--;\n        return ans;\n    }\n    if (check(x) == 0 || check(y) == 0) return 0;\n    return 1;\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_108","title":"\u534a\u5e73\u9762\u4ea4","text":"<pre><code>Point add1(Point a1, Point a2, Point b1, Point b2) {\n    Point t1 = a2 - a1;\n    Point t2 = b2 - b1;\n    Point t3 = b1 - a1;\n    ld t = (t2 / t3) / (t2 / t1);\n    t = max(t, - t);\n    t1.x *= t;\n    t1.y *= t;\n    return a1 + t1;\n}\nvoid cut(Point x, Point y) {\n    a[top + 1] = a[1];\n    tot = 0;\n    for (int i = 1; i &lt;= top; i++) {\n        ld v1 = (a[i] - x) / (a[i] - y);\n        ld v2 = (a[i + 1] - x) / (a[i + 1] - y);\n        if (v1 &gt;= 0) {\n            c[++tot] = a[i];\n        }\n        if (v1 * v2 &lt; 0) {\n            c[++tot] = add1(a[i], a[i + 1], x, y);\n        }\n    }\n    for (int i = 1; i &lt;= tot; i++) {\n        a[i] = c[i];\n    }\n    top = tot;\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_109","title":"\u65cb\u8f6c\u5361\u58f3","text":"<pre><code>double js(int x, int y, int z) {\n    return (a[y] - a[x]) / (a[z] - a[x]);\n}\ndouble dj(int x, int y, int z) {\n    return (a[y] - a[x]) * (a[z] - a[x]);\n}\nsigned() {\n    int j = 3, l = 2, r = 2;\n    double t1 = 0, t2 = 0, t3 = 0, ans = 1e18;\n    point b[4];\n    for (int i = 1; i &lt; top; i++) {\n        while (js(st[i], st[i + 1], st[j]) &lt;= js (st[i], st[i + 1], st[j % top + 1])) {\n            j = j % top + 1;\n        }\n        while (dj(st[i], st[i + 1], st[r]) &lt;= dj(st[i], st[i + 1], st[r % top + 1])) {\n            r = r % top + 1;\n        }\n        if (i == 1) {\n            l = r;\n        }\n        while (dj(st[i], st[i + 1], st[l]) &gt;= dj(st[i], st[i + 1], st[l % top + 1])) {\n            l = l % top + 1;\n        }\n        t1 = js(st[i], st[i + 1], st[j]);\n        t2 = abs((a[st[r]] - a[st[i]]) * (a[st[i + 1]] - a[st[i]])) + \n             abs((a[st[l]] - a[st[i + 1]]) * (a[st[i]] - a[st[i + 1]])) -\n             abs((a[st[i + 1]] - a[st[i]]) * (a[st[i]] - a[st[i + 1]]));\n        t3 = abs((a[st[i + 1]] - a[st[i]]) * (a[st[i]] - a[st[i + 1]]));\n        // cout &lt;&lt; t1 &lt;&lt; ' ';\n        // cout &lt;&lt; t2 &lt;&lt; ' ';\n        // cout &lt;&lt; t3 &lt;&lt; endl;\n        if (ans &gt; t1 * t2 / t3) {\n            ans = min(ans, t1 * t2 / t3);\n            point mm = a[st[i + 1]] - a[st[i]];\n            point m1 = mm;\n            double h = t1 / mm.len();\n            double ch = ans / h;\n            m1.x *= dj(st[i], st[i + 1], st[r]) / (a[st[i + 1]] - a[st[i]]).len() / (a[st[i + 1]] - a[st[i]]).len();\n            m1.y *= dj(st[i], st[i + 1], st[r]) / (a[st[i + 1]] - a[st[i]]).len() / (a[st[i + 1]] - a[st[i]]).len();\n            b[1] = a[st[i]] + m1;\n\n            mm = mm.xz();\n            m1 = mm;\n            m1.x *= h / mm.len();\n            m1.y *= h / mm.len();\n            b[2] = b[1] + m1;\n\n            mm = mm.xz();\n            m1 = mm;\n            m1.x *= ch / mm.len();\n            m1.y *= ch / mm.len();\n            b[3] = b[2] + m1;\n\n            mm = mm.xz();\n            m1 = mm;\n            m1.x *= h / mm.len();\n            m1.y *= h / mm.len();\n            b[0] = b[3] + m1;\n\n            ans = min(ans, t1 * t2 / t3);\n        }\n    }\n    int id = 0, maxn1 = 1e18;\n    printf(\"%.5lf\\n\", ans);\n    for (int i = 0; i &lt; 4; i++) {\n        b[i].x += eps;\n        b[i].y += eps;\n        if (b[i].y &lt; maxn1) {\n            id = i;\n            maxn1 = b[i].y;\n        }\n    }\n    int nowsum = 0;\n    for (int i = id; i &lt; 4; i = (i + 1) % 4) {\n        nowsum++;\n        if (nowsum == 5) break;\n        printf(\"%.5lf %.5lf\\n\", b[i].x, b[i].y);\n    }\n}\n</code></pre>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#_110","title":"\u95f5\u53ef\u592b\u65af\u57fa\u548c","text":"<pre><code>vector&lt;Point&gt; Minkowski(vector&lt;Point&gt; t1, vector&lt;Point&gt; t2) {\n    vector&lt;Point&gt; A;\n    if (t1.size() == 0 || t2.size() == 0) return A;\n    for (int i = 1; i &lt; (int)t1.size(); i++) s1[i] = t1[i] - t1[i - 1];\n    for (int i = 1; i &lt; (int)t2.size(); i++) s2[i] = t2[i] - t2[i - 1];\n    A.push_back(t1[0] + t2[0]);\n    int p1 = 1, p2 = 1, tot = 0;\n    while(p1 &lt; (int) t1.size() &amp;&amp; p2 &lt; (int) t2.size()) {\n        A.push_back((Point){0, 0});\n        tot++;\n        A[tot] = A[tot - 1] + (s1[p1] / s2[p2] &gt;= 0? s1[p1++] : s2[p2++]);\n    }\n    while (p1 &lt; (int) t1.size()) {\n        A.push_back((Point){0, 0});\n        tot++;\n        A[tot] = A[tot - 1] + s1[p1++];\n    }\n    while (p2 &lt; (int)t2.size()) {\n        A.push_back((Point){0, 0});\n        tot++;\n        A[tot] = A[tot - 1] + s2[p2++];\n    }\n    return A;\n}\n</code></pre> <p>```cpp</p>"},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#include","title":"include  <p>using namespace std;</p> <p>using ll = long long; using vi = vector; using pii = pair;","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#define-endl-n","title":"define endl '\\n'","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#define-allx-xbegin-xend","title":"define all(x) (x).begin(), (x).end()","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#define-uniquex-xeraseuniqueallx-xend","title":"define UNIQUE(x) (x).erase(unique(all(x)), (x).end())","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#define-repit-ff-ee-for-int-it-ff-it-ee-it","title":"define rep(it, ff, ee) for (int it = (ff); it &lt;= (ee); ++it)","text":""},{"location":"OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/#define-perit-ff-ee-for-int-it-ff-it-ee-it","title":"define per(it, ff, ee) for (int it = (ff); it &gt;= (ee); --it) <p>int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);     cout.tie(nullptr);</p> <pre><code>int T;\ncin &gt;&gt; T;\nwhile (T--) {\n    ll x, m;\n    cin &gt;&gt; x &gt;&gt; m;\n\n    ll k = 1;\n    while (k &lt;= x) k &lt;&lt;= 1;\n\n    ll ans = 0;\n    if (m &lt;= k) {\n        rep (y, 1, m) {\n            ll p = x ^ y;\n            if (p != 0 &amp;&amp; (x % p == 0 || y % p == 0)) ++ans;\n        }\n        cout &lt;&lt; ans &lt;&lt; endl;\n        continue;\n    }\n\n    ll y_ = k;\n    while (--y_) {\n        ll p = x ^ y_;\n        if (p != 0 &amp;&amp; (x % p == 0 || y_ % p == 0)) ++ans;\n    }\n\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\n\nreturn 0;\n</code></pre> <p>}</p>","text":""},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E9%80%92%E5%BD%92%E5%8F%8A%E9%80%92%E6%8E%A8/","title":"\u9012\u5f52","text":"","tags":["\u5b66\u4e60\u7b14\u8bb0","CSP-J\u7ec4\u77e5\u8bc6","\u57fa\u7840"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E9%80%92%E5%BD%92%E5%8F%8A%E9%80%92%E6%8E%A8/#_2","title":"\u6982\u5ff5","text":"<p>\u9012\u5f52\uff0c\u5728\u6570\u5b66\u548c\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u662f\u6307\u5728\u51fd\u6570\u7684\u5b9a\u4e49\u4e2d\u4f7f\u7528\u51fd\u6570\u81ea\u8eab\u7684\u65b9\u6cd5\uff0c\u5728\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u8fd8\u989d\u5916\u6307\u4e00\u79cd\u901a\u8fc7\u91cd\u590d\u5c06\u95ee\u9898\u5206\u89e3\u4e3a\u540c\u7c7b\u7684\u5b50\u95ee\u9898\u800c\u89e3\u51b3\u95ee\u9898\u7684\u65b9\u6cd5\u3002</p>","tags":["\u5b66\u4e60\u7b14\u8bb0","CSP-J\u7ec4\u77e5\u8bc6","\u57fa\u7840"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E9%80%92%E5%BD%92%E5%8F%8A%E9%80%92%E6%8E%A8/#_3","title":"\u672c\u8d28","text":"<p>\u9012\u5f52\u7684\u5b9e\u8d28\u5c31\u662f\u76f4\u63a5\u6216\u95f4\u63a5\u8c03\u7528\u81ea\u8eab\u51fd\u6570\uff0c\u5c06\u539f\u95ee\u9898\u8f6c\u5316\u4e3a\u6027\u8d28\u76f8\u540c\u89c4\u6a21\u4e0d\u540c\u7684\u5b50\u95ee\u9898\u3002</p> <p>\u9012\u5f52\u4ee3\u7801\u6700\u91cd\u8981\u7684\u4e24\u4e2a\u7279\u5f81\uff1a\u7ed3\u675f\u6761\u4ef6\u548c\u81ea\u6211\u8c03\u7528\u3002\u81ea\u6211\u8c03\u7528\u662f\u5728\u89e3\u51b3\u5b50\u95ee\u9898\uff0c\u800c\u7ed3\u675f\u6761\u4ef6\u5b9a\u4e49\u4e86\u6700\u7b80\u5b50\u95ee\u9898\u7684\u7b54\u6848\u3002</p>","tags":["\u5b66\u4e60\u7b14\u8bb0","CSP-J\u7ec4\u77e5\u8bc6","\u57fa\u7840"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E9%80%92%E5%BD%92%E5%8F%8A%E9%80%92%E6%8E%A8/#_4","title":"\u4e3b\u8981\u683c\u5f0f","text":"<pre><code>int func(\u4f20\u5165\u6570\u503c) {\n  if (\u7ec8\u6b62\u6761\u4ef6) return \u6700\u5c0f\u5b50\u95ee\u9898\u89e3;\n  return func(\u7f29\u5c0f\u89c4\u6a21);\n}\n</code></pre>","tags":["\u5b66\u4e60\u7b14\u8bb0","CSP-J\u7ec4\u77e5\u8bc6","\u57fa\u7840"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E9%80%92%E5%BD%92%E5%8F%8A%E9%80%92%E6%8E%A8/#_5","title":"\u8981\u70b9","text":"","tags":["\u5b66\u4e60\u7b14\u8bb0","CSP-J\u7ec4\u77e5\u8bc6","\u57fa\u7840"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E9%80%92%E5%BD%92%E5%8F%8A%E9%80%92%E6%8E%A8/#_6","title":"\u4ec0\u4e48\u60c5\u51b5\u5e94\u8be5\u4f7f\u7528\u9012\u5f52\uff1f","text":"<p>\u5f53\u95ee\u9898\u53ef\u4ee5\u88ab\u5206\u89e3\u4e3a\u6210\u76f8\u540c\u7ed3\u6784\u7684\u5c0f\u95ee\u9898\u65f6\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u4f7f\u7528\u9012\u5f52\u6765\u6c42\u89e3\u3002</p>","tags":["\u5b66\u4e60\u7b14\u8bb0","CSP-J\u7ec4\u77e5\u8bc6","\u57fa\u7840"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E9%80%92%E5%BD%92%E5%8F%8A%E9%80%92%E6%8E%A8/#_7","title":"\u7f3a\u70b9","text":"<p>1.\u5bb9\u6613\u6808\u6ea2\u51fa</p> <p>2.\u53ef\u80fd\u4f1a\u8d85\u65f6\uff0c\u8017\u65f6\u95f4\uff0c\u9700\u8981\u4f18\u5316\u3002</p>","tags":["\u5b66\u4e60\u7b14\u8bb0","CSP-J\u7ec4\u77e5\u8bc6","\u57fa\u7840"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E9%80%92%E5%BD%92%E5%8F%8A%E9%80%92%E6%8E%A8/#_8","title":"\u6ce8\u610f","text":"<p>\u5199\u9012\u5f52\u7a0b\u5e8f\u65f6\uff0c\u660e\u767d\u4e00\u4e2a\u51fd\u6570\u7684\u4f5c\u7528\u5e76\u76f8\u4fe1\u5b83\u80fd\u5b8c\u6210\u8fd9\u4e2a\u4efb\u52a1\uff0c\u5343\u4e07\u4e0d\u8981\u8df3\u8fdb\u8fd9\u4e2a\u51fd\u6570\u91cc\u9762\u4f01\u56fe\u63a2\u7a76\u66f4\u591a\u7ec6\u8282\u3002\u5426\u5219\u53ef\u80fd\u9677\u5165\u65e0\u9650\u7684\u7ec6\u8282\u4e2d\u65e0\u6cd5\u81ea\u62d4\uff08\u5f15\u7528\u81eaOi Wiki\uff09</p>","tags":["\u5b66\u4e60\u7b14\u8bb0","CSP-J\u7ec4\u77e5\u8bc6","\u57fa\u7840"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E9%80%92%E5%BD%92%E5%8F%8A%E9%80%92%E6%8E%A8/#_9","title":"\u5206\u6cbb","text":"","tags":["\u5b66\u4e60\u7b14\u8bb0","CSP-J\u7ec4\u77e5\u8bc6","\u57fa\u7840"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E9%80%92%E5%BD%92%E5%8F%8A%E9%80%92%E6%8E%A8/#_10","title":"\u6982\u5ff5","text":"<p>\u5206\u6cbb\uff08\u82f1\u8bed\uff1aDivide and Conquer\uff09\uff0c\u5b57\u9762\u4e0a\u7684\u89e3\u91ca\u662f\u300c\u5206\u800c\u6cbb\u4e4b\u300d\uff0c\u5c31\u662f\u628a\u4e00\u4e2a\u590d\u6742\u7684\u95ee\u9898\u5206\u6210\u4e24\u4e2a\u6216\u66f4\u591a\u7684\u76f8\u540c\u6216\u76f8\u4f3c\u7684\u5b50\u95ee\u9898\uff0c\u76f4\u5230\u6700\u540e\u5b50\u95ee\u9898\u53ef\u4ee5\u7b80\u5355\u7684\u76f4\u63a5\u6c42\u89e3\uff0c\u539f\u95ee\u9898\u7684\u89e3\u5373\u5b50\u95ee\u9898\u7684\u89e3\u7684\u5408\u5e76\u3002</p>","tags":["\u5b66\u4e60\u7b14\u8bb0","CSP-J\u7ec4\u77e5\u8bc6","\u57fa\u7840"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E9%80%92%E5%BD%92%E5%8F%8A%E9%80%92%E6%8E%A8/#_11","title":"\u8fc7\u7a0b","text":"<p>\u6838\u5fc3\u601d\u60f3\uff1a\u300c\u5206\u800c\u6cbb\u4e4b\u300d \u5927\u81f4\u5206\u4e3a\u4e09\u6b65\uff1a\u5206\u89e3 -&gt; \u89e3\u51b3 -&gt; \u5408\u5e76\u3002</p> <ol> <li>\u5206\u89e3\u539f\u95ee\u9898\u4e3a\u7ed3\u6784\u76f8\u540c\u7684\u5b50\u95ee\u9898\u3002</li> <li>\u5206\u89e3\u539f\u95ee\u9898\u4e3a\u7ed3\u6784\u76f8\u540c\u7684\u5b50\u95ee\u9898\u3002</li> <li>\u5c06\u5b50\u95ee\u9898\u7684\u89e3\u5408\u5e76\u6210\u539f\u95ee\u9898\u7684\u89e3\u3002</li> </ol>","tags":["\u5b66\u4e60\u7b14\u8bb0","CSP-J\u7ec4\u77e5\u8bc6","\u57fa\u7840"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E9%80%92%E5%BD%92%E5%8F%8A%E9%80%92%E6%8E%A8/#_12","title":"\u7279\u5f81","text":"<ul> <li>\u5206\u89e3\u539f\u95ee\u9898\u4e3a\u7ed3\u6784\u76f8\u540c\u7684\u5b50\u95ee\u9898\u3002</li> <li>\u8be5\u95ee\u9898\u53ef\u4ee5\u5206\u89e3\u4e3a\u82e5\u5e72\u4e2a\u89c4\u6a21\u8f83\u5c0f\u7684\u76f8\u540c\u95ee\u9898\uff0c\u5373\u8be5\u95ee\u9898\u5177\u6709\u6700\u4f18\u5b50\u7ed3\u6784\u6027\u8d28\uff0c\u5229\u7528\u8be5\u95ee\u9898\u5206\u89e3\u51fa\u7684\u5b50\u95ee\u9898\u7684\u89e3\u53ef\u4ee5\u5408\u5e76\u4e3a\u8be5\u95ee\u9898\u7684\u89e3\u3002</li> <li>\u8be5\u95ee\u9898\u6240\u5206\u89e3\u51fa\u7684\u5404\u4e2a\u5b50\u95ee\u9898\u662f\u76f8\u4e92\u72ec\u7acb\u7684\uff0c\u5373\u5b50\u95ee\u9898\u4e4b\u95f4\u4e0d\u5305\u542b\u516c\u5171\u7684\u5b50\u95ee\u9898\u3002   \u6ce8\u610f \u5982\u679c\u5b50\u95ee\u9898\u4e0d\u72ec\u7acb\uff0c\u5206\u6cbb\u6cd5\u8981\u91cd\u590d\u591a\u6b21\u6765\u6c42\u89e3\u516c\u5171\u7684\u5b50\u95ee\u9898\uff0c\u505a\u4e86\u8bb8\u591a\u4e0d\u5fc5\u8981\u7684\u5de5\u4f5c\uff0c\u8fd9\u79cd\u60c5\u51b5\u4e00\u822c\u4f7f\u7528\u52a8\u6001\u89c4\u5212\uff08\u8fd9\u91cc\u5e94\u8be5\u6709\u4e2a\u94fe\u63a5\uff09\u8f83\u597d\u3002</li> </ul>","tags":["\u5b66\u4e60\u7b14\u8bb0","CSP-J\u7ec4\u77e5\u8bc6","\u57fa\u7840"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E9%80%92%E5%BD%92%E5%8F%8A%E9%80%92%E6%8E%A8/#_13","title":"\u533a\u522b","text":"<p>\u9012\u5f52\u548c\u679a\u4e3e\u7684\u533a\u522b\u5728\u4e8e\uff1a\u679a\u4e3e\u662f\u6a2a\u5411\u5730\u628a\u95ee\u9898\u5212\u5206\uff0c\u7136\u540e\u4f9d\u6b21\u6c42\u89e3\u5b50\u95ee\u9898\uff1b\u800c\u9012\u5f52\u662f\u628a\u95ee\u9898\u9010\u7ea7\u5206\u89e3\uff0c\u662f\u7eb5\u5411\u7684\u62c6\u5206\u3002</p>","tags":["\u5b66\u4e60\u7b14\u8bb0","CSP-J\u7ec4\u77e5\u8bc6","\u57fa\u7840"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E9%80%92%E5%BD%92%E5%8F%8A%E9%80%92%E6%8E%A8/#_14","title":"\u9012\u5f52\u4e0e\u5206\u6cbb\u7684\u533a\u522b","text":"<p>\u9012\u5f52\u662f\u4e00\u79cd\u7f16\u7a0b\u6280\u5de7\uff0c\u4e00\u79cd\u89e3\u51b3\u95ee\u9898\u7684\u601d\u7ef4\u65b9\u5f0f\uff1b\u5206\u6cbb\u7b97\u6cd5\u5f88\u5927\u7a0b\u5ea6\u4e0a\u662f\u57fa\u4e8e\u9012\u5f52\u7684\uff0c\u89e3\u51b3\u66f4\u5177\u4f53\u95ee\u9898\u7684\u7b97\u6cd5\u601d\u60f3\u3002</p>","tags":["\u5b66\u4e60\u7b14\u8bb0","CSP-J\u7ec4\u77e5\u8bc6","\u57fa\u7840"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E9%80%92%E5%BD%92%E5%8F%8A%E9%80%92%E6%8E%A8/#_15","title":"\u4e60\u9898","text":"<ul> <li>P1028 \u6570\u7684\u8ba1\u7b97</li> </ul> <ul> <li>P1036 \u9009\u6570</li> </ul> <ul> <li>P1025 \u6570\u7684\u5212\u5206</li> </ul>","tags":["\u5b66\u4e60\u7b14\u8bb0","CSP-J\u7ec4\u77e5\u8bc6","\u57fa\u7840"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-DFS-BFS%E7%AE%97%E6%B3%95/","title":"\u641c\u7d22","text":"<p>\u641c\u7d22\u5c31\u662f\u5bf9\u72b6\u6001\u7a7a\u95f4\u8fdb\u884c\u679a\u4e3e\u6765\u67e5\u627e\u6240\u6709\u79cd\u53ef\u80fd\u6765\u627e\u5230\u95ee\u9898\u7684\u6700\u4f18\u89e3\u6216\u53ef\u884c\u89e3\u7684\u4e2a\u6570\u3002\u641c\u7d22\u4e00\u822c\u65f6\u95f4\u6216\u7a7a\u95f4\u590d\u6742\u5ea6\u5f88\u9ad8\uff0c\u6240\u4ee5\u6709\u5f88\u591a\u4f18\u5316\u65b9\u6cd5,\u5982\u8bb0\u5fc6\u5316\u3001\u51cf\u679d\u7b49\u3002</p>","tags":["\u641c\u7d22","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-DFS-BFS%E7%AE%97%E6%B3%95/#_2","title":"\u6ce8\u610f","text":"<p>\u4e0d\u540c\u7684\u641c\u7d22\u9898\u76ee\u5927\u90fd\u4e0d\u76f8\u540c\uff0cDFS/BFS\u4e24\u79cd\u7b97\u6cd5\u66f4\u50cf\u662f\u65b9\u6cd5\uff0c\u8981\u7406\u89e3\u5b83\u7684\u601d\u60f3\u5e76\u7075\u6d3b\u8fd0\u7528\uff0c\u6b7b\u5957\u6a21\u677f\u662f\u6ca1\u6709\u7528\u7684\u3002\u8981\u6839\u636e\u4e0d\u540c\u7684\u95ee\u9898\u6765\u9009\u62e9\u66f4\u597d\u7684\u65b9\u6cd5\u6765\u89e3\u51b3\u3002</p>","tags":["\u641c\u7d22","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-DFS-BFS%E7%AE%97%E6%B3%95/#dfs","title":"\u4e00.DFS \u6df1\u5ea6\u4f18\u5148\u641c\u7d22","text":"","tags":["\u641c\u7d22","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-DFS-BFS%E7%AE%97%E6%B3%95/#_3","title":"\u5b9a\u4e49","text":"<p>\u4e00\u79cd\u7528\u4e8e\u904d\u5386\u6216\u641c\u7d22\u6811\u6216\u56fe\u7684\u7b97\u6cd5\uff08\u4fd7\u79f0 ~~\u4e0d\u649e\u5357\u5899\u4e0d\u56de\u5934\u7b97\u6cd5~~ \uff09  \u3002 \u6cbf\u7740\u6811\u7684\u6df1\u5ea6\u904d\u5386\u6811\u7684\u8282\u70b9\uff0c\u5c3d\u53ef\u80fd\u6df1\u5730\u641c\u7d22\u6811\u7684\u5206\u652f\u3002\u5f53\u8282\u70b9v\u7684\u6240\u5728\u8fb9\u90fd\u5df1\u88ab\u63a2\u5bfb\u8fc7\u6216\u8005\u5728\u641c\u5bfb\u65f6\u7ed3\u70b9\u4e0d\u6ee1\u8db3\u6761\u4ef6\uff0c\u641c\u7d22\u5c06\u56de\u6eaf\u5230\u53d1\u73b0\u8282\u70b9v\u7684\u90a3\u6761\u8fb9\u7684\u8d77\u59cb\u8282\u70b9\u3002\u6574\u4e2a\u8fdb\u7a0b\u53cd\u590d\u8fdb\u884c\u76f4\u5230\u6240\u6709\u8282\u70b9\u90fd\u88ab\u8bbf\u95ee\u4e3a\u6b62\u3002\u5c5e\u4e8e\u76f2\u76ee\u641c\u7d22,\u6700\u7cdf\u7cd5\u7684\u60c5\u51b5\u7b97\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(!n)$\u3002</p>","tags":["\u641c\u7d22","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-DFS-BFS%E7%AE%97%E6%B3%95/#_4","title":"\u9002\u7528","text":"<p>\u4e3b\u8981\u7528\u4e8e\u641c\u7d22\u6574\u4e2a\u6811\u6216\u56fe\uff0c\u5373\u6c42\u89e3\u6240\u6709\u89e3\u4f7f\u7528dfs\u8f83\u4e3a\u5408\u9002\u3002 \u4f46\u662fdfs\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5f88\u9ad8\uff0c\u8d39\u65f6\uff0c\u7701\u7a7a\u95f4\u3002\u4e00\u822c\u53ef\u4ee5\u5bf9dfs\u7b97\u6cd5\u8fdb\u884c\u526a\u679d\u6765\u964d\u4f4e\u65f6\u95f4\u590d\u6742\u5ea6\u3002</p>","tags":["\u641c\u7d22","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-DFS-BFS%E7%AE%97%E6%B3%95/#_5","title":"\u57fa\u672c\u601d\u60f3","text":"<p>1.\u627e\u5230\u4e00\u79cd\u53ef\u80fd\u7684\u60c5\u51b5\u8fdb\u884c\u5411\u524d\u641c\u7d22\u3002</p> <p>2.\u5982\u679c\u641c\u7d22\u9014\u4e2d\u53d1\u73b0\u4e0d\u53ef\u884c\uff0c\u5219\u56de\u9000\u4e00\u6b65\uff0c\u9009\u62e9\u53e6\u5916\u4e00\u79cd\u60c5\u51b5\u7ee7\u7eed\u641c\u7d22\u3002</p> <p>3.\u91cd\u590d\u4ee5\u4e0a\u6b65\u9aa4\uff0c\u76f4\u5230\u641c\u5b8c\u6216\u627e\u5230\u6700\u4f18\u89e3\u3002</p>","tags":["\u641c\u7d22","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-DFS-BFS%E7%AE%97%E6%B3%95/#_6","title":"\u5b9e\u73b0","text":"<p>\u5bf9\u4e8eDFS\u7684\u5199\u6cd5\u6709\u5f88\u591a\u79cd\uff0c\u6700\u5e38\u89c1\u4e5f\u662f\u6700\u597d\u7528\u7684\u5b9e\u73b0\u65b9\u5f0f\u4e3a\u9012\u5f52\u7b97\u6cd5\u3002\uff08\u9012\u5f52\u76f8\u5173\u77e5\u8bc6link\uff09</p> <p>\u8be6\u7ec6\u5199\u6cd5\u770b\u6a21\u677f\u4ee3\u7801\u6ce8\u91ca\u3002</p>","tags":["\u641c\u7d22","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-DFS-BFS%E7%AE%97%E6%B3%95/#_7","title":"\u6a21\u677f","text":"<pre><code>bool visit[maxn];//\u6807\u8bb0\u6570\u7ec4\uff0c\u7528\u6765\u5224\u65ad\u662f\u5426\u8bbf\u95ee\u8fc7\nint a[maxn];\n\nvoid dfs(int k) {\n    if () {//\u9012\u5f52\u51fa\u53e3\n        print();//\u5df2\u7ecf\u8dd1\u5b8c\u90a3\u5c31\u8f93\u51fa\u5427(^_^)\n        return;//\u8bb0\u5f97\u7ed3\u675f\u5faa\u73af\uff0c\u5c0f\u5fc3\u6b7b\u5faa\u73af\n    } else {\n        for (i in range(n)) {//\u904d\u5386\u5728\u8fd9\u4e2a\u4f4d\u7f6e\u53ef\u4ee5\u641c\u7d22\u7684\u6240\u6709\u60c5\u51b5\n            if (!visit[i]) {//\u5224\u65ad\u662f\u5426\u5df2\u7ecf\u8bbf\u95ee\u8fc7\uff0c\u5982\u679c\u7c7b\u4f3c\u8ff7\u5bab\u7684\u9898\u76ee\u5efa\u8bae\u5355\u72ec\u5199\u4e00\u4e2acheck\n                visit[i] = 1;//\u5148\u628a\u5f53\u524d\u70b9\u6807\u8bb0\n                a[k + 1] = i;\n                dfs(k + 1);//\u641c\u7d22\u4e0b\u4e00\u79cd\u60c5\u51b5\n                visit[i] = 0;//\u56de\u6eaf\u540e\u6e05\u9664\u6807\u8bb0\uff08\u5982\u679c\u4e0d\u9700\u8981\u56de\u6eaf\u53ef\u4ee5\u4e0d\u5199\uff09\n            }\n        }\n    }\n}\n\n</code></pre>","tags":["\u641c\u7d22","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-DFS-BFS%E7%AE%97%E6%B3%95/#bfs","title":"\u4e8c.BFS\u5bbd\u5ea6\u4f18\u5148\u641c\u7d22","text":"","tags":["\u641c\u7d22","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-DFS-BFS%E7%AE%97%E6%B3%95/#_8","title":"\u5b9a\u4e49","text":"<p>\u662f\u56fe\u4e0a\u6700\u57fa\u7840\u3001\u6700\u91cd\u8981\u7684\u641c\u7d22\u7b97\u6cd5\u4e4b\u4e00\u3002</p> <p>\u6240\u8c13\u5bbd\u5ea6\u4f18\u5148\u3002\u5c31\u662f\u6bcf\u6b21\u90fd\u5c1d\u8bd5\u8bbf\u95ee\u540c\u4e00\u5c42\u7684\u8282\u70b9\u3002 \u5982\u679c\u540c\u4e00\u5c42\u90fd\u8bbf\u95ee\u5b8c\u4e86\uff0c\u518d\u8bbf\u95ee\u4e0b\u4e00\u5c42\u3002</p> <p>\u8fd9\u6837\u505a\u7684\u7ed3\u679c\u662f\uff0cBFS \u7b97\u6cd5\u627e\u5230\u7684\u8def\u5f84\u662f\u4ece\u8d77\u70b9\u5f00\u59cb\u7684 \u6700\u77ed \u5408\u6cd5\u8def\u5f84\u3002\u6362\u8a00\u4e4b\uff0c\u8fd9\u6761\u8def\u5f84\u6240\u5305\u542b\u7684\u8fb9\u6570\u6700\u5c0f\u3002</p> <p>\u5728 BFS \u7ed3\u675f\u65f6\uff0c\u6bcf\u4e2a\u8282\u70b9\u90fd\u662f\u901a\u8fc7\u4ece\u8d77\u70b9\u5230\u8be5\u70b9\u7684\u6700\u77ed\u8def\u5f84\u8bbf\u95ee\u7684\u3002</p>","tags":["\u641c\u7d22","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-DFS-BFS%E7%AE%97%E6%B3%95/#_9","title":"\u57fa\u672c\u601d\u60f3","text":"<p>\u7528\u961f\u5217\u6765\u5b58\u50a8\u6bcf\u4e00\u4e2a\u70b9\uff0c\u7136\u540e\u6bcf\u4e2a\u70b9\u90fd\u5411\u4e0b\u6269\u5c55$N$\u4e2a\u70b9\uff0c\u4e0d\u65ad\u641c\u7d22\uff0c\u76f4\u5230\u627e\u5230\u7b54\u6848\u3002\u8fd9\u4e2a\u8fc7\u7a0b\u6709\u70b9\u50cf\"\u4e00\u751f\u4e8c\uff0c\u4e8c\u751f\u56db\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\"\u3002 \u4f7f\u7528\u8fd9\u79cd\u65b9\u6cd5\u53ef\u4ee5\u5f88\u5feb\u627e\u5230\u6700\u77ed\u7684\u5408\u6cd5\u8def\u5f84\u3002 \u8fd9\u79cd\u65b9\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u8f83\u4f4e\uff0c\u4f46\u662f\uff0cbfs\u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u76f8\u8f83\u6765\u8bf4\u8f83\u9ad8\u3002</p>","tags":["\u641c\u7d22","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-DFS-BFS%E7%AE%97%E6%B3%95/#code","title":"Code","text":"<pre><code>void bfs() {\n    queue&lt;int&gt; q1, q2;\n    q1.push(1);\n    q2.push(1);\n    sum[1][1] = 1;\n    while (!q1.empty()) {\n        int x = q1.front();\n        q1.pop();\n        int y = q2.front();\n        q2.pop();\n        vis[x][y] = 1;\n        for (int i = 0; i &lt; 4; i++) {//\u904d\u5386\u56db\u4e2a\u65b9\u5411\n            if (check(x + dx[i], y + dy[i])) {//pd\n                sum[x + dx[i]][y + dy[i]] = sum[x][y] + 1;\n                q1.push(x + dx[i]);\n                q2.push(y + dy[i]);\n                vis[x + dx[i]][y + dy[i]] = 1;\n                if (x + dx[i] == R &amp;&amp; y + dy[i] == C) {//bfs\u51fa\u53e3\n                    return;\n                }\n            }\n        }\n    }\n}\n</code></pre>","tags":["\u641c\u7d22","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-DFS-BFS%E7%AE%97%E6%B3%95/#_10","title":"\u4f18\u5316","text":"<p>\u5728\u5e26\u6743\u6709\u5411\u56fe/\u5e26\u6743\u6811\u4e2d\uff0c\u6700\u5c0f\u4ee3\u4ef7\u4e0d\u4e00\u5b9a\u662f\u6700\u77ed\u7684\u8def\u5f84\u3002\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4f18\u5148\u961f\u5217/\u53cc\u7aef\u961f\u5217\u6765\u4f18\u5316\u3002</p>","tags":["\u641c\u7d22","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E4%BA%8C%E5%88%86/","title":"\u4e8c\u5206\u67e5\u627e","text":"<p>\u5177\u4f53\u601d\u8def\u4e3a\u6bcf\u6b21\u67e5\u627e\u65f6\uff0c\u5c06\u8303\u56f4\u6298\u534a\uff0c\u5224\u65ad\u67e5\u627e\u6570\u7684\u4f4d\u7f6e\u5e76\u5c06\u5176\u6298\u534a\uff0c\u91cd\u590d\u4ee5\u4e0a\u64cd\u4f5c\u5c31\u53ef\u5feb\u901f\u5f97\u51fa\u7b54\u6848\u3002\u6ce8\u610f\u64cd\u4f5c\u65f6\u5fc5\u987b\u4fdd\u8bc1\u6570\u7ec4\u662f\u6709\u5e8f\u7684\uff01\uff01</p>","tags":["\u4e8c\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E4%BA%8C%E5%88%86/#_2","title":"\u65f6\u95f4\u590d\u6742\u5ea6","text":"<p>\u4e8c\u5206\u7684\u6700\u574f\u590d\u6742\u5ea6\u4e3a $O(log N)$</p>","tags":["\u4e8c\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E4%BA%8C%E5%88%86/#_3","title":"\u5b9e\u73b0","text":"","tags":["\u4e8c\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E4%BA%8C%E5%88%86/#_4","title":"\u624b\u5199","text":"","tags":["\u4e8c\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E4%BA%8C%E5%88%86/#1","title":"\u6a21\u677f1","text":"<pre><code>//\u5f80\u5de6\u627e\u7b54\u6848\nwhile(l&lt;r){\n    int mid=l+r&gt;&gt;1;//(l+r)/2\n    if(check(mid)){\n        r=mid;\n    }\n    else{\n        l=mid+1;\n    }\n}\n</code></pre>","tags":["\u4e8c\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E4%BA%8C%E5%88%86/#2","title":"\u6a21\u677f2","text":"<pre><code>//\u5f80\u53f3\u627e\u7b54\u6848\nwhile(l&lt;r){\n    int mid=l+r+1&gt;&gt;1;//(l+r+1)/2\n    if(check(mid)){\n        l=mid;\n    }\n    else{\n        r=mid-1;\n    }\n}\n</code></pre>","tags":["\u4e8c\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E4%BA%8C%E5%88%86/#3","title":"\u6a21\u677f3\uff08\u6d6e\u70b9\uff09","text":"<pre><code>while(r-l&lt;1e-5){//\u6ce8\u610f\u6240\u6709\u7c7b\u578b\u90fd\u4e3adouble\n    double mid=(l+r)/2;\n    if(check(mid)){\n        l=mid;\n    }\n    else{\n        r=mid;\n    }\n}\n</code></pre>","tags":["\u4e8c\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E4%BA%8C%E5%88%86/#stl","title":"STL\u51fd\u6570","text":"<p>\u67e5\u627e\u9996\u4e2a\u4e0d\u5c0f\u4e8e\u7ed9\u5b9a\u503c\u7684\u5143\u7d20\uff1a<code>lower_bound</code>\uff1a</p> <p>\u4f7f\u7528\u65f6\u76f4\u63a5\u8c03\u7528<code>lower_bound( ForwardIt first, ForwardIt last, const T&amp; value );</code>\uff0c\u4f7f\u7528\u65f6\u5fc5\u987b\u4fdd\u8bc1\u6570\u7ec4\u6709\u5e8f\u3002</p> <p>\u5982\u679c\u6ca1\u6709\u627e\u5230\uff0c\u8fd4\u56de<code>last</code></p> <p>\u67e5\u627e\u9996\u4e2a\u5927\u4e8e\u7ed9\u5b9a\u503c\u7684\u5143\u7d20\uff1a <code>upper_bound</code>\uff1a</p> <p>\u4f7f\u7528\u65f6\u76f4\u63a5\u8c03\u7528<code>upper_bound( ForwardIt first, ForwardIt last, const T&amp; value );</code>\uff0c\u4f7f\u7528\u65f6\u5fc5\u987b\u4fdd\u8bc1\u6570\u7ec4\u6709\u5e8f\u3002</p> <p>\u5982\u679c\u6ca1\u6709\u627e\u5230\uff0c\u8fd4\u56de<code>last</code></p>","tags":["\u4e8c\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E4%BA%8C%E5%88%86/#_5","title":"\u4f8b\u9898","text":"<p>P2249</p> <p>P1102</p> <p>P1163//\u6d6e\u70b9\u4e8c\u5206</p>","tags":["\u4e8c\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E4%BA%8C%E5%88%86/#_6","title":"\u4e8c\u5206\u7b54\u6848","text":"<p>\u5728\u9898\u76ee\u7684\u7b54\u6848\u6709\u4e00\u4e2a\u5f88\u5927\u7684\u533a\u95f4\uff0c\u4e14\u4fdd\u8bc1\u8fd9\u4e2a\u533a\u95f4\u5bf9\u9898\u76ee\u4e2d\u7684\u67d0\u4e00\u4e2a\u91cf\u5177\u6709\u5355\u8c03\u6027\uff0c\u5c31\u53ef\u4ee5\u4f7f\u7528\u4e8c\u5206\u7b54\u6848\u6765\u89e3\u51b3\u95ee\u9898\u3002</p> <p>\u5f62\u5f0f\u5316\u7684\u6765\u8bf4\uff0c\u4e00\u9053\u9898\u76ee\u5982\u679c\u7b26\u5408\u4ee5\u4e0b\u6761\u4ef6\u5c31\u53ef\u4ee5\u4f7f\u7528\u4e8c\u5206\u7b54\u6848\u6765\u6c42\u89e3\u3002 - \u7b54\u6848\u5728\u4e00\u4e2a\u533a\u95f4\u3002 - \u76f4\u63a5\u641c\u7d22\u4e0d\u5bb9\u6613\uff0c\u4f46\u662f\u53ef\u4ee5\u5bb9\u6613\u5224\u65ad\u4e00\u4e2a\u7b54\u6848\u662f\u5426\u7b26\u5408\u6761\u4ef6\u3002 - \u8fd9\u4e2a\u533a\u95f4\u5177\u6709\u5355\u8c03\u6027\uff0c\u4f1a\u968f\u7740\u4e00\u4e2a\u6761\u4ef6\u7684\u6539\u53d8\u800c\u53d8\u5316\u3002 - \u53ef\u80fd\u4f1a\u6709\u6700\u5927\u503c\u6700\u5c0f\u5316\uff08\u6216\u8005\u6700\u5c0f\u503c\u6700\u5927\u5316\uff09\uff0c\u7b49\u5178\u578b\u7279\u5f81\u3002 - check()\u51fd\u6570\u8981\u5199\u6b63\u786e\uff0c\u4e00\u822c\u53ef\u4ee5\u7528\u7b54\u6848\u5e26\u8fdb\u53bb\u8bd5\u3002 - \u6ce8\u610f\u4e00\u4e9b\u7279\u6b8a\u7684\u60c5\u51b5\uff0c\u5199\u597d\u7279\u5224\u3002</p>","tags":["\u4e8c\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E4%BA%8C%E5%88%86/#_7","title":"\u4f8b\u9898","text":"<p>P1873</p> <p>P1024</p> <p>P2240</p> <p>P2678</p> <p>P1182</p> <p>P1824</p> <p>P3853</p> <p>P3743</p>","tags":["\u4e8c\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/","title":"\u524d\u7f00\u548c","text":"","tags":["\u524d\u7f00\u548c&\u5dee\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3","OI\u5b66\u4e60\u7b14\u8bb0"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/#_2","title":"\u5b9a\u4e49","text":"<p>\u5b9a\u4e49\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u4e00\u4e2a\u6570\u5217\u4e2d\u524dn\u9879\u7684\u548c\u3002\u867d\u7136\u7b80\u5355\uff0c\u5374\u662f\u4e00\u79cd\u975e\u5e38\u597d\u7528\u7684\u51cf\u5c11\u65f6\u95f4\u590d\u6742\u5ea6\u7684\u4f18\u5316\u65b9\u6cd5\u3002</p>","tags":["\u524d\u7f00\u548c&\u5dee\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3","OI\u5b66\u4e60\u7b14\u8bb0"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/#_3","title":"\u4e00\u7ef4","text":"","tags":["\u524d\u7f00\u548c&\u5dee\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3","OI\u5b66\u4e60\u7b14\u8bb0"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/#_4","title":"\u539f\u7406","text":"<p>$sum_r=a_1+a_2+......+a_r$</p> <p>$sum_{l-1}=a_1+a_2+......+a_{l-1}$</p> <p>$sum_r-sum_{l-1}=a_l+a_l+1+...a_r$</p>","tags":["\u524d\u7f00\u548c&\u5dee\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3","OI\u5b66\u4e60\u7b14\u8bb0"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/#_5","title":"\u5b9e\u73b0","text":"","tags":["\u524d\u7f00\u548c&\u5dee\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3","OI\u5b66\u4e60\u7b14\u8bb0"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/#_6","title":"\u5b9a\u4e49","text":"<pre><code>int sum[N];\nsum[0]=a[0];\nfor(int i=;i&lt;N;i++){\n    sum[i]=sum[i-1]+a[i];\n}\n</code></pre>","tags":["\u524d\u7f00\u548c&\u5dee\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3","OI\u5b66\u4e60\u7b14\u8bb0"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/#_7","title":"\u67e5\u8be2","text":"<pre><code>//l\u5230r\u533a\u95f4\u4e4b\u548c\ncout&lt;&lt;sum[r]-sum[l-1];\n</code></pre>","tags":["\u524d\u7f00\u548c&\u5dee\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3","OI\u5b66\u4e60\u7b14\u8bb0"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/#_8","title":"\u4e8c\u7ef4","text":"<p>\u901a\u8fc7\u56fe\u7247\u53ef\u77e5\uff0c<code>sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j]</code> </p> <p>\u4e0d\u96be\u63a8\u51fa\uff0c<code>s[x2, y2] - s[x1 - 1, y2] - s[x2, y1 - 1] + s[x1 - 1, y1 - 1]</code></p>","tags":["\u524d\u7f00\u548c&\u5dee\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3","OI\u5b66\u4e60\u7b14\u8bb0"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/#_9","title":"\u5dee\u5206","text":"<p>\u5dee\u5206\u53ef\u4ee5\u7406\u89e3\u4e3a\u524d\u7f00\u548c\u7684\u9006\u8fd0\u7b97\uff0c\u5373\u5982\u679c\u4e00\u4e2a\u6570\u7ec4a\u7684\u524d\u7f00\u548c\u6570\u7ec4\u4e3ab\uff0c\u5219\u6570\u7ec4a\u662f\u6570\u7ec4b\u7684\u5dee\u5206\u6570\u7ec4\u3002</p>","tags":["\u524d\u7f00\u548c&\u5dee\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3","OI\u5b66\u4e60\u7b14\u8bb0"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/#_10","title":"\u6784\u9020\u5dee\u5206","text":"<p>\u6700\u7b80\u5355\u7684\u6784\u9020\u65b9\u6cd5\uff1a</p> <pre><code>int a[n],[n];\nb[0]=a[0];\nfor(int i=1;i&lt;n;i++)\n{\n    b[i]=a[i]-a[i-1];\n}\n</code></pre>","tags":["\u524d\u7f00\u548c&\u5dee\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3","OI\u5b66\u4e60\u7b14\u8bb0"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/#_11","title":"\u4e00\u7ef4","text":"<p>\u4e00\u7ef4\u5dee\u5206\u662f\u6307\u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e3an\u7684\u5e8f\u5217a\uff0c\u8981\u6c42\u652f\u6301\u64cd\u4f5cfuc(l,r,c)\u8868\u793a\u5bf9a[l]~a[r]\u533a\u95f4\u4e0a\u7684\u6bcf\u4e00\u4e2a\u503c\u90fd\u52a0\u4e0a\u6216\u51cf\u53bb\u5e38\u6570c\uff0c\u5e76\u6c42\u4fee\u6539\u540e\u7684\u5e8f\u5217a\u3002</p> <pre><code>//\u533a\u95f4[l,r]\u4e2d\u7684\u6240\u6709\u503c\u90fd\u52a0\u4e0a\u5e38\u6570c\nb[l] += c;\nb[r+1] -= c;\n\n//\u4e0a\u8fb9\u8bed\u53e5\u5b9e\u73b0\u539f\u7406 b\u76f8\u5f53\u4e8ea\u7684\u8f85\u52a9\u6570\u7ec4\n//\u628aa\u5e8f\u5217\u5206\u4e3a[1,l-1],[l,r],[r+1,n]\u4e09\u90e8\u5206,\u7531\u5dee\u5206\u5b9a\u4e49\u548c\u4e0e\u524d\u7f00\u548c\u5173\u7cfb\u53ef\u5f97\na[l-1] = b[1]+b[2]+...+b[l-1]; //b[1]~b[l-1]\u4e2d\u6240\u6709\u503c\u90fd\u672a\u6539\u53d8\uff0ca[l-1]\u4e5f\u4e0d\u53d8\na[l] = b[1]+b[2]+...+b[l-1]+b[l]; //b[1] += c,\u6240\u4ee5a[l] += c\na[l+1] = b[1]+b[2]+...+b[l-1]+b[l]+b[l+1]; //b[1] += c,\u6240\u4ee5a[l+1] += c\n... //\u4e00\u76f4\u5230\na[r] = b[1]+b[2]+...b[l]+...+b[r];  //b[1] += c,\u6240\u4ee5a[l+1] += c\na[r+1] = b[1]+b[2]+...b[l]+...+b[r]+b[r+1]; //b[l] += c,b[r+1] -= c;\u6240\u4ee5a[r+1]\u4e0d\u53d8\n\n//\u6240\u4ee5\u7531\u6b64\u53ef\u77e5\u4e0a\u9762\u7684\u4e24\u4e2a\u8bed\u53e5\uff08b[l] += c;b[r+1] -= c\uff09\u53ef\u4ee5\u5b9e\u73b0a\u6570\u7ec4\u5728\u533a\u95f4[l,r]\u5185\u7684\u6240\u6709\u503c\u90fd\u52a0\u4e0a\u4e86\u5e38\u6570c\n\n ```\n\n## \u4e8c\u7ef4\n\u5982\u679c\u6269\u5c55\u5230\u4e8c\u7ef4\uff0c\u6211\u4eec\u9700\u8981\u8ba9\u4e8c\u7ef4\u6570\u7ec4\u88ab\u9009\u4e2d\u7684\u5b50\u77e9\u9635\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u7684\u503c\u52a0\u4e0ac,\u662f\u5426\u4e5f\u53ef\u4ee5\u8fbe\u5230O(1)\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u3002\u7b54\u6848\u662f\u53ef\u4ee5\u7684\uff0c\u8003\u8651\u4e8c\u7ef4\u5dee\u5206\u3002\n![](https://img-blog.csdnimg.cn/20210718012458309.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nvb3Blcmlh,size_16,color_FFFFFF,t_70)\n### \u64cd\u4f5c\n```cpp\nvoid insert(int x1,int y1,int x2,int y2,int c)\n{\n    b[x1][y1] += c;\n    b[x2+1][y1] -= c;\n    b[x1][y2+1] -= c;\n    b[x2+1][y2+1] += c;\n}\n</code></pre> <p>\u521d\u59cb\u5316</p> <pre><code>for(int i = 1; i &lt;= n; i++)\n{\n    for(int j = 1; j &lt;= m; j++)\n    {\n       insert(i,j,i,j,a[i][j]);\n    }\n}\n</code></pre>","tags":["\u524d\u7f00\u548c&\u5dee\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3","OI\u5b66\u4e60\u7b14\u8bb0"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/#_12","title":"\u533a\u95f4\u4fee\u6539","text":"<p>\u5bf9\u4e8e\u533a\u95f4 $[l,r]$\uff0c\u6240\u6709\u5143\u7d20\u90fd\u52a0\u4e0a\u4e00\u4e2a\u503c $c$\uff0c\u7b49\u4ef7\u4e8e\u5728\u5dee\u5206\u6570\u7ec4\u4e2d $cha_i+=c,cha_{r+1}-=c$\u3002 \u7136\u540e\u5bf9\u8fd9\u4e2a\u5dee\u5206\u6570\u7ec4\u6c42\u524d\u7f00\u548c\u5373\u53ef\u627e\u5230\u7b54\u6848\u3002</p> <p>\u6b64\u6587\u7ae0\u53c2\u8003\u4e86\u524d\u7f00\u548c\u4e0e\u5dee\u5206 \u56fe\u6587\u5e76\u8302 \u8d85\u8be6\u7ec6\u6574\u7406\uff08\u5168\u7f51\u6700\u901a\u4fd7\u6613\u61c2\uff09 \u548c\u7b97\u6cd5\u7b14\u8bb0\uff08\u516d\uff09\uff1a\u5dee\u5206\u6cd5\u7684\u76f8\u5173\u5185\u5bb9\uff0c\u5728\u6b64\u8868\u793a\u611f\u8c22\u3002</p>","tags":["\u524d\u7f00\u548c&\u5dee\u5206","\u5b66\u4e60\u7b14\u8bb0","\u7b97\u6cd5\u601d\u60f3","OI\u5b66\u4e60\u7b14\u8bb0"]},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0_README/","title":"\u7b97\u6cd5\u6587\u7ae0_README","text":""},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0_README/#introl","title":"Introl\u7684\u4e2a\u4eba\u5b66\u4e60\u7b14\u8bb0","text":"<p>\u5b66\u4e60\u7b14\u8bb0-1-\u9012\u5f52\u53ca\u9012\u63a8</p> <p>\u5b66\u4e60\u7b14\u8bb0-2-DFS-BFS\u7b97\u6cd5</p> <p>\u5b66\u4e60\u7b14\u8bb0-3-\u4e8c\u5206</p> <p>\u5b66\u4e60\u7b14\u8bb0-4-\u524d\u7f00\u548c-\u5dee\u5206</p>"},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0_README/#_1","title":"\u8bfe\u4ef6","text":"<p>\u5185\u5bb9\u6765\u6e90\u4e8e\u7f51\u7edc\uff0c\u4ec5\u7528\u4e8e\u4ea4\u6d41\u5b66\u4e60\u4f7f\u7528\uff0c\u7981\u6b62\u5546\u7528\u3002\u5982\u6709\u4fb5\u6743\u8bf7\u8054\u7cfb\u5220\u9664\u3002</p> <p>\u500d\u589e\u601d\u60f3\u53ca\u5e94\u7528_\u8d75\u5b97\u660c</p> <p>\u641c\u7d22\u7b97\u6cd5\u53ca\u5176\u5e94\u7528_\u80e1\u82b3</p> <p>\u52a8\u6001\u89c4\u5212_\u5f20\u8d85</p> <p>NOI\u6307\u5bfc\u6559\u5e08\u57f9\u8bad_\u5415\u7ea2\u6ce2</p> <p>\u6570\u636e\u7ed3\u6784_\u738b\u6653\u9e4f</p> <p>\u52a8\u6001\u89c4\u5212_\u674e\u5efa</p> <p>2024\u4fe1\u606f\u5b66\u7ade\u8d5b\u4e2d\u7684\u6570\u8bba\uff08\u5165\u95e8\u7ea7\u548c\u63d0\u9ad8\u7ec4\uff09</p> <p>\u56fe\u8bba\u521d\u6b65_\u53f6\u56fd\u5e73</p> <p>\u7b80\u5355\u6570\u8bba\u53ca\u5176\u5e94\u7528_\u5b8b\u65b0\u6ce2</p> <p>\u5e38\u89c1\u52a8\u6001\u89c4\u5212\u6a21\u578b\u53ca\u5176\u4f18\u5316_\u5c48\u8fd0\u534e</p> <p>\u6570\u636e\u7ed3\u6784_\u5c48\u8fd0\u534e</p>"},{"location":"OI/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E8%AF%BE%E4%BB%B6/","title":"\u8bfe\u4ef6","text":"<p>\u5185\u5bb9\u6765\u6e90\u4e8e\u7f51\u7edc\uff0c\u4ec5\u7528\u4e8e\u4ea4\u6d41\u5b66\u4e60\u4f7f\u7528\uff0c\u7981\u6b62\u5546\u7528\u3002\u5982\u6709\u4fb5\u6743\u8bf7\u8054\u7cfb\u5220\u9664\u3002</p> <p>\u500d\u589e\u601d\u60f3\u53ca\u5e94\u7528_\u8d75\u5b97\u660c</p> <p>\u641c\u7d22\u7b97\u6cd5\u53ca\u5176\u5e94\u7528_\u80e1\u82b3</p> <p>\u52a8\u6001\u89c4\u5212_\u5f20\u8d85</p> <p>NOI\u6307\u5bfc\u6559\u5e08\u57f9\u8bad_\u5415\u7ea2\u6ce2</p> <p>\u6570\u636e\u7ed3\u6784_\u738b\u6653\u9e4f</p> <p>\u52a8\u6001\u89c4\u5212_\u674e\u5efa</p> <p>2024\u4fe1\u606f\u5b66\u7ade\u8d5b\u4e2d\u7684\u6570\u8bba\uff08\u5165\u95e8\u7ea7\u548c\u63d0\u9ad8\u7ec4\uff09</p> <p>\u56fe\u8bba\u521d\u6b65_\u53f6\u56fd\u5e73</p> <p>\u7b80\u5355\u6570\u8bba\u53ca\u5176\u5e94\u7528_\u5b8b\u65b0\u6ce2</p> <p>\u5e38\u89c1\u52a8\u6001\u89c4\u5212\u6a21\u578b\u53ca\u5176\u4f18\u5316_\u5c48\u8fd0\u534e</p> <p>\u6570\u636e\u7ed3\u6784_\u5c48\u8fd0\u534e</p>"},{"location":"OI/%E8%B5%84%E6%BA%90%E9%93%BE%E6%8E%A5/%E8%B5%84%E6%BA%90%E9%93%BE%E6%8E%A5_README/","title":"\u8d44\u6e90\u94fe\u63a5","text":"<ul> <li>NOI-Linux2.0-iso-\u955c\u50cf</li> <li>\u6df1\u5165\u6d45\u51fa\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b_\u57fa\u7840\u7bc7_\u6d1b\u8c37\u7f51\u6821</li> <li>\u6df1\u5165\u6d45\u51fa\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b_\u8fdb\u9636\u7bc7_\u6d1b\u8c37\u7f51\u6821</li> <li>\u4fe1\u606f\u5b66\u5965\u8d5b\u4e00\u672c\u901a_\u7b2c\u4e94\u7248</li> </ul> <p>\u672c\u77e5\u8bc6\u5e93\u6240\u6709OI\u76f8\u5173\u8d44\u6599\u53ef\u5728github(Introl-ljl/OI-PDF)\u4e2d\u627e\u5230\u5907\u4efd\u3002\u6b64\u6587\u6863\u7531\u4e8egit\u63d0\u4ea4\u4e0a\u9650\u539f\u56e0\u66f4\u65b0\u901f\u5ea6\u7f13\u6162\uff0c\u63a8\u8350\u76f4\u63a5\u5728\u4e91\u76d8\u4e0b\u8f7d\u5373\u53ef\u3002</p>"},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/11-25-NOIP-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/","title":"11.25 NOIP\u6a21\u62df\u8d5b2 \u9898\u89e3","text":"","tags":["\u6a21\u62df\u8d5b","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/11-25-NOIP-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/#t1-pair","title":"T1 \u6570\u5bf9\uff08pair\uff09","text":"<p>\u7ed9\u5b9a $n$ \u4e2a\u6b63\u6574\u6570\uff0c\u6c42\u6ee1\u8db3 $a_i$ \u662f $a_j$ \u500d\u6570\u7684\u6570\u5bf9\u6570\u91cf\u3002</p>","tags":["\u6a21\u62df\u8d5b","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/11-25-NOIP-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/#_1","title":"\u9898\u76ee\u5206\u6790","text":"","tags":["\u6a21\u62df\u8d5b","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/11-25-NOIP-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/#onsqrt-n","title":"$(O(n\\sqrt n))$ \u505a\u6cd5","text":"<p>\u5bf9\u4e8e\u6bcf\u4e2a\u6570 $a_i$ \u6c42\u51fa\u5b83\u7684\u56e0\u6570\uff0c\u7528\u6876\u6765\u5b58\u50a8\u6bcf\u4e2a\u6570\u4f5c\u4e3a\u56e0\u6570\u7684\u51fa\u73b0\u6b21\u6570\uff0c\u5faa\u73af\u7edf\u8ba1\u7b54\u6848\u5373\u53ef\u3002</p>","tags":["\u6a21\u62df\u8d5b","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/11-25-NOIP-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/#onlog-n","title":"$O(n\\log n)$\u505a\u6cd5","text":"<p>\u5bf9\u4e8e\u6bcf\u4e2a\u6570 $a_i$ \u6c42\u51fa\u5176\u4e0d\u5927\u4e8e $\\max_{i=1}^{n}a_i$ \u7684\u6240\u6709\u500d\u6570\uff0c\u540c\u6837\u7528\u6876\u5b58\u50a8\u6bcf\u4e2a\u6570\u4f5c\u4e3a\u5176\u4f59\u6570\u500d\u6570\u7684\u51fa\u73b0\u6b21\u6570\uff0c\u7edf\u8ba1\u7b54\u6848\u5373\u53ef\u3002\u590d\u6742\u5ea6\u4e3a\u8c03\u548c $O(n\\log n)$\u3002</p>","tags":["\u6a21\u62df\u8d5b","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/11-25-NOIP-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/#code","title":"Code","text":"<pre><code>// #pragma GCC optimize(1, 2, 3, \"Ofast\", \"inline\")\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\n// #define ONLINEJUDGE\n// #define MULTI_CASES\nconst int MaxN = 2e5 + 100;\nconst int MaXN = 5e5 + 100;\nconst int INF = 1e9;\nint T = 1, N, M;\nint a[MaxN];\nint vis[MaXN];\nint ans[MaXN];\ninline void Solve()\n{\n    cin &gt;&gt; N;\n    int maxn = 0;\n    for (int i = 1; i &lt;= N; i++)\n    {\n        cin &gt;&gt; a[i];\n        // vis[a[i]]=1;\n        vis[a[i]]++;\n        maxn = max(maxn, a[i]);\n    }\n    for (int i = 1; i &lt;= N; i++)\n    {\n        if (ans[a[i]])\n        {\n            // ans[a[i]]++;\n            continue;\n        }\n        for (int j = 1; j * a[i] &lt;= maxn; j++)\n        {\n            ans[a[i]] += vis[a[i] * j];\n            if (j == 1)\n            {\n                ans[a[i]]--;\n            }\n        }\n    }\n    int sum = 0;\n    for (int i = 1; i &lt;= N; i++)\n    {\n        sum += ans[a[i]];\n    }\n    cout &lt;&lt; sum &lt;&lt; endl;\n}\nsigned main()\n{\n#ifndef ONLINEJUDGE\n    freopen(\"pair.in\", \"r\", stdin);\n    freopen(\"pair.out\", \"w\", stdout);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n\n#ifdef MULTI_CASES\n    cin &gt;&gt; T;\n    while (T--)\n#endif\n        Solve();\n    // fclose(stdin);\n    // fclose(stdout);\n    return 0;\n}\n</code></pre>","tags":["\u6a21\u62df\u8d5b","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/11-25-NOIP-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/#t2-transport","title":"T2 \u8fd0\u8d27\uff08transport\uff09","text":"","tags":["\u6a21\u62df\u8d5b","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/11-25-NOIP-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/#_2","title":"\u9898\u76ee\u5206\u6790","text":"<p>\u9996\u5148\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u8d27\u7269\uff0c\u6700\u4f18\u7684\u5c0f\u8f66\u51fa\u53d1\u65f6\u95f4\u5e94\u4e3a\u5176\u5230\u8fbe\u5378\u8d27\u53e3\u7684\u65f6\u95f4\u51cf\u53bb\u5c0f\u8f66\u5230\u8d27\u67b6\u7684\u65f6\u95f4\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5c06\u6240\u6709\u7684\u5c0f\u8f66\u51fa\u53d1\u65f6\u95f4\u5b58\u50a8\u4e0b\u6765\uff0c\u5bf9\u5176\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u5e8f\u5217 $a_i$\u3002\u663e\u7136\u901a\u8fc7\u8d2a\u5fc3\u7684\u601d\u60f3\uff0c\u6bcf\u8f86\u5c0f\u8f66\u5728\u8fd9\u4e2a\u5e8f\u5217\u4e2d\u7684\u65f6\u95f4\u51fa\u53d1\u624d\u662f\u6700\u4f18\u7684\u3002</p> <p>\u9898\u76ee\u8981\u6c42\u6700\u5c11\u82b1\u8d39\u7684\u65f6\u95f4\uff0c\u90a3\u4e48\u663e\u7136\u53ef\u4ee5\u53d1\u73b0\uff0c\u6240\u6709\u5c0f\u8f66\u8d70\u4e86\u6700\u8fdc\u7684\u90a3\u8f86\u8f66\u6240\u82b1\u8d39\u7684\u65f6\u95f4\u5c31\u662f\u6700\u77ed\u65f6\u95f4\u3002\u6211\u4eec\u5bf9\u4e8e $a_i$\uff0c\u8fd0\u9001\u5b83\u7684\u5c0f\u8f66\u7f16\u53f7\u5e94\u4e3a $i\\mod  M$\uff0c\u8fd9\u8f86\u5c0f\u8f66\u8fd0\u8f93\u5b8c  $a_i$ \u540e\u7684\u82b1\u8d39\u65f6\u95f4\u5e94\u8be5\u4e3a $\\max(max_{i\\mod M},a_i)$\uff0c\u90a3\u4e48\u5bf9\u4e8e $M$ \u4e2a\u5c0f\u8f66\u5206\u522b\u6c42\u51fa\u5176\u6700\u591a\u82b1\u8d39\u7684\u65f6\u95f4\uff0c\u7edf\u8ba1\u7b54\u6848\u5373\u53ef\u3002</p>","tags":["\u6a21\u62df\u8d5b","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/11-25-NOIP-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/#code_1","title":"Code","text":"<pre><code>// #pragma GCC optimize(1, 2, 3, \"Ofast\", \"inline\")\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\n// #define ONLINEJUDGE\n// #define MULTI_CASES\nconst int MaxN = 2e5 + 100;\nconst int INF = 1e9;\nint T = 1, N, M;\nint a[MaxN];\nint ans[2010];\ninline void Solve()\n{\n    cin &gt;&gt; N &gt;&gt; M;\n    // for (int i = 1; i &lt;= M; i++)\n    // {\n    //     q.push(0);\n    // }\n    // int ans = 0;\n    vector&lt;int&gt; f;\n    for (int i = 0; i &lt; N; i++)\n    {\n        int len;\n        cin &gt;&gt; len;\n        for (int j = 1; j &lt;= len; j++)\n        {\n            int x;\n            cin &gt;&gt; x;\n            f.push_back(x - i - 1);\n        }\n    }\n    sort(f.begin(), f.end());\n    for (int i = 0; i &lt; (int)f.size(); i++)\n    {\n        ans[i % M] = max(ans[i % M], f[i]) + N + 1;\n    }\n    int sum = 0;\n    for (int i = 0; i &lt; M; i++)\n    {\n        sum = max(sum, ans[i]);\n    }\n    cout &lt;&lt; sum &lt;&lt; endl;\n}\nsigned main()\n{\n#ifndef ONLINEJUDGE\n    freopen(\"transport.in\", \"r\", stdin);\n    freopen(\"transport.out\", \"w\", stdout);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n\n#ifdef MULTI_CASES\n    cin &gt;&gt; T;\n    while (T--)\n#endif\n        Solve();\n    // fclose(stdin);\n    // fclose(stdout);\n    return 0;\n}\n</code></pre>","tags":["\u6a21\u62df\u8d5b","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/11-25-NOIP-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/#t3-daddy","title":"T3 \u627e\u7238\u7238\uff08daddy\uff09","text":"","tags":["\u6a21\u62df\u8d5b","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/11-25-NOIP-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/#_3","title":"\u9898\u76ee\u5206\u6790","text":"<p>\u9898\u76ee\u8981\u6c42DNA\u5e8f\u5217\u7684\u6700\u5927\u76f8\u4f3c\u7a0b\u5ea6\uff0c\u8003\u8651 $dp$ \u505a\u6cd5\uff0c\u53ef\u4ee5\u5f97\u51fa $dp_{i,j,k}$ \u8868\u793a a\u5e8f\u5217\u957f\u5ea6\u4e3a $i$\uff0cb\u5e8f\u5217\u957f\u5ea6\u4e3a $j$ \uff0c\u672b\u5c3e\u6709/\u65e0\u7a7a\u683c\uff08$k=0$ \u65e0\u7a7a\u683c\uff0c$k=1$ \u8868\u793aa\u5e8f\u5217\u6709\u7a7a\u683c\uff0c$k=2$ \u8868\u793ab\u5e8f\u5217\u672b\u5c3e\u6709\u7a7a\u683c\uff09\u65f6\u7684\u6700\u5927\u76f8\u4f3c\u7a0b\u5ea6\u3002</p> <p>\u5173\u4e8e\u7a7a\u683c\uff0c\u5bf9\u4e8e\u6bcf\u6bb5\u8fde\u7eed\u7a7a\u683c\uff0c\u76f8\u4f3c\u7a0b\u5ea6\u4e3a $-A-B\\times (k-1)$ \u56e0\u4e3a $A,B$ \u90fd\u662f\u6b63\u6574\u6570\uff0c\u6240\u4ee5\u5176\u76f8\u4f3c\u7a0b\u5ea6\u4e00\u5b9a\u4e3a\u8d1f\u6570\u3002\u5bf9\u4e8e\u4e00\u4e2a\u7a7a\u683c\uff0c\u4f1a\u51cf\u5c11 $A$ \u70b9\u76f8\u4f3c\u5ea6\uff0c\u5982\u679c\u5728\u540e\u9762\u591a\u6dfb\u52a0\u4e00\u4e2a\u7a7a\u683c\uff0c\u5219\u4f1a\u8fdb\u4e00\u6b65\u51cf\u5c11 $B$ \u70b9\u76f8\u4f3c\u5ea6\u3002</p> <p>\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b\uff1a</p> <p>$$dp_{i,j,0}=\\max(dp_{i-1,j-1,0},dp_{i-1,j-1,1},dp_{i-1,j-1,2})+a_{s1_i,s2_j}$$</p> <p>$$dp_{i,j,1}=\\max(dp_{i-1,j,0}-A,dp_{i-1,j,1}-B,dp_{i-1,j,2}-A)$$</p> <p>$$dp_{i,j,2}=\\max(dp_{i,j-1,0}-A,dp_{i,j-1,1}-A,dp_{i,j-1,2}-B)$$</p>","tags":["\u6a21\u62df\u8d5b","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/11-25-NOIP-%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E9%A2%98%E8%A7%A3/#code_2","title":"Code","text":"<pre><code>// #pragma GCC optimize(1, 2, 3, \"Ofast\", \"inline\")\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\n// #define ONLINEJUDGE\n// #define MULTI_CASES\nconst int MaxN = 2e3 + 100;\nconst int INF = 1e18;\nint T = 1, N, M;\nint a[10][10];\nint dp[MaxN][MaxN][4];\nint A, B;\n\nint g(int k)\n{\n    return -A - B * (k - 1);\n}\ninline void Solve()\n{\n    string s1, s2;\n    cin &gt;&gt; s1 &gt;&gt; s2;\n    s1 = ' ' + s1;\n    s2 = ' ' + s2;\n    map&lt;char, int&gt; mp;\n    mp['A'] = 1;\n    mp['T'] = 2;\n    mp['G'] = 3;\n    mp['C'] = 4;\n    for (int i = 1; i &lt;= 4; i++)\n    {\n        for (int j = 1; j &lt;= 4; j++)\n        {\n            cin &gt;&gt; a[i][j];\n        }\n    }\n    cin &gt;&gt; A &gt;&gt; B;\n    for (int i = max(s1.size(), s2.size()); i &gt;= 1; i--)\n    {\n        dp[0][i][0] = dp[i][0][0] = dp[0][i][2] = dp[i][0][1] = dp[0][i][1] = dp[i][0][2] = -INF;\n        dp[0][i][1] = dp[i][0][2] = g(i);\n    }\n    for (int i = 1; i &lt; s1.size(); i++)\n    {\n        for (int j = 1; j &lt; s2.size(); j++)\n        {\n            dp[i][j][0] = max({dp[i - 1][j - 1][0], dp[i - 1][j - 1][1], dp[i - 1][j - 1][2]}) + a[mp[s1[i]]][mp[s2[j]]];\n            dp[i][j][1] = max({dp[i - 1][j][0] - A, dp[i - 1][j][1] - B, dp[i - 1][j][2] - A});\n            dp[i][j][2] = max({dp[i][j - 1][0] - A, dp[i][j - 1][1] - A, dp[i][j - 1][2] - B});\n        }\n    }\n    cout &lt;&lt; max({dp[s1.size() - 1][s2.size() - 1][0], dp[s1.size() - 1][s2.size() - 1][1], dp[s1.size() - 1][s2.size() - 1][2]}) &lt;&lt; endl;\n}\nsigned main()\n{\n#ifndef ONLINEJUDGE\n    freopen(\"daddy.in\", \"r\", stdin);\n    freopen(\"daddy.out\", \"w\", stdout);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n\n#ifdef MULTI_CASES\n    cin &gt;&gt; T;\n    while (T--)\n#endif\n        Solve();\n    // fclose(stdin);\n    // fclose(stdout);\n    return 0;\n}\n\n</code></pre>","tags":["\u6a21\u62df\u8d5b","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1833B-Restore-the-Weather-%E9%A2%98%E8%A7%A3/","title":"CF1833B Restore the Weather \u9898\u89e3","text":"","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1833B-Restore-the-Weather-%E9%A2%98%E8%A7%A3/#_1","title":"\u9898\u610f\u7b80\u8ff0","text":"<ul> <li>\u7ed9\u5b9a\u4e24\u4e2a\u957f\u5ea6\u4e3a $n$ \u7684\u6570\u7ec4 $a,b$\u3002</li> <li>\u91cd\u6392\u6570\u7ec4 $b$\uff0c\u4f7f\u5f97 $|a_i-b_i|$ \u7684\u503c\u5c3d\u53ef\u80fd\u5c0f\u4e14 $|a_i - b_i|\\le k$\u3002</li> <li>\u4fdd\u8bc1\u6709\u89e3\u3002</li> </ul>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1833B-Restore-the-Weather-%E9%A2%98%E8%A7%A3/#_2","title":"\u5206\u6790","text":"<p>\u56e0\u4e3a\u8fd9\u9053\u9898\u662f\u4fdd\u8bc1\u6709\u89e3\u7684\uff0c\u6240\u4ee5\u5728 $|a_i - b_i|$ \u7684\u503c\u6700\u5c0f\u7684\u60c5\u51b5\u4e0b\uff0c$|a_i - b_i|\\le k$ \u8fd9\u4e2a\u6761\u4ef6\u662f\u4e0d\u5fc5\u8981\u7684\u3002\u53ef\u5f97\u672c\u9898\u505a\u6cd5\u4e3a\u600e\u6837\u91cd\u6392 $b$ \u6570\u7ec4\uff0c\u4fdd\u8bc1 $|a_i - b_i|$ \u7684\u503c\u5c3d\u53ef\u80fd\u5c0f\u3002\u663e\u7136\uff0c\u901a\u8fc7\u7b80\u8981\u7684\u8f6c\u5316\u53ef\u5f97\uff0c\u5f53 $a,b$ \u6309\u7167\u5347\u5e8f\u6216\u964d\u5e8f\u6392\u5217\u7684\u65f6\u5019\uff0c$|a_i-b_i|$ \u7684\u503c\u5c3d\u53ef\u80fd\u5c0f\u3002\u6ce8\u610f\u4e00\u70b9\uff0c\u5728\u9898\u76ee\u4e2d\uff0c\u8981\u6c42\u4ee5 $a$ \u6570\u7ec4\u7684\u539f\u987a\u5e8f\u6765\u8f93\u51fa\u91cd\u6392\u540e\u7684 $b$ \u6570\u7ec4\u3002\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u7ed3\u6784\u4f53\u5b58\u50a8 $a_i$ \u7684\u539f\u7f16\u53f7\uff0c\u5bf9\u7ed3\u6784\u4f53\u6392\u5e8f\u4e4b\u540e\u6309\u7167\u8fd9\u4e2a\u987a\u5e8f\u8fdb\u884c\u8f93\u51fa\u5373\u53ef\u3002</p>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1833B-Restore-the-Weather-%E9%A2%98%E8%A7%A3/#_3","title":"\u4ee3\u7801","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\nconst int MaxN = 1e5 + 100;\nconst int INF = 1e9;\nint T=1, N, M;\ntemplate&lt;class T&gt;\ninline void qread(T &amp;sum)\n{\n    sum=0;int boo=1;\n    char x=getchar();\n    while(x&lt;'0'||x&gt;'9'){if(x=='-')boo=-1;x=getchar();}\n    while(x&gt;='0'&amp;&amp;x&lt;='9'){sum=(sum&lt;&lt;1)+(sum&lt;&lt;3)+x-'0';x=getchar();}\n    sum*=boo;\n}\ntemplate&lt;class T&gt;\nvoid qput(T x)\n{\n    if(x&lt;0){\n        x=-x;\n        putchar('-');}\n    if(x&gt;9)\n        qput(x/10);\n   putchar(x%10+48);\n}\nstruct f{\n    int id ,a;\n}a[MaxN];//\u7ed3\u6784\u4f53\uff0cid\u4e3a\u539f\u7f16\u53f7\uff0ca\u4e3a\u503c\u3002\n\nbool cmp(f a,f b){\n    return a.a&lt;b.a;//\u5bf9\u7ed3\u6784\u4f53\u6309\u7167a\u7684\u5927\u5c0f\u8fdb\u884c\u6392\u5e8f\u3002\n}\ninline void Solve()\n{\n    int n,k;//\u5176\u5b9e\u4e0ek\u7684\u503c\u662f\u65e0\u5173\u7684\u3002\n    int b[MaxN],ans[MaxN];\n    qread(n),qread(k);\n    for(int i=0;i&lt;n;i++){\n        qread(a[i].a);\n        a[i].id=i;//\u5728\u8f93\u5165a\u6570\u7ec4\u65f6\u8bb0\u5f55a_i\u7684\u7f16\u53f7\u3002\n    }\n    for(int i=0;i&lt;n;i++){\n        qread(b[i]);\n    }\n    sort(b,b+n);\n    sort(a,a+n,cmp);\n    for(int i=0;i&lt;n;i++){\n        ans[a[i].id]=b[i];//\u5b58\u50a8\u91cd\u6392\u4e4b\u540e\u7684b\u6570\u7ec4\n    }\n    for(int i=0;i&lt;n;i++){\n        cout&lt;&lt;ans[i]&lt;&lt;\" \";\n    }\n    cout&lt;&lt;endl;\n}\nsigned main()\n{\n    cin &gt;&gt; T;\n    while (T--)\n       Solve();\n    return 0;\n}\n</code></pre>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1846B-Rudolph-and-Tic-Tac-Toe-%E9%A2%98%E8%A7%A3/","title":"CF1846B Rudolph and Tic-Tac-Toe \u9898\u89e3","text":"<p>\u5176\u5b9e\u5c31\u662f\u4e2a\u6a21\u62df\u9898\uff0c\u6309\u9898\u610f\u6a21\u62df\u5373\u53ef</p>","tags":["CF","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1846B-Rudolph-and-Tic-Tac-Toe-%E9%A2%98%E8%A7%A3/#_1","title":"\u9898\u610f\u7b80\u8ff0","text":"<p>\u9898\u610f\u53ef\u4ee5\u7406\u89e3\u4e3a\u6709\u4e09\u4e2a\u4eba\u4e2a\u4eba\u5728 $3\\times3$ \u7684\u65b9\u683c\u4e2d\u4e0b\u4e95\u5b57\u68cb\uff0c\u5982\u679c\u4e09\u4e2a\u76f8\u540c\u7684\u68cb\u5b50\u8fde\u6210\u4e00\u6761\u7ebf\uff0c\u5c31\u53ef\u4ee5\u5224\u5b9a\u8f93\u8d62\u3002\u5982\u679c\u6ca1\u6709\u4eba\u8d62\u5219\u8f93\u51fa <code>DRAW</code> \u3002</p>","tags":["CF","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1846B-Rudolph-and-Tic-Tac-Toe-%E9%A2%98%E8%A7%A3/#_2","title":"\u5206\u6790","text":"<p>\u8fde\u63a5\u7684\u65b9\u5f0f\u53ef\u5206\u4e3a\u4e09\u7c7b\uff1a\u6a2a\u884c\u3001\u7ad6\u5217\u3001\u5bf9\u89d2\u7ebf\u3002\u5171\u516b\u79cd\u60c5\u51b5\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u5224\u65ad\u662f\u5426\u6ee1\u8db3\u8fd9\u516b\u79cd\u60c5\u51b5\u7136\u540e\u8f93\u51fa\u5373\u53ef\u3002\u6ce8\u610f\u5728\u5224\u65ad\u7684\u65f6\u5019\u8981\u6392\u53bb <code>.</code> \uff0c\u4e0d\u80fd\u628a\u7a7a\u884c\u4e5f\u7b97\u4f5c\u4e00\u79cd\u3002\u5177\u4f53\u53ef\u770b\u4ee3\u7801\u3002</p>","tags":["CF","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1846B-Rudolph-and-Tic-Tac-Toe-%E9%A2%98%E8%A7%A3/#_3","title":"\u4ee3\u7801","text":"<pre><code>inline void Solve()\n{\n     string a[3];//\u5b58\u50a8\u5730\u56fe\uff0c\u6ce8\u610fstring\u662f\u4ece\u96f6\u5f00\u59cb\u7684\n     cin &gt;&gt; a[0];\n     cin &gt;&gt; a[1];\n     cin &gt;&gt; a[2];\n     //cout &lt;&lt; T&lt;&lt;endl;\n     //cout &lt;&lt; a[0][2]&lt;&lt;endl;\n     //\u6ce8\u610f\u6392\u9664\u7a7a\u884c\n     if (a[0][0] == a[1][0]&amp;&amp;a[0][0] == a[2][0]&amp;&amp;a[0][0]!='.'){//\u5224\u65ad\u7b2c\u4e00\u5217\n          cout &lt;&lt; a[0][0] &lt;&lt; endl;\n          return;\n     }\n     if(a[0][1]==a[1][1]&amp;&amp;a[0][1]==a[2][1]&amp;&amp;a[0][1]!='.'){//\u7b2c\u4e8c\u5217\n          cout &lt;&lt; a[0][1] &lt;&lt; endl;//cout &lt;&lt; 1;\n           return;\n     }\n     if(a[0][2]==a[1][2]&amp;&amp;a[0][2]==a[2][2]&amp;&amp;a[0][2]!='.'){//\u7b2c\u4e09\u5217\n          cout &lt;&lt; a[0][2] &lt;&lt; endl;\n          return;\n     }\n     if (a[0][0] == a[0][1]&amp;&amp;a[0][0] == a[0][2]&amp;&amp;a[0][0]!='.'){//\u7b2c\u4e00\u884c\n          cout &lt;&lt; a[0][0] &lt;&lt; endl;\n          return;\n     }\n     if(a[1][0]==a[1][1]&amp;&amp;a[1][0]==a[1][2]&amp;&amp;a[1][0]!='.'){//\u7b2c\u4e8c\u884c\n             cout &lt;&lt; a[1][0] &lt;&lt; endl;\n             return;\n     }\n     if(a[2][0]==a[2][1]&amp;&amp;a[2][0]==a[2][2]&amp;&amp;a[2][0]!='.'){//\u7b2c\u4e09\u884c\n             cout &lt;&lt; a[2][0] &lt;&lt; endl;\n             return;\n     }\n     if(a[0][0]==a[1][1]&amp;&amp;a[0][0]==a[2][2]&amp;&amp;a[0][0]!='.'){//\u5bf9\u89d2\u7ebf1\n             cout &lt;&lt; a[0][0] &lt;&lt; endl;\n             return;\n     }\n     if(a[0][2]==a[1][1]&amp;&amp;a[0][2]==a[2][0]&amp;&amp;a[0][2]!='.'){//\u5bf9\u89d2\u7ebf2\n             cout &lt;&lt; a[0][2] &lt;&lt; endl;\n             return;\n     }\n     cout &lt;&lt; \"DRAW\" &lt;&lt; endl;//\u5982\u679c\u90fd\u4e0d\u7b26\u5408\n}\n</code></pre>","tags":["CF","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1850B-Ten-Words-of-Wisdom%E9%A2%98%E8%A7%A3/","title":"CF1850B Ten Words of Wisdom\u9898\u89e3","text":"","tags":["CF","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1850B-Ten-Words-of-Wisdom%E9%A2%98%E8%A7%A3/#_1","title":"\u9898\u76ee\u7b80\u8ff0","text":"<p>\u5728 $n$ \u4e2a\u56de\u7b54\u4e2d\u627e\u5230\u957f\u5ea6\u4e0d\u8d85\u8fc7 $10$ \u4e14\u8d28\u91cf\u6700\u9ad8\u7684\u56de\u7b54\u3002</p>","tags":["CF","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1850B-Ten-Words-of-Wisdom%E9%A2%98%E8%A7%A3/#_2","title":"\u9898\u76ee\u5206\u6790","text":"<p>\u5c31\u662f\u4e2a\u666e\u901a\u6a21\u62df\uff0c\u5982\u679c $a_i\\le 10$\uff0c\u5c31\u6253\u64c2\u53f0\u627e\u6700\u5927\u8d28\u91cf\uff0c\u66f4\u65b0\u5e8f\u53f7\u3002</p>","tags":["CF","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1850B-Ten-Words-of-Wisdom%E9%A2%98%E8%A7%A3/#code","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\nconst int MaxN = 1e6 + 100;\nconst int INF = 1e9;\nint T=1, N, M;\ntemplate&lt;class T&gt;\ninline void qread(T &amp;sum)\n{\n    sum=0;int boo=1;\n    char x=getchar();\n    while(x&lt;'0'||x&gt;'9'){if(x=='-')boo=-1;x=getchar();}\n    while(x&gt;='0'&amp;&amp;x&lt;='9'){sum=(sum&lt;&lt;1)+(sum&lt;&lt;3)+x-'0';x=getchar();}\n    sum*=boo;\n}\ntemplate&lt;class T&gt;\nvoid qput(T x)\n{\n    if(x&lt;0){\n        x=-x;\n        putchar('-');}\n    if(x&gt;9)\n        qput(x/10);\n    putchar(x%10+48);\n}\ninline void Solve()\n{\n    int n;\n    cin&gt;&gt;n;\n    int maxn=-1,ans=0;\\\\\u8bb0\u5f97\u521d\u59cb\u5316\n    for(int i=0;i&lt;n;i++){\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        if(a&gt;10){\n            continue;\n        }\n        if(b&gt;maxn){\n            maxn=b;\n            ans=i+1;\\\\\u56e0\u4e3a\u6211\u7684\u4e60\u60ef\u662f\u4ece\u96f6\u5f00\u59cb\uff0c\u8fd9\u91cc\u7684ans\u66f4\u65b0\u65f6\u9700\u8981+1.\n        }\n    }\n    cout&lt;&lt;ans&lt;&lt;endl;\n}\nsigned main()\n{\n    //freopen(\".in\", \"r\", stdin);\n    //freopen(\".out\", \"w\", stdout);\n    ios::sync_with_stdio(0);\n    //cin.tie(0);\n    cin &gt;&gt; T;\n    while (T--)\n        Solve();\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n\n</code></pre>","tags":["CF","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1850C-Word-on-the-Paper%E9%A2%98%E8%A7%A3/","title":"CF1850C Word on the Paper\u9898\u89e3","text":"","tags":["CF","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1850C-Word-on-the-Paper%E9%A2%98%E8%A7%A3/#_1","title":"\u9898\u76ee\u7b80\u8ff0","text":"<p>\u5728 $8 \\times 8$ \u7684\u70b9\u7f51\u683c\u4e0a\uff0c\u4e00\u4e2a\u7531\u5c0f\u5199\u62c9\u4e01\u5b57\u6bcd\u7ec4\u6210\u7684\u5355\u8bcd\u4ece\u4e0a\u5230\u4e0b\u5782\u76f4\u5730\u5199\u5728\u4e00\u5217\u4e2d\u3002\u4f60\u9700\u8981\u627e\u5230\u4ed6\u5e76\u8f93\u51fa</p>","tags":["CF","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1850C-Word-on-the-Paper%E9%A2%98%E8%A7%A3/#_2","title":"\u9898\u76ee\u5206\u6790","text":"<p>\u7531\u9898\u610f\u53ef\u5f97\uff0c\u7f51\u683c\u4e2d\u53ea\u4f1a\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u81ea\u4e0a\u800c\u4e0b\u904d\u5386\u7f51\u683c\uff0c\u5982\u679c\u662f\u5b57\u6bcd\u5c31\u8f93\u51fa\u5373\u53ef\u3002</p>","tags":["CF","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1850C-Word-on-the-Paper%E9%A2%98%E8%A7%A3/#code","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\nconst int MaxN = 1e6 + 100;\nconst int INF = 1e9;\nint T=1, N, M;\ntemplate&lt;class T&gt;\ninline void qread(T &amp;sum)\n{\n    sum=0;int boo=1;\n    char x=getchar();\n    while(x&lt;'0'||x&gt;'9'){if(x=='-')boo=-1;x=getchar();}\n    while(x&gt;='0'&amp;&amp;x&lt;='9'){sum=(sum&lt;&lt;1)+(sum&lt;&lt;3)+x-'0';x=getchar();}\n    sum*=boo;\n}\ntemplate&lt;class T&gt;\nvoid qput(T x)\n{\n    if(x&lt;0){\n        x=-x;\n        putchar('-');}\n    if(x&gt;9)\n        qput(x/10);\n   putchar(x%10+48);\n}\ninline void Solve()\n{\n   string a[10];\\\\\u907f\u514d\u7206\u7a7a\u95f4\u53ef\u4ee5\u5f00\u5927\u70b9\n   for (int i = 0; i &lt; 8;i++){\n        cin &gt;&gt; a[i];\n   }\n   for (int i = 0; i &lt; 8;i++){\n        for (int j = 0; j &lt; a[i].size();j++){\n            if(a[i][j]!='.'){\n                cout &lt;&lt; a[i][j];\n            }\n        }\n   }\n   cout &lt;&lt; endl;\n}\nsigned main()\n{\n    //freopen(\".in\", \"r\", stdin);\n    //freopen(\".out\", \"w\", stdout);\n    ios::sync_with_stdio(0);\n    //cin.tie(0);\n    cin &gt;&gt; T;\n    while (T--)\n       Solve();\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n\n</code></pre>","tags":["CF","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1862B-Sequence-Game-%E9%A2%98%E8%A7%A3/","title":"CF1862B Sequence Game \u9898\u89e3","text":"","tags":["CF","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1862B-Sequence-Game-%E9%A2%98%E8%A7%A3/#_1","title":"\u5206\u6790","text":"<p>\u5f88\u7b80\u5355\u7684\u4e00\u9053\u6784\u9020\u9898\u3002</p> <p>\u56e0\u4e3a\u7b2c\u4e00\u4e2a\u6570\u662f\u5fc5\u53d6\u7684\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u4ece\u7b2c\u4e8c\u4e2a\u6570\u5f00\u59cb\u5224\u65ad\uff0c\u5373\u5982\u679c $b_{i-1}\\le b_i$\uff0c\u5c31\u4e0d\u9700\u8981\u5728\u8fd9\u4e24\u4e2a\u6570\u4e4b\u95f4\u6dfb\u52a0\u522b\u7684\u6570\u3002</p> <p>\u53cd\u4e4b\uff0c\u5982\u679c\u4e0d\u6ee1\u8db3\uff0c\u6211\u4eec\u5c31\u9700\u8981\u5728\u8fd9\u4e24\u4e2a\u6570\u4e4b\u95f4\u6dfb\u52a0\u4e00\u4e2a $b_i$\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u4fdd\u8bc1\u5b83\u6ee1\u8db3 $b_{i-1}\\le b_i$ \u7684\u6761\u4ef6\u3002</p> <p>\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u5148\u8dd1\u4e00\u6b21\u5faa\u73af\u8ba1\u7b97\u51fa $m$ \u7684\u503c\uff0c\u5c06 $m$ \u548c $a_1$ \u63d0\u524d\u8f93\u51fa\uff0c\u7136\u540e\u5faa\u73af\u8f93\u51fa\u5269\u4e0b\u7684\u6570\u5373\u53ef\u3002</p>","tags":["CF","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1862B-Sequence-Game-%E9%A2%98%E8%A7%A3/#code","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\nconst int MaxN = 1e6 + 100;\nconst int INF = 1e9;\nint T=1, N, M;\ntemplate&lt;class T&gt;\ninline void qread(T &amp;sum)\n{\n    sum=0;int boo=1;\n    char x=getchar();\n    while(x&lt;'0'||x&gt;'9'){if(x=='-')boo=-1;x=getchar();}\n    while(x&gt;='0'&amp;&amp;x&lt;='9'){sum=(sum&lt;&lt;1)+(sum&lt;&lt;3)+x-'0';x=getchar();}\n    sum*=boo;\n}\ntemplate&lt;class T&gt;\nvoid qput(T x)\n{\n    if(x&lt;0){\n        x=-x;\n        putchar('-');}\n    if(x&gt;9)\n        qput(x/10);\n   putchar(x%10+48);\n}\ninline void Solve()\n{\n    int n;\n    cin&gt;&gt;n;\n    int a[2000010];\n    for(int i=1;i&lt;=n;i++){\n        cin&gt;&gt;a[i];\n    }\n    int m=1;\n    //cout&lt;&lt;a[1]&lt;&lt;\" \";\n    for(int i=2;i&lt;=n;i++){\n        m++;\n        if(a[i]&gt;=a[i-1]){//\u5982\u679c\u4e0d\u6ee1\u8db3\u6761\u4ef6\u957f\u5ea6\u5c31\u9700\u8981\u52a0\u4e00\n            //m++;\n            continue;\n        }  \n        m++;\n    }\n    cout&lt;&lt;m&lt;&lt;endl&lt;&lt;a[1]&lt;&lt;\" \";//a1\u76f4\u63a5\u8f93\u51fa\u5373\u53ef\uff0c\u5faa\u73af\u4ece2\u5f00\u59cb\n    for(int i=2;i&lt;=n;i++){\n        if(a[i]&gt;=a[i-1]){\n            cout&lt;&lt;a[i]&lt;&lt;\" \";\n        }\n        else{\n            cout&lt;&lt;a[i]&lt;&lt;\" \"&lt;&lt;a[i]&lt;&lt;\" \";\n        }\n    }\n    cout&lt;&lt;endl;\n}\nsigned main()\n{\n    //freopen(\".in\", \"r\", stdin);\n    //freopen(\".out\", \"w\", stdout);\n    ios::sync_with_stdio(0);\n    //cin.tie(0);\n    cin &gt;&gt; T;\n    while (T--)\n       Solve();\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n\n</code></pre>","tags":["CF","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1890B%20Qingshan%20Loves%20Strings%E9%A2%98%E8%A7%A3/","title":"CF1890B Qingshan Loves Strings\u9898\u89e3","text":"","tags":["CF","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1890B%20Qingshan%20Loves%20Strings%E9%A2%98%E8%A7%A3/#_1","title":"\u9898\u610f\u7b80\u8ff0","text":"<p>\u7ed9\u5b9a\u4e24\u4e2a01\u5b57\u7b26\u4e32 $s,t$\uff0c\u4f60\u9700\u8981\u5728 $s$ \u4e4b\u4e2d\u63d2\u5165\u4efb\u610f\u4e2a\u5b57\u7b26\u4e32 $t$\uff0c\u4f7f\u5f97\u65b0\u7684\u5b57\u7b26\u4e32 $s$ \u4e2d\u76f8\u90bb\u7684\u4e24\u4e2a\u6570\u90fd\u4e0d\u540c\u3002</p>","tags":["CF","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1890B%20Qingshan%20Loves%20Strings%E9%A2%98%E8%A7%A3/#_2","title":"\u9898\u610f\u5206\u6790","text":"<p>\u7531\u4e8e\u5b57\u7b26\u4e32\u53ea\u6709 $0$ \u548c $1$\uff0c\u6240\u4ee5\u6700\u7ec8\u7684\u5b57\u7b26\u4e32\u4e00\u5b9a\u662f <code>01010101</code> \u6216 <code>10101010</code> \u7684\u5f62\u5f0f\u3002\u800c\u63d2\u5165\u7684\u5b57\u7b26\u4e32\u662f\u56fa\u5b9a\u7684\uff0c\u6240\u4ee5\u9996\u5148\u8003\u8651\u5b57\u7b26\u4e32 $s$\uff0c\u5982\u679c\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\u540c\u65f6\u51fa\u73b0 <code>11</code> \u548c <code>00</code> \u65f6\uff0c\u5b57\u7b26\u4e32\u4e00\u5b9a\u4e0d\u80fd\u201c\u53d8\u597d\u201d\u3002</p> <p>\u7136\u540e\u6211\u4eec\u8003\u8651\u5b57\u7b26\u4e32 $t$ \u7684\u5f62\u5f0f\uff0c\u5982\u679c\u5b57\u7b26\u4e32 $t$ \u672c\u8eab\u5c31\u4e0d\u7b26\u5408 $t_i \\ne t_{i+1}$ \u7684\u8bdd\uff0c\u4e5f\u662f\u4e0d\u53ef\u4ee5\u7684\u3002</p> <p>\u5982\u679c\u90fd\u5b57\u7b26\u4e32\u90fd\u7b26\u5408\u7684\u60c5\u51b5\u4e0b\uff0c\u4e0d\u96be\u53d1\u73b0\uff0c\u6211\u4eec\u53ea\u9700\u8981\u8bb0\u5f55\u5b57\u7b26\u4e32 $s$ \u4e2d\u5305\u62ec <code>00</code> \u8fd8\u662f <code>11</code>\uff0c\u7136\u540e\u4e0e\u5b57\u7b26\u4e32 $t$ \u7684\u4e24\u8fb9\u5224\u65ad\uff0c\u5982\u679c\u4e0d\u540c\uff0c\u5c31\u53ef\u4ee5\u6784\u6210\u3002\u5177\u4f53\u5224\u65ad\u89c1\u4ee3\u7801\u3002</p>","tags":["CF","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1890B%20Qingshan%20Loves%20Strings%E9%A2%98%E8%A7%A3/#code","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\nconst int MaxN = 1e6 + 100;\nconst int INF = 1e9;\nint T=1, N, M;\ntemplate&lt;class T&gt;\ninline void qread(T &amp;sum)\n{\n    sum=0;int boo=1;\n    char x=getchar();\n    while(x&lt;'0'||x&gt;'9'){if(x=='-')boo=-1;x=getchar();}\n    while(x&gt;='0'&amp;&amp;x&lt;='9'){sum=(sum&lt;&lt;1)+(sum&lt;&lt;3)+x-'0';x=getchar();}\n    sum*=boo;\n}\ntemplate&lt;class T&gt;\nvoid qput(T x)\n{\n    if(x&lt;0){\n        x=-x;\n        putchar('-');}\n    if(x&gt;9)\n        qput(x/10);\n    putchar(x%10+48);\n}\ninline void Solve()\n{\n    int n,m;\n    cin&gt;&gt;n&gt;&gt;m;\n\n    string s,t;\n    cin&gt;&gt;s&gt;&gt;t;\n\n    bool flag=0;\n    int cnt=-1;\n    for(int i=0;i&lt;n;i++){\n        if(s[i]==s[i+1]){\n            if(s[i]-'0'!=cnt&amp;&amp;cnt!=-1){\n                puts(\"No\");//\u5b57\u7b26\u4e32s\n                //cout&lt;&lt;cnt;\n                return;\n            }\n            cnt=s[i]-'0';\n            flag=1;\n\n        }\n    }\n\n    if(flag==0){\n        puts(\"Yes\");\n        return;\n    }\n    for(int i=0;i&lt;t.size();i++){\n        if(t[i]==t[i+1]){\n            puts(\"No\");//\u5b57\u7b26\u4e32t\n            return;\n        }\n    }\n    if(t[0]-'0'!=cnt&amp;&amp;t[m-1]-'0'!=cnt){\n        puts(\"Yes\");//\u5b57\u7b26\u4e32s\u548ct\u5224\u65ad\n        //cout&lt;&lt;cnt\n    }\n    else{\n        puts(\"No\");\n    }\n}\nsigned main()\n{\n    //freopen(\".in\", \"r\", stdin);\n    //freopen(\".out\", \"w\", stdout);\n    ios::sync_with_stdio(0);\n    //cin.tie(0);\n    cin &gt;&gt; T;\n    while (T--)\n        Solve();\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n\n</code></pre>","tags":["CF","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1988A-Split-the-Multiset-%E9%A2%98%E8%A7%A3/","title":"CF1988A","text":"","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1988A-Split-the-Multiset-%E9%A2%98%E8%A7%A3/#_1","title":"\u9898\u610f\u7b80\u8ff0","text":"<p>\u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6574\u6570 $n$\uff0c\u6bcf\u6b21\u53ef\u4ee5\u5c06\u5176\u62c6\u5206\u6210 $k$ \u4e2a\u6570\uff0c\u6c42\u5c06 $n$ \u53d8\u4e3a $n$ \u4e2a $1$ \u7684\u6700\u5c11\u64cd\u4f5c\u6b21\u6570\u3002</p>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1988A-Split-the-Multiset-%E9%A2%98%E8%A7%A3/#_2","title":"\u9898\u76ee\u5206\u6790","text":"<p>\u5bf9\u4e8e\u4e00\u4e2a\u6570 $n$\uff0c\u6211\u4eec\u6bcf\u6b21\u53ef\u4ee5\u5c06\u5176\u62c6\u5206\u4e3a $(k-1)$ \u4e2a $1$\uff0c\u548c $1$ \u4e2a $(n-k)$\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u66b4\u529b\u679a\u4e3e $n$ \u80fd\u88ab\u62c6\u5206\u51e0\u6b21\uff0c\u5c31\u53ef\u4ee5\u5f97\u51fa\u7b54\u6848\uff0c\u5177\u4f53\u89c1\u4e0b\uff1a</p> <p>\u5f53 $n=5,k=2$\u65f6\uff1a - $5$ - $1,4$ - $1,1,3$ - $1,1,1,2$ - $1,1,1,1,1$</p> <p>\u4e0d\u96be\u53d1\u73b0\u53ea\u9700\u8981\u6bcf\u6b21\u5c06 $n$ \u51cf\u53bb $k-1$\uff0c\u4e00\u76f4\u51cf\u5230 $n&lt;=1$\uff0c\u6b64\u65f6\u7684\u64cd\u4f5c\u6b21\u6570\u5373\u4e3a\u7b54\u6848\u3002</p>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1988A-Split-the-Multiset-%E9%A2%98%E8%A7%A3/#code","title":"Code","text":"<pre><code>#pragma GCC optimize(1, 2, 3, \"Ofast\", \"inline\")\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\n#define ONLINE_JUDGE\n#define MULTI_CASES\nconst int MaxN = 2e5+100;\nconst int INF = 1e9;\nint T=1, N, M;\nint a[MaxN];\nint ans=0;\ninline void Solve()\n{\n    cin&gt;&gt;N&gt;&gt;M;\n    if(N==1){\n        cout&lt;&lt;0&lt;&lt;endl;\n        return ;\n    }\n    ans=0;\n    for(int i=1;;i++){\n        N-=M-1;\n//      cout&lt;&lt;N&lt;&lt;endl;\n        ans++;\n        if(N&lt;=1){\n            break;\n        }\n    }\n    cout&lt;&lt;ans&lt;&lt;endl;\n}\nsigned main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(\".in\", \"r\", stdin);\n    freopen(\".out\", \"w\", stdout);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0),cout.tie(0);\n\n#ifdef MULTI_CASES\n    cin &gt;&gt; T;\n    while (T--)\n#endif\n        Solve();\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n</code></pre>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1988B-Make-Majority-%E9%A2%98%E8%A7%A3/","title":"CF1988B","text":"","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1988B-Make-Majority-%E9%A2%98%E8%A7%A3/#_1","title":"\u9898\u76ee\u5206\u6790","text":"<p>\u6839\u636e\u9898\u610f\uff0c\u6bcf\u6b21\u64cd\u4f5c\u53ef\u4ee5\u5c06 $[l,r]$ \u533a\u95f4\u7684\u6570\u53d8\u4e3a $1$ \u4e2a\u591a\u6570\uff0c\u8981\u6c42\u80fd\u5426\u8f6c\u5316\u4e3a $a=[1]$\u3002\u4e0d\u96be\u60f3\u51fa\uff0c\u6211\u4eec\u5e94\u8be5\u5c06\u5e8f\u5217\u4e2d $0$ \u7684\u4e2a\u6570\u964d\u4e3a\u6700\u4f4e\uff0c\u6240\u4ee5\u53ef\u4ee5\u5c06\u6bcf\u4e00\u6bb5\u8fde\u7eed\u7684 $0$ \u90fd\u8fdb\u884c\u64cd\u4f5c\u4f7f\u5f97\u6700\u540e\u7684\u65f6\u5019\u5e8f\u5217\u4e2d\u6240\u5305\u542b\u7684 $0$ \u6700\u5c11\uff0c\u7136\u540e\u53ea\u9700\u8981\u904d\u5386\u5e8f\u5217\u7edf\u8ba1 $c_0$ \u548c $c_1$ \u7684\u4e2a\u6570\uff0c\u6bd4\u8f83\u4e24\u6570\uff0c\u5982\u679c $c_1&gt;c_0$ \u5219\u4e3a<code>Yes</code>\u3002</p>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1988B-Make-Majority-%E9%A2%98%E8%A7%A3/#code","title":"Code","text":"<pre><code>//#pragma GCC optimize(1, 2, 3, \"Ofast\", \"inline\")\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\n#define ONLINE_JUDGE\n#define MULTI_CASES\nconst int MaxN = 2e5+100;\nconst int INF = 1e9;\nint T=1, N, M;\nint a[MaxN];\ninline void Solve()\n{\n    int N;\n    cin&gt;&gt;N;\n    string s;\n    cin&gt;&gt;s;\n    int xx[MaxN],n=0;\n//  memset(xx,0,sizeof xx);\n    bool f=0;\n    for(int i=0;i&lt;N;i++){\n//      cout&lt;&lt;f&lt;&lt;endl;\n//      cout&lt;&lt;s[i];\n        if(s[i]=='0'&amp;&amp;!f){\n            xx[n++]=0;//\u5c3d\u53ef\u80fd\u51cf\u5c110\u7684\u6570\u91cf\n            f=1;\n        }\n        else{\n            if(s[i]!='1'){\n                continue;\n            }\n            f=0;\n            xx[n++]=1;\n        }\n//      cout&lt;&lt;xx[n-1];\n    }\n    int sum0=0,sum1=0;\n    for(int i=0;i&lt;n;i++){\n        if(xx[i]==1){\n            sum1++;\n        }\n        else{\n            sum0++;\n        }\n    }\n//  cout&lt;&lt;sum0&lt;&lt;\" \"&lt;&lt;sum1&lt;&lt;endl;\n    if(sum0&gt;=sum1){\n        puts(\"No\");\n    }\n    else{\n        puts(\"Yes\");\n    }\n}\nsigned main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(\".in\", \"r\", stdin);\n    freopen(\".out\", \"w\", stdout);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0),cout.tie(0);\n\n#ifdef MULTI_CASES\n    cin &gt;&gt; T;\n    while (T--)\n#endif\n        Solve();\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n</code></pre>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1988C-Increasing-Sequence-with-Fixed-OR-%E9%A2%98%E8%A7%A3/","title":"CF1988C","text":"","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1988C-Increasing-Sequence-with-Fixed-OR-%E9%A2%98%E8%A7%A3/#_1","title":"\u9898\u610f\u7b80\u8ff0","text":"<p>\u7ed9\u5b9a\u4e00\u4e2a\u6b63\u6574\u6570 $n$\uff0c\u8981\u6784\u9020\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e3a $k$ \u7684\u4e25\u683c\u9012\u589e\u5e8f\u5217 $a$\uff0c\u4e14\u6bcf\u4e00\u9879 $a_i\\le n$\u3002\u8981\u6ee1\u8db3 $a_i|a_{i-1}=n$\u3002</p>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1988C-Increasing-Sequence-with-Fixed-OR-%E9%A2%98%E8%A7%A3/#_2","title":"\u9898\u76ee\u5206\u6790","text":"<p>\u8981\u4f7f\u5f97 $a_i|a_{i-1}=n$\uff0c\u6211\u4eec\u4e0d\u59a8\u5148\u627e\u627e\u89c4\u5f8b\uff1a</p> <p>\u5f53 $n=14$ \u65f6\uff0c\u53ef\u4ee5\u6784\u9020\u51fa\u4ee5\u4e0b\u6570\u636e\uff1a</p> <p>$a_1=6$</p> <p>$a_2=10$</p> <p>$a_3=12$</p> <p>$a_4=14$</p> <p>\u5c06\u5176\u8f6c\u5316\u4e3a \u4e8c\u8fdb\u5236\uff1a</p> <p>$0110$\\ $1010$\\ $1100$\\ $1110$</p> <p>\u901a\u8fc7\u89c2\u5bdf\u6b64\u6570\u636e\uff0c\u53ef\u4ee5\u53d1\u73b0\uff0c\u6784\u9020\u51fa\u7684\u6570\u5b57\u7684\u4e8c\u8fdb\u5236\u5b58\u5728\u89c4\u5f8b\uff0c\u5373\u5c06 $n$ \u4ece\u672b\u4f4d\u5f00\u59cb\u5c06\u6bcf\u4e2a $1$ \u90fd\u53bb\u9664\u4e00\u6b21\uff0c\u8fd9\u6837\u53ef\u4ee5\u4f7f\u5f97\u76f8\u90bb\u4e24\u4e2a\u6570\u7684\u5f02\u6216\u503c\u90fd\u4e3a $n$\u3002</p>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF1988C-Increasing-Sequence-with-Fixed-OR-%E9%A2%98%E8%A7%A3/#code","title":"Code","text":"<pre><code>#pragma GCC optimize(1, 2, 3, \"Ofast\", \"inline\")\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\n#define ONLINE_JUDGE\n #define MULTI_CASES\nconst int MaxN = 2e5+100;\nconst int INF = 1e9;\nint T=1, N, M;\nint a[MaxN];\nint Atoi(string s,int radix)    //s\u662f\u7ed9\u5b9a\u7684radix\u8fdb\u5236\u5b57\u7b26\u4e32\n{\n    int ans=0;\n    for(int i=0;i&lt;s.size();i++)\n    {\n        char t=s[i];\n        if(t&gt;='0'&amp;&amp;t&lt;='9') ans=ans*radix+t-'0';\n        else ans=ans*radix+t-'a'+10;\n    }\n    return ans;\n}\n//n\u662f\u5f85\u8f6c\u6362\u7684\u5341\u8fdb\u5236\u6570\uff0cm\u662f\u5f85\u8f6c\u6362\u6210\u7684\u8fdb\u5236\u6570 \nstring intToA(int n,int m){\n    string ans=\"\";\n    do{      //\u4f7f\u7528do{}while()\u5faa\u73af\u7c7b\u578b\u4ee5\u9632\u6b62\u8f93\u5165\u4e3a0\u7684\u60c5\u51b5\n        int t=n%m;\n        if(t&gt;=0&amp;&amp;t&lt;=9)    \n            ans+=(t+'0');\n        else \n            ans+=(t+'a'-10);\n        n/=m;\n    }while(n);   \n    reverse(ans.begin(),ans.end());\n    return ans;    \n}\n\ninline void Solve()\n{\n    cin&gt;&gt;N;\n//  char s1[MaxN];\n    string s;\n    s=intToA(N,2);\n\n    M=1;\n//  cout&lt;&lt;s&lt;&lt;endl;\n    for(int i=0;i&lt;s.size();i++){\n        if(s[i]=='1'){\n            M++;\n        }\n    }\n    if(M==2){\n        cout&lt;&lt;1&lt;&lt;endl&lt;&lt;N&lt;&lt;endl;\n        return;\n    }\n    cout&lt;&lt;M&lt;&lt;endl;\n    for(int i=0;i&lt;s.size();i++){\n        if(s[i]=='1'){\n            string str=s;\n            str[i]='0';\n            cout&lt;&lt;Atoi(str,2)&lt;&lt;\" \";\n        }\n    }\n    cout&lt;&lt;N&lt;&lt;endl;\n//  cout&lt;&lt;endl;\n//  cout&lt;&lt;s&lt;&lt;endl;\n}\nsigned main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(\".in\", \"r\", stdin);\n    freopen(\".out\", \"w\", stdout);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0),cout.tie(0);\n\n#ifdef MULTI_CASES\n    cin &gt;&gt; T;\n    while (T--)\n#endif\n        Solve();\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n</code></pre>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF2023B-CF2024D-Skipping-%E9%A2%98%E8%A7%A3/","title":"CF2023B/CF2024D","text":"","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF2023B-CF2024D-Skipping-%E9%A2%98%E8%A7%A3/#_1","title":"\u9898\u610f\u5206\u6790","text":"<p>\u9996\u5148\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u5728\u7b2c $i$ \u4e2a\u70b9\u4e0a\u65f6\uff0c\u6240\u5f97\u7684\u5f97\u5206\u4e3a\u4ece $1$ \u5230 $i$ \u4e4b\u548c\u51cf\u53bb\u8df3\u8fc7\u7684\u95ee\u9898\u3002\u6240\u4ee5\u6b64\u9898\u53ef\u4ee5\u8f6c\u5316\u4e3a\u6c42\u8df3\u8fc7\u7684\u9898\u76ee\u7684\u6700\u5c0f\u503c\u3002\u6240\u4ee5\u7b54\u6848\u5c31\u662f</p> <p>$$ans=\\max_{i=1}^{n}(sum_i-dis_i)$$</p> <p>\u5176\u4e2d\u7684 $sum_i$ \u8868\u793a\u4ece $1$ \u5230 $i$ \u7684\u524d\u7f00\u548c\uff0c$dis_i$ \u8868\u793a\u4ece $1$ \u5230 $i$ \u7684\u4ee3\u4ef7\u6700\u5c0f\u503c\u3002</p> <p>\u5173\u4e8e\u5982\u4f55\u6c42 $dis_i$\uff0c\u6211\u4eec\u53ef\u4ee5\u5efa\u56fe\u8dd1\u6700\u77ed\u8def\uff0c\u5bf9 $i\\rightarrow i-1$ \u5efa\u8fb9\uff0c\u6743\u503c\u4e3a $0$\uff0c\u5bf9 $i\\rightarrow b_i$ \u5efa\u8fb9\uff0c\u6743\u503c\u4e3a $a_i$\u3002\u4e4b\u540e\u901a\u8fc7\u6700\u77ed\u8def\u6c42\u51fa $dis_i$\uff0c\u7136\u540e\u679a\u4e3e\u7b54\u6848\u5373\u53ef\u3002</p>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF2023B-CF2024D-Skipping-%E9%A2%98%E8%A7%A3/#code","title":"Code","text":"<pre><code>#pragma GCC optimize(1, 2, 3, \"Ofast\", \"inline\")\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\n#define ONLINE_JUDGE\n#define MULTI_CASES\n#define endl '\\n'\nconst int MaxN = 4e5+100;\nconst int INF = 1e15;\nconst int mod=212370440130137957ll;\nint T=1, N, M;\n// int dis[MaxN];\nvector&lt;pair&lt;int,int&gt;&gt;G1[MaxN];\nstruct Dijkstra{\n    int d[MaxN], vis[MaxN];\n    struct Point {\n        int id, x;\n        inline bool operator&lt;(const Point &amp;aa)const {\n            return x &gt; aa.x;\n        }\n    };\n    priority_queue&lt;Point&gt;q;\n    inline void solve(int S) {\n        for(int i = 1; i &lt;= N; i++) d[i] = INF, vis[i] = 0;\n\n        d[S] = 0;\n        q.push((Point){ S, 0 });\n        while(!q.empty()) {\n            auto [x, w] = q.top(); q.pop();\n            if (vis[x]) continue;\n            vis[x] = 1;\n            for(auto it : G1[x]) {\n                int y = it.first;\n                int z = it.second;\n                if(d[x] + z &lt; d[y]) {\n                    d[y] = d[x] + z;\n                    if(!vis[y])  q.push((Point){ y, d[y] });\n                }\n            }\n        }\n    }\n};\ninline void Solve()\n{\n    cin&gt;&gt;N;\n    // vector&lt;pair&lt;int,int&gt;&gt; G1[MaxN];\n    vector&lt;int&gt;sum(N+1);\n    vector&lt;int&gt;a(N+1);\n    for(int i=1;i&lt;=N;i++){\n        cin&gt;&gt;a[i];\n        sum[i]=sum[i-1]+a[i];\n        if(i!=1)\n            G1[i+1].push_back(make_pair(i,0));\n    }\n    for(int i=1;i&lt;=N;i++){\n        int x;\n        cin&gt;&gt;x;\n        G1[i].push_back(make_pair(x,a[i]));\n    }\n    Dijkstra dij;\n    dij.solve(1);\n    int ans=0;\n    for(int i=1;i&lt;=N;i++){\n        // cout&lt;&lt;dij.d[i]&lt;&lt;\" \";\n        ans=max(ans,sum[i]-dij.d[i]);\n        G1[i].resize(0);\n    }\n    cout&lt;&lt;ans&lt;&lt;endl;\n}\nsigned main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(\".in\", \"r\", stdin);\n    freopen(\".out\", \"w\", stdout);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0),cout.tie(0);\n\n#ifdef MULTI_CASES\n    cin &gt;&gt; T;\n    while (T--)\n#endif\n       Solve();\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n</code></pre>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF2024A-Profitable-Interest-Rate-%E9%A2%98%E8%A7%A3/","title":"CF2024A","text":"","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF2024A-Profitable-Interest-Rate-%E9%A2%98%E8%A7%A3/#_1","title":"\u9898\u610f\u7b80\u8ff0","text":"<p>Alice\u6709 $a$ \u679a\u786c\u5e01\uff0c\u5979\u60f3\u8981\u5c06\u786c\u5e01\u5b58\u5165\u94f6\u884c\uff0c\u4f46\u662f\u5f00\u7acb\u5b58\u6b3e\u7684\u6700\u4f4e\u91d1\u989d\u4e3a $b$\uff0c\u5982\u679c\u91d1\u989d\u4e0d\u8db3\uff0c\u53ef\u4ee5\u82b1\u8d39 $x$ \u4e2a\u786c\u5e01\u4f7f\u5f97\u5b58\u6b3e\u7684\u6700\u4f4e\u91d1\u989d\u51cf\u5c11 $2x$\u3002\u6c42\u5b58\u5165\u94f6\u884c\u7684\u6700\u5927\u786c\u5e01\u6570\u91cf\u3002</p>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF2024A-Profitable-Interest-Rate-%E9%A2%98%E8%A7%A3/#_2","title":"\u9898\u610f\u5206\u6790","text":"<p>\u663e\u7136\uff0c\u5f53 $b\\le a$ \u65f6\uff0c\u53ef\u4ee5\u76f4\u63a5\u5c06 $a$ \u679a\u786c\u5e01\u5168\u90e8\u5b58\u5165\uff0c\u6240\u4ee5\u76f4\u63a5\u8f93\u51fa $a$ \u5373\u53ef\u3002</p> <p>\u53cd\u4e4b\uff0c\u5f53 $b&gt;a$ \u65f6\uff0c\u6211\u4eec\u9700\u8981\u82b1\u8d39\u786c\u5e01\u964d\u4f4e\u6700\u4f4e\u91d1\u989d\u3002\u4e0d\u96be\u53d1\u73b0\uff0c\u9898\u76ee\u8981\u6c42\u6700\u5927\u503c\uff0c\u4e14\u540c\u65f6\u7b26\u5408\u5355\u8c03\u6027\uff0c\u53ef\u4ee5\u4f7f\u7528\u4e8c\u5206\u7b54\u6848\u6765\u76f4\u63a5\u8ba1\u7b97\u3002\u7b54\u6848\u533a\u95f4\u8868\u793a\u5b58\u5165\u94f6\u884c\u7684\u786c\u5e01\u6570\u91cf $ans$\uff0c\u901a\u8fc7<code>check</code>\u5224\u65ad $ans$ \u4e0e $b-(a-ans)\\times 2$ \u7684\u5927\u5c0f\u5173\u7cfb\uff0c\u5982\u679c $ans\\ge b-(a-ans)\\times 2$\uff0c<code>check</code>\u5224\u65ad\u4e3a<code>true</code>\uff0c\u5c06\u5de6\u8fb9\u754c\u66f4\u65b0\u5373\u53ef\u3002</p>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF2024A-Profitable-Interest-Rate-%E9%A2%98%E8%A7%A3/#code","title":"Code","text":"<pre><code>#pragma GCC optimize(1, 2, 3, \"Ofast\", \"inline\")\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\n#define ONLINE_JUDGE\n#define MULTI_CASES\n#define endl '\\n'\nconst int MaxN = 2e5+100;\nconst int INF = 1e9;\nconst int mod=212370440130137957ll;\nint T=1, N, M;\nint a[MaxN];\nbool check(int x)\n{\n    if(x&gt;=M-(N-x)*2){\n        return 1;\n    }\n    return 0;\n}\ninline void Solve()\n{\n    cin&gt;&gt;N&gt;&gt;M;\n    if(N&gt;=M){\n        cout&lt;&lt;N&lt;&lt;endl;\n    }\n    else{\n        int l=0,r=N;\n        while(l&lt;r){\n            int mid=(l+r+1)&gt;&gt;1;\n            if(check(mid)){\n                l=mid;\n            }\n            else{\n                r=mid-1;\n            }\n        }\n        cout&lt;&lt;l&lt;&lt;endl;\n    }\n}\nsigned main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(\".in\", \"r\", stdin);\n    freopen(\".out\", \"w\", stdout);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0),cout.tie(0);\n\n#ifdef MULTI_CASES\n    cin &gt;&gt; T;\n    while (T--)\n#endif\n       Solve();\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n\n</code></pre>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF2024B-Buying-Lemonade-%E9%A2%98%E8%A7%A3/","title":"CF2024B","text":"","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF2024B-Buying-Lemonade-%E9%A2%98%E8%A7%A3/#_1","title":"\u9898\u610f\u7b80\u8ff0","text":"<p>\u7ed9\u5b9a $n$ \u4e2a\u6309\u94ae\uff0c\u6bcf\u4e2a\u6309\u94ae\u5bf9\u5e94 $a_i$ \u74f6\u67e0\u6aac\u6c34\uff0c\u4f60\u4e0d\u6e05\u695a\u54ea\u4e2a\u6309\u94ae\u5bf9\u5e94\u54ea\u4e2a $a_i$\uff0c\u6309\u4e0b\u6309\u94ae\u540e\uff0c\u5982\u679c\u6709\u67e0\u6aac\u6c34\u5c31\u4f1a\u6389\u843d\u4e00\u74f6\uff0c\u53cd\u4e4b\u5219\u6ca1\u6709\u4efb\u4f55\u4e1c\u897f\u3002\u6c42\u81f3\u5c11\u6309\u591a\u5c11\u6b21\u6309\u94ae\u53ef\u4ee5\u4fdd\u8bc1\u81f3\u5c11\u6536\u5230 $k$ \u74f6\u67e0\u6aac\u6c34\u3002</p>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF2024B-Buying-Lemonade-%E9%A2%98%E8%A7%A3/#_2","title":"\u9898\u610f\u5206\u6790","text":"<p>\u9996\u5148\u9898\u76ee\u8981\u6c42\u4fdd\u8bc1\u81f3\u5c11\u6536\u5230 $k$ \u74f6\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u6700\u574f\u7684\u60c5\u51b5\uff1a\u6bcf\u6b21\u9009\u62e9\u4e00\u4e2a\u6309\u94ae\u65f6\u90fd\u4f1a\u9009\u62e9\u5230\u5bb9\u91cf\u6700\u5c11\u7684\u90a3\u4e2a\u3002</p> <p>\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u4e0d\u53ef\u907f\u514d\u7684\u6bcf\u4e2a\u6309\u94ae\u591a\u6309\u4e00\u6b21\u3002\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u8d2a\u5fc3\u3002\u9996\u5148\u53ef\u4ee5\u5c06 $a_i$ \u6392\u5e8f\uff0c\u7136\u540e\u4ece\u5c0f\u5230\u5927\u4f9d\u6b21\u66f4\u65b0\u83b7\u53d6\u5230\u7684\u67e0\u6aac\u6c34\u6570\u91cf\uff0c\u540c\u65f6\u6bcf\u6b21\u5c06\u64cd\u4f5c\u6b21\u6570\u591a\u52a0 $1$\u3002\u663e\u7136\u8fd9\u6837\u4e0d\u662f\u6700\u4f18\uff0c\u6240\u4ee5\u5728\u66f4\u65b0\u8fc7\u7a0b\u4e2d\u8003\u8651\uff0c\u7531\u4e8e\u6bcf\u6b21\u8bfb\u53d6\u7684\u90fd\u6bd4\u4e4b\u540e\u7684\u5c0f\uff0c\u6240\u4ee5\u5982\u679c\u5f53\u524d\u7684\u503c\u4e58\u4e0a\u5269\u4f59\u7684\u6309\u94ae\u6570\u91cf\u518d\u52a0\u4e0a\u5df2\u7ecf\u83b7\u5f97\u7684\u67e0\u6aac\u6c34\u6570\u91cf\u4e4b\u548c\u5927\u4e8e\u7b49\u4e8e $k$\uff0c\u5c31\u76f4\u63a5\u52a0\u4e0a $k$\uff0c\u51cf\u53bb\u5df2\u83b7\u5f97\u7684\u67e0\u6aac\u6c34\u6570\u91cf\u5c31\u662f\u7b54\u6848\u3002</p> <p>\u5f62\u5f0f\u5316\u7684\u8bf4\uff0c\u8bbe\u64cd\u4f5c\u6b21\u6570\u4e3a $cnt$\uff0c\u7b54\u6848\u4e3a $ans$\uff0c</p> <p>\u5219\u5bf9\u4e8e $1\\le i\\le n$\uff0c\u82e5$ans+(n-i+1)\\times a_i&lt;k,ans=ans+a_i,cnt=cnt+a_i+1$\u3002</p> <p>\u82e5 $ans+(n-i+1)\\times a_i\\ge k, cnt=cnt+k-ans$ \u6b64\u65f6\u7684 $cnt$ \u5c31\u662f\u7b54\u6848\u3002</p>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF2024B-Buying-Lemonade-%E9%A2%98%E8%A7%A3/#code","title":"Code","text":"<pre><code>#pragma GCC optimize(1, 2, 3, \"Ofast\", \"inline\")\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\n#define ONLINE_JUDGE\n#define MULTI_CASES\n#define endl '\\n'\nconst int MaxN = 2e5+100;\nconst int INF = 1e9;\nconst int mod=212370440130137957ll;\nint T=1, N, M;\nint a[MaxN];\ninline void Solve()\n{\n    cin&gt;&gt;N&gt;&gt;M;\n    for(int i=1;i&lt;=N;i++){\n        cin&gt;&gt;a[i];\n    }\n    sort(a+1,a+N+1);\n    if(M&lt;=N){\n        cout&lt;&lt;M&lt;&lt;endl;\n        return;\n    }\n    int ans=0,cnt=0;\n    for(int i=1;i&lt;=N;i++){\n        if(cnt+(N-i+1)*a[i]&gt;=M){\n            ans+=M-cnt;\n            cout&lt;&lt;ans&lt;&lt;endl;return;\n        }\n        cnt+=a[i];\n        ans+=a[i]+1;\n    }\n    cout&lt;&lt;ans&lt;&lt;endl;\n}\nsigned main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(\".in\", \"r\", stdin);\n    freopen(\".out\", \"w\", stdout);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0),cout.tie(0);\n\n#ifdef MULTI_CASES\n    cin &gt;&gt; T;\n    while (T--)\n#endif\n       Solve();\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n\n</code></pre>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF2024C-Concatenation-of-Arrays-%E9%A2%98%E8%A7%A3/","title":"CF2024C","text":"","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF2024C-Concatenation-of-Arrays-%E9%A2%98%E8%A7%A3/#_1","title":"\u9898\u610f\u7b80\u8ff0","text":"<p>\u7ed9\u5b9a $n$ \u4e2a\u4e8c\u7ef4\u6570\u7ec4\uff0c\u6bcf\u4e2a  \u6570\u7ec4\u7684\u957f\u5ea6\u4e3a $2$\uff0c\u5c06\u8fd9 $n$ \u4e2a\u6570\u7ec4\u8fde\u63a5\u8d77\u6765\uff0c\u8981\u4f7f\u5f97\u6570\u7ec4\u4e2d\u7684\u9006\u5e8f\u5bf9\u6570\u91cf\u5c3d\u53ef\u80fd\u7684\u5c11\u3002</p>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF2024C-Concatenation-of-Arrays-%E9%A2%98%E8%A7%A3/#_2","title":"\u9898\u610f\u5206\u6790","text":"<p>\u9898\u76ee\u8981\u6c42\u6392\u5217\u6570\u7ec4\u4f7f\u5f97\u9006\u5e8f\u5bf9\u5c3d\u53ef\u80fd\u5c11\uff0c\u5bf9\u4e8e\u5176\u4e2d\u4e00\u4e2a\u6570\u7ec4\uff0c\u5176\u53ef\u80fd\u8d21\u732e\u7684\u9006\u5e8f\u5bf9\u6570\u91cf\u4e3a\u6bd4 $a_{i,1}$ \u5c0f\u7684\u4e2a\u6570 $x$\uff0c\u52a0\u4e0a\u6bd4 $a_{i,2}$ \u5c0f\u7684\u4e2a\u6570 $y$\uff0c\u8bbe $cnt_i$ \u4e3a $x+y$\uff0c\u4e4b\u540e\u53ea\u9700\u8981\u5bf9\u6570\u7ec4 $cnt$ \u6392\u5e8f\u8f93\u51fa\u7ed3\u679c\u5373\u53ef\u3002</p> <p>\u6ce8\u610f\uff0c\u53ea\u8981 $a_{i,1}$ \u548c $a_{i,2}$ \u4e0d\u76f8\u540c\uff0c\u5f97\u51fa\u7684\u7ed3\u679c\u5e94\u8be5\u51cf\u53bb $1$\uff0c\u8fd9\u662f\u56e0\u4e3a\u5fc5\u7136\u4f1a\u6709\u4e00\u4e2a\u6570\u6bd4\u53e6\u4e00\u4e2a\u6570\u5c0f\uff0c\u6240\u4ee5\u8981\u6392\u9664\u6389\u3002</p> <p>\u5173\u4e8e\u6c42\u89e3\u6bd4\u5f53\u524d\u6570\u5c0f\u7684\u4e2a\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e8c\u5206\u67e5\u627e\u51fd\u6570<code>lower_bound</code>\u6765\u6c42\u89e3\u3002</p>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/CF2024C-Concatenation-of-Arrays-%E9%A2%98%E8%A7%A3/#code","title":"Code","text":"<pre><code>#pragma GCC optimize(1, 2, 3, \"Ofast\", \"inline\")\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\n#define ONLINE_JUDGE\n#define MULTI_CASES\n#define endl '\\n'\nconst int MaxN = 2e5+100;\nconst int INF = 1e9;\nconst int mod=212370440130137957ll;\nint T=1, N, M;\n// int a[MaxN];\nstruct node{\n    int x,y;\n    int id;\n}a[MaxN];\nbool cmp1(node a,node b){\n    return min(a.x,a.y)&lt;min(b.x,b.y);\n}\nbool cmp2(node a,node b){\n    return max(a.x,a.y)&gt;max(b.x,b.y);\n}\nbool cmp(node a,node b){\n    return a.id&lt;b.id;\n}\nint cnt[MaxN];\ninline void Solve()\n{\n    cin&gt;&gt;N;\n    for(int i=1;i&lt;=N;i++){\n        cin&gt;&gt;a[i].x&gt;&gt;a[i].y;\n        a[i].id=i;\n    }\n    vector&lt;int&gt;b;\n    for(int i=1;i&lt;=N;i++){\n        b.push_back(a[i].x);\n        b.push_back(a[i].y);\n    }\n    sort(b.begin(),b.end());\n    for(int i=1;i&lt;=N;i++){\n        if(a[i].x&lt;a[i].y){\n            int x=lower_bound(b.begin(),b.end(),a[i].x)-b.begin();\n            int y=lower_bound(b.begin(),b.end(),a[i].y)-b.begin()-1;\n            cnt[i]=x+y;\n        }   \n        else{\n            if(a[i].x&gt;a[i].y){\n                int x=lower_bound(b.begin(),b.end(),a[i].x)-b.begin()-1;\n                int y=lower_bound(b.begin(),b.end(),a[i].y)-b.begin();\n                cnt[i]=x+y; \n            }\n            else{\n                int x=lower_bound(b.begin(),b.end(),a[i].x)-b.begin();\n                int y=lower_bound(b.begin(),b.end(),a[i].y)-b.begin();\n                cnt[i]=x+y; \n            }\n        }\n    }\n    for(int i=1;i&lt;=N;i++){\n        a[i].id=cnt[i];\n    }\n    sort(a+1,a+N+1,cmp);\n    for(int i=1;i&lt;=N;i++){\n        cout&lt;&lt;a[i].x&lt;&lt;\" \"&lt;&lt;a[i].y&lt;&lt;\" \";\n    }\n    cout&lt;&lt;endl;\n}\nsigned main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(\".in\", \"r\", stdin);\n    freopen(\".out\", \"w\", stdout);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0),cout.tie(0);\n\n#ifdef MULTI_CASES\n    cin &gt;&gt; T;\n    while (T--)\n#endif\n       Solve();\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n\n</code></pre>","tags":["\u9898\u89e3","CF"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/Luogu-P1570-%E9%A2%98%E8%A7%A3/","title":"P1570 \u9898\u89e3","text":"","tags":["Luogu","\u9898\u89e3","\u4e8c\u5206"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/Luogu-P1570-%E9%A2%98%E8%A7%A3/#_1","title":"\u9898\u76ee\u5206\u6790","text":"<p>\u521a\u5f00\u59cb\u505a\u8fd9\u9053\u9898\u53ef\u80fd\u6ca1\u4ec0\u4e48\u601d\u8def\uff0c\u6240\u4ee5\u6211\u4eec\u5148\u4ece\u5f0f\u5b50\u5165\u624b\uff1a</p> <p>\u5047\u8bbe\u5b58\u5728\u6700\u4f18\u89e3ans\uff1a$ans=\\frac{\\sum v_i}{\\sum c_i}$</p> <p>\u8f6c\u5316\u5f97 $ans\\times\\sum c_i=\\sum v_i$</p> <p>\u79fb\u9879\u5f97 $ans\\times \\sum c_i-\\sum v_i=0$</p> <p>\u53ef\u89c1\uff0c\u5f53\u5f0f\u5b50\u7684\u7ed3\u679c\u8d8b\u5411 $ 0$ \u65f6\uff0cans\u662f\u6700\u4f18\u89e3\u3002</p> <p>\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u8bbe $f(ans)=ans\\times\\sum c_i-\\sum v_i$</p> <p>\u663e\u7136\uff0c$f(ans)$\u662f\u4e00\u4e2a\u4e00\u6b21\u51fd\u6570\uff0c\u5177\u6709\u5355\u8c03\u6027\u3002\u8fd9\u4e2a\u65f6\u5019\u5c31\u4f1a\u60f3\u5230\u53ef\u4ee5\u4f7f\u7528\u4e8c\u5206\u7b54\u6848\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002</p> <p>\u65e2\u7136\u4f7f\u7528\u4e8c\u5206\u7b54\u6848\u6765\u89e3\u51b3\uff0c\u9996\u5148\u5e94\u8be5\u8003\u8651\u8fb9\u754c\u95ee\u9898\uff0c\u8fd9\u9053\u9898\u7684\u8fb9\u754c\u6bd4\u8f83\u597d\u8bbe\u5b9a\uff0c\u5de6\u7aef\u70b9\u663e\u7136\u4e3a$ 0$\uff0c\u800c\u53f3\u7aef\u70b9\u7684\u8bbe\u5b9a\uff0c\u6211\u4eec\u79c9\u6301\u7740\u4e0d\u6015\u5927\u53ea\u6015\u5c0f\u7684\u539f\u5219\uff0c\u53ef\u4ee5\u5c06\u5176\u8bbe\u5b9a\u4e3a$\\sum v_i$\u3002</p> <p>\u7136\u540e\u8003\u8651check\u51fd\u6570\u95ee\u9898\uff0c\u601d\u8003\u4e4b\u540e\u53ef\u4ee5\u53d1\u73b0\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5224\u65ad\u5728ans\u786e\u5b9a\u7684\u60c5\u51b5\u4e0b\uff0c\u6700\u4f18\u7684\u53d6\u6cd5\u3002\u6240\u4ee5\u8003\u8651\u8d2a\u5fc3\uff0c\u628a\u6bcf\u79cd\u8c03\u6599\u7684$f(ans)$\u8ba1\u7b97\u51fa\u6765\uff0c\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\u4e4b\u540e\u53d6\u524d$m$\u4e2a\u8c03\u6599\u7684\u4e00\u6b21\u51fd\u6570\u503c\u5e76\u7d2f\u52a0\u3002\u8ba1\u7b97\u4e4b\u540e\u7684\u6570\u503c\u4e0e\u96f6\u76f8\u6bd4\u8f83\uff0c\u5982\u679c\u5c0f\u4e8e\u96f6\u7684\u8bdd\uff0c\u8bf4\u660e$ans$\u8fd8\u53ef\u4ee5\u66f4\u5927\uff0c\u53cd\u4e4b\u5219\u5e94\u8be5\u66f4\u5c0f\u3002</p> <p>\u5230\u8fd9\u91cc\uff0c\u8fd9\u9053\u9898\u76ee\u5c31ac\u4e86\uff0c\u8981\u6ce8\u610f\u597d\u7ec6\u8282\u95ee\u9898\u3002</p> <pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define int long long \nint n,m,cnt=0;;\nstruct coffee{\n    int v,c;\n    double tot;\n}a[10010];\nvoid read(){\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=1;i&lt;=n;i++){\n        cin&gt;&gt;a[i].v;cnt+=a[i].v;\n    }\n    for(int i=1;i&lt;=n;i++){\n        cin&gt;&gt;a[i].c;\n    }\n}\nbool cmp(coffee a,coffee b){\n    return a.tot&lt;b.tot;\n}\nbool check(double x){\n    for(int i=1;i&lt;=n;i++){\n        a[i].tot=x*a[i].c-a[i].v;\n    }\n    double sum=0;\n    sort(a+1,a+n+1,cmp);\n    for(int i=1;i&lt;=m;i++){\n        sum+=a[i].tot;\n    }\n    return sum&lt;=0;\n}\ndouble search(){\n    double l=0,r=cnt;\n    while(r-l&gt;=1e-5){\n        double mid=(l+r)/2.0;\n        //cout&lt;&lt;mid&lt;&lt;endl;\n        if(check(mid)){\n            l=mid;\n        }\n        else{\n            r=mid;\n        }\n    }\n    return l;\n}\nsigned main(){\n    read();\n    double ans=search();\n    printf(\u201c%.3lf\u201d,ans);\n    return 0;\n}\n</code></pre>","tags":["Luogu","\u9898\u89e3","\u4e8c\u5206"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/Luogu-P5686-%E9%A2%98%E8%A7%A3/","title":"\u9898\u76ee\u5206\u6790","text":"","tags":["Luogu","\u9898\u89e3","\u524d\u7f00\u548c"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/Luogu-P5686-%E9%A2%98%E8%A7%A3/#40pts","title":"40pts\u505a\u6cd5","text":"<p>$40$ \u5206\u505a\u6cd5\u5341\u5206\u7b80\u5355\uff0c\u5c06\u5f0f\u5b50\u4ee3\u5165\u6a21\u62df\u5373\u53ef\uff0c\u590d\u6742\u5ea6 $O(n^3)$\u3002</p>","tags":["Luogu","\u9898\u89e3","\u524d\u7f00\u548c"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/Luogu-P5686-%E9%A2%98%E8%A7%A3/#70pts","title":"70pts\u505a\u6cd5","text":"<p>\u6211\u4eec\u53ef\u4ee5\u89c2\u5bdf\u5230\uff0c$S(l,r)$ \u7684\u503c\u53ef\u4ee5\u901a\u8fc7\u524d\u7f00\u548c\u9884\u5904\u7406\uff0c\u4ece\u800c\u964d\u4f4e\u65f6\u95f4\u590d\u6742\u5ea6\u81f3 $O(n^2)$\u3002</p>","tags":["Luogu","\u9898\u89e3","\u524d\u7f00\u548c"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/Luogu-P5686-%E9%A2%98%E8%A7%A3/#100pts","title":"100pts\u505a\u6cd5","text":"<p>\u901a\u8fc7\u4f8b\u5b50\u6765\u89e3\u91ca\uff1a</p> <p>\u5f53 $n=3$ \u65f6\uff1a</p> <p>$$\\sum_{l=1}^{n}\\sum_{r=l}^{n}S(l,r)=S(1,1)+s(1,2)+S(1,3)+S(2,2)+S(2,3)+S(3,3)$$</p> <p>$S(1,1) = A_1\\times B_1$</p> <p>$S(1,2) = A_2\\times B_2$</p> <p>$S(1,3) = A_3\\times B_3$</p> <p>$S(2,2) = (A_2 - A_1)\\times (B_2-B_1)$</p> <p>$S(2,3) = (A_3 - A_1)\\times (B_3-B_1)$</p> <p>$S(3,3) = (A_3 - A_2)\\times (B_3-B_2)$</p> <p>\u6211\u4eec\u5c06\u5176\u5168\u90e8\u76f8\u52a0\uff0c\u7ecf\u8fc7\u5316\u7b80\u53ef\u5f97\u6700\u7ec8\u5f0f\u5b50:</p> <p>$$\\sum_{l=1}^{n}\\sum_{r=l}^{n}S(l,r)=(n+1)\\sum_{i=1}^{N}(A_i\\times B_i)-\\sum_{i=1}^{n}A_i\\times\\sum_{i=1}^{n}B_i$$</p>","tags":["Luogu","\u9898\u89e3","\u524d\u7f00\u548c"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/Luogu-P9455-%E5%85%A5%E9%97%A8%E8%B5%9B-14-%E5%A1%94%E5%8F%B0%E8%B6%85%E9%A2%91-Hard-Version-%E9%A2%98%E8%A7%A3/","title":"Luogu-P9455-\u5165\u95e8\u8d5b-14-\u5854\u53f0\u8d85\u9891-Hard-Version-\u9898\u89e3","text":"<p>\u770b\u5230\u8ba8\u8bba\u533a\u90fd\u662f\u4e8c\u5206\uff0c\u5b9e\u9645\u4e0a\u8fd9\u9053\u9898\u7528\u8d2a\u5fc3\u6765\u5199\u975e\u5e38\u7b80\u5355</p>","tags":["\u9898\u89e3","Luogu"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/Luogu-P9455-%E5%85%A5%E9%97%A8%E8%B5%9B-14-%E5%A1%94%E5%8F%B0%E8%B6%85%E9%A2%91-Hard-Version-%E9%A2%98%E8%A7%A3/#_1","title":"\u9898\u76ee\u5206\u6790","text":"<p>\u9996\u5148\u5c06\u5f53\u524d\u5854\u53f0\u7684\u4f4d\u7f6e\u52a0\u4e0a\u901a\u8baf\u8ddd\u79bb\uff08\u5373 $a+b$ \uff09\u770b\u4f5c\u4e3a\u53f3\u8fb9\u754c\uff0c\u901a\u8fc7\u9898\u76ee\u4e0d\u96be\u5f97\u51fa\u4e00\u4e2a\u8d2a\u5fc3\u7b56\u7565\uff1a\u5982\u679c\u5f53\u524d\u5854\u53f0 $i$ \u80fd\u5230\u8fbe\u7684\u6700\u53f3\u8fb9\u754c\u6bd4\u5f80\u540e\u7684\u5854\u53f0 $i+m$ \u4f4d\u7f6e\u8fd8\u8981\u9760\u53f3\uff0c\u5c31\u53ef\u4ee5\u5ffd\u7565\u5854\u53f0 $i+1$ \u5230 $i+m$\u3002\u8f6c\u5316\u4e00\u4e0b\uff0c\u6211\u4eec\u53ea\u9700\u8981\u6bcf\u6b21\u8bb0\u5f55\u53ef\u4ee5\u5230\u8fbe\u7684\u6700\u53f3\u8fb9\u754c\uff0c\u5982\u679c\u5f53\u524d\u5854\u53f0\u7684\u4f4d\u7f6e\u4e0d\u5728\u6700\u53f3\u8fb9\u754c\u7684\u8303\u56f4\u5185\uff0c\u5c31\u53ef\u4ee5\u66f4\u65b0\u7b54\u6848\u53d6\u8d85\u9891\u7684\u6700\u5927\u503c\u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u7528 $ans$ \u6765\u50a8\u5b58\u7b54\u6848\uff0c$r$ \u4f5c\u4e3a\u6700\u53f3\u8fb9\u754c\uff0c\u8ba1\u7b97\u8fc7\u7a0b\u5c31\u662f\uff1a</p> <pre><code>if(a[i]&gt;r)\n{\n    k=max(a[i]-r,k);\n}\nr=max(r,a+b);\n</code></pre> <p>\u56e0\u4e3a\u662f\u9010\u4e2a\u5904\u7406\uff0c\u6240\u4ee5\u5728\u8f93\u5165\u65f6\u5c31\u53ef\u4ee5\u5b8c\u6210\u8ba1\u7b97\uff0c\u4ee3\u7801\u91cf\u6781\u5c11\u3002</p>","tags":["\u9898\u89e3","Luogu"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/Luogu-P9455-%E5%85%A5%E9%97%A8%E8%B5%9B-14-%E5%A1%94%E5%8F%B0%E8%B6%85%E9%A2%91-Hard-Version-%E9%A2%98%E8%A7%A3/#code","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nint a, b, c, n, r, ans;\nint main(){\n    cin &gt;&gt; n;\n    for (int i=0;i&lt;n;i++){\n        cin&gt;&gt;a&gt;&gt;b;\n        if(a&gt;r&amp;&amp;i){\n            ans=max(ans,a-r);\n        }\n        r=max(r,a+b);\n    }\n    cout&lt;&lt;ans;\n    return 0;\n}\n</code></pre>","tags":["\u9898\u89e3","Luogu"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/P9586-%E6%B8%B8%E6%88%8F-%E9%A2%98%E8%A7%A3/","title":"P9586 \u6e38\u620f \u9898\u89e3","text":"","tags":["Luogu","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/P9586-%E6%B8%B8%E6%88%8F-%E9%A2%98%E8%A7%A3/#_1","title":"\u5206\u6790","text":"<p>\u4e00\u9053\u7b80\u5355\u7684\u6a21\u62df\u9898\uff0c\u8003\u573a\u5f88\u5feb\u60f3\u51fa\u6b63\u89e3\u3002</p> <p>\u7136\u540e\u8003\u8651\u5c0fC\u83b7\u80dc\u7684\u60c5\u51b5\uff1a\u5c0fC\u60f3\u8981\u83b7\u80dc\uff0c\u4f5c\u4e3a\u5148\u624b\uff0c\u53ea\u6709\u81ea\u5df1\u7684\u6740\u6bd4\u5c0fD\u7684\u95ea\u8981\u591a\uff0c\u6216\u8005\u81ea\u5df1\u7684\u65a9\u6bd4\u5c0fD\u7684\u6740\u8981\u591a\u65f6.\u4ed6\u662f\u4e00\u5b9a\u80fd\u83b7\u80dc\u7684\u3002\u5373 $sha_1&gt;shan_2$ \u6216 $zhan_1&gt;sha_2$ \u65f6\uff0c\u5c0fC\u83b7\u80dc\u3002</p> <p>\u9996\u5148\u5206\u6790\u9898\u610f\uff0c\u4e0d\u96be\u53d1\u73b0\uff1a\u6740\u4e0e\u95ea\u662f\u514b\u5236\u5173\u7cfb\uff0c\u65a9\u548c\u6740\u662f\u514b\u5236\u5173\u7cfb\u3002</p> <p>\u63a5\u4e0b\u6765\u8003\u8651\u5c0fD\u83b7\u80dc\u7684\u60c5\u51b5\uff1a\u5728\u5c0fC\u7b2c\u4e00\u8f6e\u4e0d\u80fd\u83b7\u80dc\u540e\uff0c\u5c0fC\u80fd\u505a\u7684\u6700\u4f18\u7b56\u7565\u5c31\u662f\u5c3d\u53ef\u80fd\u7684\u6d88\u8017\u5c0fD\u7684\u724c\u3002\u5982\u679c\u6d88\u8017\u5b8c\u4e4b\u540e\uff0c\u5c0fD\u7684\u6740\u4f9d\u7136\u6bd4\u5c0fC\u7684\u95ea\u8981\u591a\uff0c\u6216\u8005\u81ea\u5df1\u7684\u65a9\u6bd4\u5c0fC\u7684\u6740\u8981\u591a\u65f6\uff0c\u5c0fD\u83b7\u80dc\u3002</p> <p>\u5982\u679c\u4e24\u79cd\u60c5\u51b5\u90fd\u4e0d\u6ee1\u8db3\uff0c\u90a3\u5c31\u662f\u5e73\u5c40\u4e86\u3002</p>","tags":["Luogu","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/P9586-%E6%B8%B8%E6%88%8F-%E9%A2%98%E8%A7%A3/#code","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\nconst int MaxN = 1e6 + 100;\nconst int INF = 1e9;\nint T=1, N, M;\n\ninline void Solve()\n{\n    int sha1,shan1,zhan1,sha2,zhan2,shan2;\n    cin&gt;&gt;sha1&gt;&gt;shan1&gt;&gt;zhan1&gt;&gt;sha2&gt;&gt;shan2&gt;&gt;zhan2;\n    if(sha1&gt;shan2||zhan1&gt;sha2){//\u5c0fC Win\n        puts(\"C\");\n    }\n    else{\n        shan2-=sha1;\n        sha2-=zhan1;\n        if(sha2&gt;shan1||zhan2&gt;sha1){//\u5c0fD Win\n            puts(\"D\");\n        }\n        else{\n            puts(\"E\");//\u5e73\u5c40\n        }\n    }\n}\nsigned main()\n{\n    //freopen(\".in\", \"r\", stdin);\n    //freopen(\".out\", \"w\", stdout);\n    ios::sync_with_stdio(0);\n    cin&gt;&gt;T;\n    while(T--)\n        Solve();\n    return 0;\n}\n\n</code></pre>","tags":["Luogu","\u9898\u89e3"]},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/%E4%BA%8C%E5%88%86%E8%AE%AD%E7%BB%83%E9%A2%98%E8%A7%A3/","title":"\u6a21\u677f","text":""},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/%E4%BA%8C%E5%88%86%E8%AE%AD%E7%BB%83%E9%A2%98%E8%A7%A3/#_2","title":"\u624b\u5199","text":""},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/%E4%BA%8C%E5%88%86%E8%AE%AD%E7%BB%83%E9%A2%98%E8%A7%A3/#1","title":"\u6a21\u677f1","text":"<pre><code>//\u5f80\u5de6\u627e\u7b54\u6848\nwhile(l&lt;r){\n    int mid=l+r&gt;&gt;1;//(l+r)/2\n    if(check(mid)){\n        r=mid;\n    }\n    else{\n        l=mid+1;\n    }\n}\n\n</code></pre>"},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/%E4%BA%8C%E5%88%86%E8%AE%AD%E7%BB%83%E9%A2%98%E8%A7%A3/#2","title":"\u6a21\u677f2","text":"<pre><code>//\u5f80\u53f3\u627e\u7b54\u6848\nwhile(l&lt;r){\n    int mid=l+r+1&gt;&gt;1;//(l+r+1)/2\n    if(check(mid)){\n        l=mid;\n    }\n    else{\n        r=mid-1;\n    }\n}\n</code></pre>"},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/%E4%BA%8C%E5%88%86%E8%AE%AD%E7%BB%83%E9%A2%98%E8%A7%A3/#3","title":"\u6a21\u677f3","text":"<pre><code>while(r-l&lt;1e-5){//\u6ce8\u610f\u6240\u6709\u7c7b\u578b\u90fd\u4e3adouble\n    double mid=(l+r)/2;\n    if(check(mid)){\n        l=mid;\n    }\n    else{\n        r=mid;\n    }\n}\n</code></pre>"},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/%E4%BA%8C%E5%88%86%E8%AE%AD%E7%BB%83%E9%A2%98%E8%A7%A3/#_3","title":"\u4e8c\u5206\u67e5\u627e\u51fd\u6570","text":"<p>\u67e5\u627e\u9996\u4e2a\u4e0d\u5c0f\u4e8e\u7ed9\u5b9a\u503c\u7684\u5143\u7d20\uff1a<code>lower_bound</code>\uff1a</p> <p>\u4f7f\u7528\u65f6\u76f4\u63a5\u8c03\u7528 <code>lower_bound( ForwardIt first, ForwardIt last, const T&amp; value );</code>\uff0c\u4f7f\u7528\u65f6\u5fc5\u987b\u4fdd\u8bc1\u6570\u7ec4\u6709\u5e8f\u3002</p> <p>\u5982\u679c\u6ca1\u6709\u627e\u5230\uff0c\u8fd4\u56de <code>last</code></p> <p>\u67e5\u627e\u9996\u4e2a\u5927\u4e8e\u7ed9\u5b9a\u503c\u7684\u5143\u7d20\uff1a <code>upper_bound</code>\uff1a</p> <p>\u4f7f\u7528\u65f6\u76f4\u63a5\u8c03\u7528 <code>upper_bound( ForwardIt first, ForwardIt last, const T&amp; value );</code>\uff0c\u4f7f\u7528\u65f6\u5fc5\u987b\u4fdd\u8bc1\u6570\u7ec4\u6709\u5e8f\u3002</p> <p>\u5982\u679c\u6ca1\u6709\u627e\u5230\uff0c\u8fd4\u56de <code>last</code></p>"},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/%E4%BA%8C%E5%88%86%E8%AE%AD%E7%BB%83%E9%A2%98%E8%A7%A3/#hamburgerscf371c","title":"Hamburgers\uff08CF371C)","text":""},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/%E4%BA%8C%E5%88%86%E8%AE%AD%E7%BB%83%E9%A2%98%E8%A7%A3/#_4","title":"\u9898\u76ee\u5206\u6790","text":"<p>\u9898\u76ee\u8981\u6c42\u6c42\u51fa\u6700\u591a\u6c49\u5821\u6570\u91cf\uff0c\u4e0d\u96be\u53d1\u73b0\u5982\u679c\u76f4\u63a5\u7edf\u8ba1\u65e0\u6cd5\u505a\u5230\uff0c\u6240\u4ee5\u8003\u8651\u4e8c\u5206\u7b54\u6848\u3002</p> <p>check\u51fd\u6570\uff1a\u5bf9\u4e8e\u6bcf\u79cd\u7684\u7b54\u6848\uff0c\u5c3d\u53ef\u80fd\u4f7f\u7528\u53a8\u623f\u91cc\u7684\uff0c\u4e0d\u591f\u5c31\u4e70\uff0c\u6bd4\u8f83\u91d1\u989d\u548c $r$ \u5373\u53ef\u3002</p>"},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/%E4%BA%8C%E5%88%86%E8%AE%AD%E7%BB%83%E9%A2%98%E8%A7%A3/#code","title":"Code","text":"<pre><code>#pragma GCC optimize(1, 2, 3, \"Ofast\", \"inline\")\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long\n#define int ll\n#define ONLINE_JUDGE\n// #define MULTI_CASES\n#define endl '\\n'\nconst int MaxN = 2e5 + 100;\nconst int INF = 1e9;\nconst int mod = 212370440130137957ll;\nint T = 1, N, M;\nint a[MaxN];\nint nb, ns, nc;\nint pb, ps, pc;\nint r;\nint sumb, sums, sumc;\nbool check(int mid)\n{\n    int b = max(sumb*mid - nb, (ll)0), s = max(sums*mid - ns, (ll)0), c = max(sumc *mid- nc, (ll)0);\n    if (b * pb + s * ps + c * pc &lt;= r)\n    {\n        return 1;\n    }\n    return 0;\n}\ninline void Solve()\n{\n    string s;\n    cin &gt;&gt; s;\n    cin &gt;&gt; nb &gt;&gt; ns &gt;&gt; nc;\n    cin &gt;&gt; pb &gt;&gt; ps &gt;&gt; pc;\n    cin &gt;&gt; r;\n    for (int i = 0; i &lt; s.size(); i++)\n    {\n        if (s[i] == 'B')\n        {\n            sumb++;\n        }\n        if (s[i] == 'S')\n        {\n            sums++;\n        }\n        if (s[i] == 'C')\n        {\n            sumc++;\n        }\n    }\n    int l = 0, r = 1e13;\n    // cerr &lt;&lt; check(1) &lt;&lt; endl;\n    while (l &lt; r)\n    {\n        int mid = (l + r + 1) &gt;&gt; 1;\n        // cout&lt;&lt;mid&lt;&lt;endl;\n        if (check(mid))\n        {\n            l = mid;\n        }\n        else\n        {\n            r = mid - 1;\n        }\n    }\n    cout &lt;&lt; l &lt;&lt; endl;\n}\nsigned main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(\".in\", \"r\", stdin);\n    freopen(\".out\", \"w\", stdout);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n\n#ifdef MULTI_CASES\n    cin &gt;&gt; T;\n    while (T--)\n#endif\n        Solve();\n    // fclose(stdin);\n    // fclose(stdout);\n    return 0;\n}\n</code></pre>"},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/%E4%BA%8C%E5%88%86%E8%AE%AD%E7%BB%83%E9%A2%98%E8%A7%A3/#matrixpoj3685","title":"Matrix\uff08POJ3685\uff09","text":""},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88_README/","title":"\u9898\u89e3\u96c6\u5408_README","text":"<p>\u8fd9\u91cc\u662f\u5b66\u4e60\u8fc7\u7a0b\u4e2d\u7684\u9898\u89e3\u4ee5\u53caodeforces/NOIp\u7b49\u6bd4\u8d5b\u7684\u590d\u76d8\u548c\u8865\u9898\u3002</p>"},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88_README/#codeforces","title":"codeforces\u7cfb\u5217","text":"<p>CF1833B</p> <p>CF1846B</p> <p>CF1850B</p> <p>CF1850C</p> <p>CF1862B</p> <p>CF1890B</p> <p>CF1988A</p> <p>CF1988B</p> <p>CF1988C</p> <p>CF2023B</p> <p>CF2024A</p> <p>CF2024B</p> <p>CF2024C</p>"},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88_README/#luogu","title":"Luogu\u9898\u89e3","text":"<p>P1570</p> <p>P5686</p> <p>P9455</p> <p>P9586</p>"},{"location":"OI/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88_README/#_1","title":"\u6a21\u62df\u8d5b\u9898\u89e3","text":"<p>2024.11.25-NOIP\u6a21\u62df\u8d5b</p>"},{"location":"%E5%8D%95%E7%89%87%E6%9C%BA/","title":"\u5355\u7247\u673a","text":""},{"location":"%E5%8D%95%E7%89%87%E6%9C%BA/#_2","title":"\u7b80\u4ecb","text":"<p>\u4e3b\u8981\u5185\u5bb9\u5305\u62ecSTM32&amp;ESP32\u7b49\u5355\u7247\u673a\u6a21\u5757\u7684\u5f00\u53d1\u73af\u5883\u642d\u5efa\uff0c\u8bbe\u5907\u9a71\u52a8\uff0c\u9879\u76ee\u5b9e\u6218\uff0c\u5e38\u89c1\u95ee\u9898\u53ca\u89e3\u51b3\u65b9\u6848\u7b49\u5185\u5bb9\u3002</p>"},{"location":"%E5%8D%95%E7%89%87%E6%9C%BA/#stm32","title":"STM32","text":""},{"location":"%E5%8D%95%E7%89%87%E6%9C%BA/#_3","title":"\u5f00\u53d1\u73af\u5883","text":""},{"location":"%E5%8D%95%E7%89%87%E6%9C%BA/#_4","title":"\u8bbe\u5907\u9a71\u52a8\u6587\u4ef6","text":""},{"location":"%E5%8D%95%E7%89%87%E6%9C%BA/#_5","title":"\u9879\u76ee","text":""},{"location":"%E5%8D%95%E7%89%87%E6%9C%BA/#_6","title":"\u95ee\u9898\u53ca\u65b9\u6848","text":""},{"location":"%E5%8D%95%E7%89%87%E6%9C%BA/#esp32","title":"ESP32","text":""},{"location":"%E5%8D%95%E7%89%87%E6%9C%BA/#_7","title":"\u5f00\u53d1\u73af\u5883","text":""},{"location":"%E5%8D%95%E7%89%87%E6%9C%BA/#_8","title":"\u8bbe\u5907\u9a71\u52a8\u6587\u4ef6","text":""},{"location":"%E5%8D%95%E7%89%87%E6%9C%BA/#_9","title":"\u9879\u76ee","text":""},{"location":"%E5%8D%95%E7%89%87%E6%9C%BA/#_10","title":"\u95ee\u9898\u53ca\u65b9\u6848","text":""},{"location":"%E6%96%87%E5%AD%A6/","title":"\u6587\u5b66","text":""},{"location":"%E6%96%87%E5%AD%A6/#_2","title":"\u7b80\u4ecb","text":"<p>\u6587\u5b66\u677f\u5757\u4e3b\u8981\u8bb0\u5f55\u9605\u8bfb\u65b9\u9762\u548c\u5199\u4f5c\u65b9\u9762\u3002\u9605\u8bfb\u65b9\u9762\u4e3b\u8981\u5305\u62ec\u9605\u8bfb\u4e66\u7c4d\uff0c\u8bfb\u4e66\u7b14\u8bb0&amp;\u611f\u609f\u7b49\u5185\u5bb9\uff1b\u5199\u4f5c\u5305\u62ec\u4f5c\u6587\u7d20\u6750\u79ef\u7d2f\uff0c\u6587\u5b66\u521b\u4f5c\u7b49\u5185\u5bb9\u3002</p>"},{"location":"%E6%96%87%E5%AD%A6/#_3","title":"\u9605\u8bfb","text":""},{"location":"%E6%96%87%E5%AD%A6/#_4","title":"\u5199\u4f5c","text":""},{"location":"%E6%96%87%E5%AD%A6/#_5","title":"\u7d20\u6750","text":""},{"location":"%E6%96%87%E5%AD%A6/#_6","title":"\u6587\u7ae0","text":""},{"location":"%E6%97%A5%E8%AE%B0/2025-03-13/","title":"2025 03 13","text":"<p>\u4eca\u5929\u770b\u5230\u5c71\u897f\u7701\u961f\u540d\u5355\u4e86\uff0c\u611f\u6168\u4e07\u5343\uff1b\u601d\u6765\u60f3\u53bb\uff0c\u8fd8\u662f\u60f3\u8981\u62fc\u4e00\u628a\uff0c\u6545\u56e0\u6b64\u91cd\u542f\u4e2a\u4eba\u77e5\u8bc6\u5e93\u9879\u76ee\u3002 \u672c\u6b21\u9879\u76ee\u4e3b\u8981\u4ee5Obsidian&amp;VScode\u5728\u672c\u5730\u90e8\u7f72\u3002\u540e\u671f\u53ef\u80fd\u8003\u8651\u6dfb\u52a0\u8fdc\u7a0b\u65b9\u5f0f\u3002\u6240\u6709\u6570\u636e\u5e93\u4fe1\u606f\u5b58\u50a8\u5728NAS\u4e0a\u3002 \u4eca\u65e5\u9996\u5148\u5c06OI\u90e8\u5206\u5185\u5bb9\u8fdb\u884c\u91cd\u6784\uff0c\u660e\u786e\u5185\u5bb9\u67b6\u6784\u3002 Dream it possible\uff01</p>"},{"location":"%E6%97%A5%E8%AE%B0/2025-03-14/","title":"2025 03 14","text":"<p>\u65e0\u66f4\u65b0</p>"},{"location":"%E6%97%A5%E8%AE%B0/2025-03-15/","title":"2025 03 15","text":"<ul> <li>\u542f\u7528git\u5b9e\u73b0\u8fdc\u7a0b\u5b58\u50a8\u3002</li> <li>\u79fb\u9664GoodNotes\u6587\u4ef6\u5939</li> <li>\u4fee\u6539OI_README\u6587\u4ef6</li> <li>\u6dfb\u52a0\u7b97\u6cd5\u6587\u7ae0\u5185\u5bb9</li> <li>\u91cd\u65b0\u4fee\u6539\u94fe\u63a5\u65b9\u5f0f\uff0c\u4f7f\u5176\u7b26\u5408markdown\u683c\u5f0f\u3002</li> </ul>"},{"location":"%E6%97%A5%E8%AE%B0/2025-03-16/","title":"2025 03 16","text":"<ul> <li>\u79fb\u9664\u6587\u5316\u8bfe\u677f\u5757\u4e2d\u7684\u5927\u6587\u4ef6\uff0c\u6539\u7528\u4e2a\u4eba\u7f51\u76d8\uff0c\u51cf\u5c11git lfs\u8d44\u6e90\u3002</li> <li>\u66f4\u65b0OI/\u8d44\u6e90\u94fe\u63a5\uff0c\u6dfb\u52a0OI\u5b66\u4e60\u4e2d\u7684\u5e38\u7528\u8d44\u6e90\u94fe\u63a5\u3002</li> <li>\u6dfb\u52a0\u7b97\u6cd5\u6587\u7ae0\u4e2d\u7684\u8bfe\u4ef6\u3002</li> </ul>"},{"location":"%E8%8B%B1%E8%AF%AD/","title":"\u82f1\u8bed/English","text":""},{"location":"%E8%8B%B1%E8%AF%AD/#introduce","title":"\u7b80\u4ecb/Introduce","text":"<p>\u6b64\u90e8\u5206\u5305\u62ec\u82f1\u8bed\u5b66\u4e60\u6240\u7528\u7684\u6587\u732e\uff0c\u5355\u8bcd\u5b66\u4e60\u60c5\u51b5\u4ee5\u53ca\u5404\u79cd\u5b66\u4e60\u8d44\u6e90\u7b49\u5185\u5bb9\u3002</p> <p>This section includes literature for English learning, vocabulary learning progress, and various learning resources.</p>"},{"location":"%E8%8B%B1%E8%AF%AD/#document","title":"\u6587\u732e /Document","text":""},{"location":"%E8%8B%B1%E8%AF%AD/#vocabulary","title":"\u5355\u8bcd/Vocabulary","text":""},{"location":"%E8%8B%B1%E8%AF%AD/#resources","title":"\u8d44\u6e90/Resources","text":""},{"location":"%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/whk_README/","title":"\u9ad8\u4e2d\u6587\u5316\u8bfe","text":""},{"location":"%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/whk_README/#_2","title":"\u7b80\u4ecb","text":"<p>\u6b64\u5206\u7c7b\u4e3b\u8981\u5305\u542b\u9ad8\u4e2d\u6240\u6709\u8bfe\u5185\u77e5\u8bc6\u70b9\u5408\u96c6\uff0c\u8bb0\u5f55\u76ee\u524d\u6240\u5b66\u7684\u77e5\u8bc6\u4ee5\u4fbf\u4e4b\u540e\u56de\u987e\u590d\u4e60\u3002\u4e3b\u8981\u6709\u8bed\u6587\u3001\u6570\u5b66\u3001\u82f1\u8bed\u3001\u7269\u7406\u3001\u5316\u5b66\u3001\u751f\u7269\u3001\u653f\u6cbb\u3001\u5730\u7406\u548c\u5386\u53f2\u7b49\u5b66\u79d1\u77e5\u8bc6\u3002</p>"},{"location":"%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/whk_README/#_3","title":"\u8bed\u6587","text":"<p>\u8bed\u6587_README</p>"},{"location":"%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/whk_README/#_4","title":"\u6570\u5b66","text":"<p>\u6570\u5b66_README</p>"},{"location":"%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/whk_README/#_5","title":"\u82f1\u8bed","text":"<p>\u82f1\u8bed_README</p>"},{"location":"%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/whk_README/#_6","title":"\u7269\u7406","text":"<p>\u7269\u7406_README</p>"},{"location":"%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/whk_README/#_7","title":"\u5316\u5b66","text":"<p>\u5316\u5b66_README</p>"},{"location":"%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/whk_README/#_8","title":"\u751f\u7269","text":"<p>\u751f\u7269_README</p>"},{"location":"%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/whk_README/#_9","title":"\u653f\u6cbb","text":"<p>\u653f\u6cbb_README</p>"},{"location":"%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/whk_README/#_10","title":"\u5730\u7406","text":"<p>\u5730\u7406_README</p>"},{"location":"%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/whk_README/#_11","title":"\u5386\u53f2","text":"<p>\u5386\u53f2_README</p>"},{"location":"%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/%E5%8C%96%E5%AD%A6/%E5%8C%96%E5%AD%A6_README/","title":"\u5316\u5b66","text":""},{"location":"%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/%E5%8C%96%E5%AD%A6/%E5%8C%96%E5%AD%A6_README/#_2","title":"\u8d44\u6e90","text":"<ul> <li>\u5316\u5b66_\u77e5\u8bc6\u70b9\u6c47\u603b_Magolor</li> </ul>"},{"location":"%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6_README/","title":"\u6570\u5b66","text":""},{"location":"%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6_README/#_2","title":"\u8d44\u6e90","text":"<ul> <li>\u6570\u5b66_\u77e5\u8bc6\u70b9\u6c47\u603b_Magolor</li> </ul>"},{"location":"%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/%E7%89%A9%E7%90%86/%E7%89%A9%E7%90%86_README/","title":"\u7269\u7406","text":""},{"location":"%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/%E7%89%A9%E7%90%86/%E7%89%A9%E7%90%86_README/#_2","title":"\u8d44\u6e90","text":"<ul> <li>\u7269\u7406_\u77e5\u8bc6\u70b9\u6c47\u603b_Magolor</li> </ul>"},{"location":"%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/%E7%94%9F%E7%89%A9/%E7%94%9F%E7%89%A9_README/","title":"\u751f\u7269","text":""},{"location":"%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/%E7%94%9F%E7%89%A9/%E7%94%9F%E7%89%A9_README/#_2","title":"\u8d44\u6e90","text":"<ul> <li>\u751f\u7269_\u77e5\u8bc6\u70b9\u6c47\u603b_Magolor</li> </ul>"}]}