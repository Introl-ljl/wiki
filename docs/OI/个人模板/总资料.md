<!-- TOC -->

- [杂项](#杂项)
	- [$O2$ 优化](#o2-优化)
	- [高精度](#高精度)
	- [哈希](#哈希)
		- [单哈希](#单哈希)
	- [Mod网赛](#mod网赛)
	- [普通莫队](#普通莫队)
	- [样例 #1](#样例-1)
		- [样例输入 #1](#样例输入-1)
		- [样例输出 #1](#样例输出-1)
	- [树上莫队](#树上莫队)
	- [整体二分](#整体二分)
		- [\[国家集训队\]矩阵乘法](#国家集训队矩阵乘法)
			- [题目描述](#题目描述)
			- [输入格式](#输入格式)
			- [输出格式](#输出格式)
			- [样例 #1](#样例-1-1)
					- [样例输入 #1](#样例输入-1-1)
			- [样例输出 #1](#样例输出-1-1)
			- [数据规模与约定](#数据规模与约定)
	- [cdq分治](#cdq分治)
		- [【模板】三维偏序（陌上花开）](#模板三维偏序陌上花开)
	- [KD-Tree](#kd-tree)
	- [并查集](#并查集)
	- [带权并查集](#带权并查集)
		- [题解](#题解)
	- [离散化](#离散化)
	- [手打队列](#手打队列)
	- [点分治](#点分治)
		- [【模板】点分治1](#模板点分治1)
			- [题目描述](#题目描述-1)
			- [输入格式](#输入格式-1)
			- [输出格式](#输出格式-1)
				- [数据规模与约定。](#数据规模与约定-1)
	- [树上启发式合并](#树上启发式合并)
- [数据结构](#数据结构)
	- [ST 表](#st-表)
	- [FHQ-treap](#fhq-treap)
		- [平衡树维护Hash](#平衡树维护hash)
		- [普通平衡树](#普通平衡树)
			- [添点](#添点)
			- [合并](#合并)
			- [分裂](#分裂)
				- [普通](#普通)
				- [区间分裂](#区间分裂)
		- [$\\mathcal{O}(1)$建树](#mathcalo1建树)
		- [FHQ-Treap给编号寻位置](#fhq-treap给编号寻位置)
	- [【模板】文艺平衡树（Splay）](#模板文艺平衡树splay)
		- [题目描述](#题目描述-2)
			- [输入格式](#输入格式-2)
			- [输出格式](#输出格式-2)
			- [思路](#思路)
	- [树状数组](#树状数组)
	- [线段树](#线段树)
		- [Introl](#introl)
	- [权值线段树](#权值线段树)
	- [树链剖分](#树链剖分)
		- [Introl](#introl-1)
	- [【模板】可持久化线段树 1（可持久化数组）](#模板可持久化线段树-1可持久化数组)
		- [题目描述](#题目描述-3)
	- [【模板】可持久化线段树 2(主席树)](#模板可持久化线段树-2主席树)
	- [可持久化并查集](#可持久化并查集)
	- [ODT](#odt)
	- [【模板】左偏树（可并堆）](#模板左偏树可并堆)
		- [题目描述](#题目描述-4)
			- [输入格式](#输入格式-3)
			- [输出格式](#输出格式-3)
	- [【模板】可持久化平衡树](#模板可持久化平衡树)
			- [题目背景](#题目背景)
			- [题目描述](#题目描述-5)
			- [输入格式](#输入格式-4)
			- [输出格式](#输出格式-4)
	- [【模板】可持久化文艺平衡树](#模板可持久化文艺平衡树)
			- [题目描述](#题目描述-6)
			- [输入格式](#输入格式-5)
			- [输出格式](#输出格式-5)
			- [提示](#提示)
	- [LCA](#lca)
	- [\[Vani有约会\]雨天的尾巴 /【模板】线段树合并](#vani有约会雨天的尾巴-模板线段树合并)
		- [题目描述](#题目描述-7)
			- [输入格式](#输入格式-6)
			- [输出格式](#输出格式-6)
			- [样例 #1](#样例-1-2)
				- [样例输入 #1](#样例输入-1-2)
				- [样例输出 #1](#样例输出-1-2)
			- [提示](#提示-1)
				- [思路](#思路-1)
	- [【模板】线段树分裂](#模板线段树分裂)
		- [题目描述](#题目描述-8)
			- [输入格式](#输入格式-7)
			- [输出格式](#输出格式-7)
			- [样例 #1](#样例-1-3)
				- [样例输入 #1](#样例输入-1-3)
				- [样例输出 #1](#样例输出-1-3)
	- [树套树](#树套树)
		- [1.线段树套FHQ-treap](#1线段树套fhq-treap)
			- [【模板】二逼平衡树（树套树）](#模板二逼平衡树树套树)
			- [题目描述](#题目描述-9)
			- [输入格式](#输入格式-8)
			- [输出格式](#输出格式-8)
		- [2.树状数组套主席树](#2树状数组套主席树)
			- [题目描述](#题目描述-10)
		- [权值线段树套权值线段树(二维单点修改，矩形查询)](#权值线段树套权值线段树二维单点修改矩形查询)
	- [【模板】动态树（Link Cut Tree）](#模板动态树link-cut-tree)
		- [题目描述](#题目描述-11)
		- [输入格式](#输入格式-9)
		- [输出格式](#输出格式-9)
		- [样例 #1](#样例-1-4)
			- [样例输入 #1](#样例输入-1-4)
			- [样例输出 #1](#样例输出-1-4)
		- [样例 #2](#样例-2)
			- [样例输入 #2](#样例输入-2)
			- [样例输出 #2](#样例输出-2)
		- [维护子树大小](#维护子树大小)
		- [无makeroot](#无makeroot)
		- [乘法加法混合](#乘法加法混合)
	- [K-D Tree](#k-d-tree)
		- [简单题](#简单题)
			- [题目描述](#题目描述-12)
			- [输入格式](#输入格式-10)
			- [输出格式](#输出格式-10)
			- [样例 #1](#样例-1-5)
				- [样例输入 #1](#样例输入-1-5)
				- [样例输出 #1](#样例输出-1-5)
			- [提示](#提示-2)
- [数论](#数论)
	- [sqrt求根号](#sqrt求根号)
	- [质数筛](#质数筛)
	- [exgcd求逆元](#exgcd求逆元)
	- [组合数](#组合数)
	- [【模板】扩展中国剩余定理（EXCRT）](#模板扩展中国剩余定理excrt)
			- [题目描述](#题目描述-13)
			- [输入格式](#输入格式-11)
			- [输出格式](#输出格式-11)
			- [样例 #1](#样例-1-6)
				- [样例输入 #1](#样例输入-1-6)
				- [样例输出 #1](#样例输出-1-6)
			- [提示](#提示-3)
			- [题解：](#题解-1)
	- [【模板】Pollard-Rho算法](#模板pollard-rho算法)
- [字符串](#字符串)
	- [Trie](#trie)
	- [kmp](#kmp)
	- [Manacher](#manacher)
	- [【模板】扩展 KMP（Z 函数）](#模板扩展-kmpz-函数)
		- [题目描述](#题目描述-14)
		- [输入格式](#输入格式-12)
	- [后缀数组](#后缀数组)
	- [【模板】后缀自动机（SAM）](#模板后缀自动机sam)
			- [题目描述](#题目描述-15)
			- [输入格式](#输入格式-13)
			- [输出格式](#输出格式-12)
			- [样例 #1](#样例-1-7)
				- [样例输入 #1](#样例输入-1-7)
				- [样例输出 #1](#样例输出-1-7)
		- [后缀自动机(SAM)](#后缀自动机sam)
		- [EXSAM](#exsam)
		- [最长公共子串](#最长公共子串)
	- [回文自动机（回文树）](#回文自动机回文树)
	- [AC自动机(ACM)](#ac自动机acm)
- [图论](#图论)
	- [tarjan](#tarjan)
	- [模板】单源最短路径（标准版）](#模板单源最短路径标准版)
	- [EK费用流处理负环](#ek费用流处理负环)
	- [最大流（dinic）](#最大流dinic)
	- [费用流](#费用流)
	- [2-SAT](#2-sat)
- [dp](#dp)
	- [斜率优化](#斜率优化)
- [计算几何](#计算几何)
		- [二维凸包](#二维凸包)
		- [两直线交点](#两直线交点)
		- [判断在凸包内](#判断在凸包内)
		- [多边形面积](#多边形面积)
		- [判断圆和线段有几个交点](#判断圆和线段有几个交点)
		- [半平面交](#半平面交)
		- [旋转卡壳](#旋转卡壳)
		- [闵可夫斯基和](#闵可夫斯基和)

<!-- /TOC -->
# 杂项
## $O2$ 优化
```cpp
#pragma GCC optimize(1, 2, 3, "Ofast", "inline")

if ((ed - st) / CLOCKS_PER_SEC >= 0.9) break;

ios::sync_with_stdio(0);
cin.tie(0);

windos: -std=c++17 -Wl,--stack=1024000000     
linux: ulimit -s unlimited  

ll qread_tmp;
#define read() qread(qread_tmp)
template<class T>
inline T qread(T &sum) {
	sum=0;int boo=1;
	char x=getchar();
	while(x<'0'||x>'9'){if(x=='-')boo=-1;x=getchar();}
	while(x>='0'&&x<='9'){sum=(sum<<1)+(sum<<3)+x-'0';x=getchar();}
	sum*=boo;
	return sum;
}
template<class T>
void qput(T x) {
	if(x<0) {x=-x;putchar('-');}
	if(x>9) qput(x/10);
	putchar(x%10+48);
}



namespace IN {
    const int MAXN_INPUT = 1000000;
    #define getc() (p1 == p2 && (p2 = (p1 = buf) + inbuf -> sgetn(buf, MAXN_INPUT), p1 == p2) ? EOF : *p1++)
    char buf[MAXN_INPUT], *p1, *p2;
    template <typename T> inline bool qread(T &x) {
        static std::streambuf *inbuf = cin.rdbuf();
        x = 0;
        register int f = 0, flag = false;
        register char ch = getc();
        while (!std::isdigit(ch)) {
            if (ch == '-') f = 1;
        ch = getc();
        }
        if (std::isdigit(ch)) x = x * 10 + ch - '0', ch = getc(),flag = true;
        while (std::isdigit(ch)) {
            x = x * 10 + ch - 48;
            ch = getc();
        }
        x = f ? -x : x ;
        return flag;
    }
    template <typename T,typename ...Args> inline bool qread(T& a,Args& ...args) {
       return qread(a) && qread(args...);
    }
    #undef getc
}

namespace OUT {
    template <typename T> inline void qput(T x) {
        static std::streambuf *outbuf = cout.rdbuf();
        static char stack[255];
        static int top = 0;
        if (x < 0) {
            outbuf -> sputc('-');
            x=-x;
        }
        if (!x) {
            outbuf -> sputc('0');
            outbuf -> sputc('\n');
            return;
        }
        while (x) {
            stack[++top] = x % 10 + '0';
            x /= 10;
        }
        while (top) {
            outbuf -> sputc(stack[top]);
            -- top;
        }
    }
    inline void putc (const char ch) {
        static std::streambuf *outbuf = cout.rdbuf();
        outbuf -> sputc(ch);
    }
    template <typename T> inline void qput(const char ch,T x)
    {
        static std::streambuf *outbuf = cout.rdbuf();
        static char stack[255];
        static int top = 0;
        if (x < 0) {
            outbuf -> sputc('-');
            x=-x;
        }
        if (!x) {
            outbuf -> sputc('0');
            outbuf -> sputc(ch);
            return;
        }
        while (x) {
            stack[++top] = x % 10 + '0';
            x /= 10;
        }
        while (top) {
            outbuf -> sputc(stack[top]);
            --top;
        }
        outbuf -> sputc(ch);
    }
    template<typename T,typename ...Args> inline void qput(T a,Args ...args) {
        qput(a); qput(args...);
    }
    template<typename T,typename ...Args> inline void qput(const char ch,T a,Args ...args) {
        qput(ch, a); qput(ch, args...);
    }
}
using IN::qread;
using OUT::qput;
using OUT::putc;
```

## 高精度
```cpp
struct BigInteger {
    static const int BASE = 100000000;
    static const int WIDTH = 8;
    vector<int> s;
    bool negative;

    BigInteger(long long num = 0) { *this = num; }
    BigInteger(const string& str) { *this = str; }
    
    BigInteger operator=(long long num) {
        s.clear();
        negative = num < 0;
        num = std::abs(num);
        do {
            s.push_back(num % BASE);
            num /= BASE;
        } while (num > 0);
        return *this;
    }
    
    BigInteger operator=(const string& str) {
        s.clear();
        negative = str[0] == '-';
        int x, len = (str.length() - 1 - negative) / WIDTH + 1;
        for (int i = 0; i < len; i++) {
            int end = str.length() - i * WIDTH;
            int start = max(negative ? 1ll : 0ll, end - WIDTH);
            sscanf(str.substr(start, end - start).c_str(), "%lld", &x);
            s.push_back(x);
        }
        return *this;
    }

    bool operator<(const BigInteger& b) const {
        if (negative != b.negative) return negative;
        if (s.size() != b.s.size()) return negative ? s.size() > b.s.size() : s.size() < b.s.size();
        for (int i = s.size() - 1; i >= 0; i--)
            if (s[i] != b.s[i]) return negative ? s[i] > b.s[i] : s[i] < b.s[i];
        return false;
    }
    bool operator>(const BigInteger& b) const { return b < *this; }
    bool operator<=(const BigInteger& b) const { return !(b < *this); }
    bool operator>=(const BigInteger& b) const { return !(*this < b); }
    bool operator!=(const BigInteger& b) const { return b < *this || *this < b; }
    bool operator==(const BigInteger& b) const { return !(b < *this) && !(*this < b); }

    BigInteger operator+(const BigInteger& b) const {
        if (negative == b.negative) {
            BigInteger c;
            c.negative = negative;
            c.s.clear();
            for (int i = 0, g = 0;; i++) {
                if (g == 0 && i >= s.size() && i >= b.s.size()) break;
                int x = g;
                if (i < s.size()) x += s[i];
                if (i < b.s.size()) x += b.s[i];
                c.s.push_back(x % BASE);
                g = x / BASE;
            }
            return c;
        }
        return *this - (-b);
    }

    BigInteger operator-(const BigInteger& b) const {
        if (negative == b.negative) {
            if (abs() >= b.abs()) {
                BigInteger c;
                c.negative = negative;
                c.s.clear();
                for (int i = 0, g = 0;; i++) {
                    if (g == 0 && i >= s.size() && i >= b.s.size()) break;
                    int x = g;
                    if (i < s.size()) x += s[i];
                    if (i < b.s.size()) x -= b.s[i];
                    if (x < 0) {
                        c.s.push_back(x + BASE);
                        g = -1;
                    } else {
                        c.s.push_back(x);
                        g = 0;
                    }
                }
                c.killzero();
                return c;
            }
            return -(b - *this);
        }
        return *this + (-b);
    }

    BigInteger operator*(const BigInteger& b) const {
        BigInteger c;
        c.s.resize(s.size() + b.s.size(), 0);
        c.negative = negative != b.negative;
        for (int i = 0; i < s.size(); i++) {
            long long carry = 0;
            for (int j = 0; j < b.s.size(); j++) {
                long long sum = (long long)s[i] * b.s[j] + c.s[i + j] + carry;
                c.s[i + j] = sum % BASE;
                carry = sum / BASE;
            }
            if (carry) c.s[i + b.s.size()] += carry;
        }
        c.killzero();
        return c;
    }

    BigInteger operator/(const BigInteger& b) const {
        BigInteger c, cur;
        c.s.resize(s.size());
        cur.negative = negative;
        c.negative = negative != b.negative;
		BigInteger abs_b = b.abs();
        for (int i = s.size() - 1; i >= 0; i--) {
            cur = cur * BASE + s[i];
            int x = 0, l = 0, r = BASE;
			BigInteger cur_b = cur.abs();
            while (l <= r) {
                int mid = (l + r) / 2;
                if (abs_b * mid <= cur_b) {
                    x = mid;
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
            c.s[i] = x;
            cur = cur - abs_b * x;
        }
        c.killzero();
        return c;
    }

    BigInteger operator/(const int& b) const {
        BigInteger c;
        c.s.clear();
        long long r = 0;
        c.negative = negative != (b < 0);
        int abs_b = std::abs(b);
        for (int i = s.size() - 1; i >= 0; --i) {
            r = r * BASE + s[i];
            c.s.push_back(r / abs_b);
            r %= abs_b;
        }
        reverse(c.s.begin(), c.s.end());
        c.killzero();
        return c;
    }

    BigInteger operator%(const BigInteger& b) const {
        return *this - (*this / b) * b;
    }

    BigInteger operator%(const int& b) const {
        return *this - (*this / b) * b;
    }

    BigInteger operator+=(const BigInteger& b) {
        *this = *this + b;
        return *this;
    }
    BigInteger operator++(signed) {
        *this = *this + 1;
        return *this;
    }
    BigInteger operator++() {
        *this = *this + 1;
        return *this;
    }
    BigInteger operator-=(const BigInteger& b) {
        *this = *this - b;
        return *this;
    }
    BigInteger operator--(signed) {
        *this = *this - 1;
        return *this;
    }
    BigInteger operator--() {
        *this = *this - 1;
        return *this;
    }
    BigInteger operator*=(const BigInteger& b) {
        *this = *this * b;
        return *this;
    }
    BigInteger operator/=(const BigInteger& b) {
        *this = *this / b;
        return *this;
    }
    BigInteger operator%=(const BigInteger& b) {
        *this = *this % b;
        return *this;
    }

    BigInteger operator-() const {
        BigInteger c = *this;
        c.negative = !negative;
        return c;
    }

    BigInteger abs() const {
        BigInteger c = *this;
        c.negative = false;
        return c;
    }

    void killzero() {
        while (s.back() == 0 && s.size() > 1)
            s.pop_back();
    }

    friend ostream& operator<<(ostream& out, const BigInteger& x) {
        if (x.negative) out << '-';
        out << x.s.back();
        for (int i = x.s.size() - 2; i >= 0; i--) {
            char buf[20];
            sprintf(buf, "%08d", x.s[i]);
            out << buf;
        }
        return out;
    }

    friend istream& operator>>(istream& in, BigInteger& x) {
        string s;
        if (!(in >> s)) return in;
        x = s;
        return in;
    }
};
```

## 哈希
```cpp
const int P1 = 1e9 + 7;
const int P2 = 1e9 + 9;
const int b1 = 33331;
const int b2 = 32141;
struct Hash {
	ll x, y;
	Hash(): x(0), y(0) {}
	Hash(ll x): x(x), y(x) {}
	Hash(ll t1, ll t2): x(t1), y(t2) {}
	inline bool operator==(const Hash &aa) const {
		if (x == aa.x && y == aa.y) return 1;
		return 0;
	}
	inline bool operator!=(const Hash &aa) const {
		return !(*this == aa);
	}
	inline void js(){
		x = (x % P1 + P1) % P1;
		y = (y % P2 + P2) % P2;
	}
	inline bool operator<(const Hash &aa) const {
		if (x != aa.x) return x < aa.x;
		return y < aa.y;
	}
	inline Hash operator+(const Hash &aa) const {
		return (Hash){ x + aa.x, y + aa.y };
	}
	inline Hash operator-(const Hash &aa) const {
		return (Hash){ x - aa.x, y - aa.y };
	}
	inline Hash operator*(const Hash &aa) const {
		return (Hash){ x * aa.x, y * aa.y };
	}
	inline Hash operator*(const ll &aa) const {
		return (Hash){ x * aa, y * aa };
	}
	inline Hash operator%(const Hash &aa) const {
		return (Hash){ (x % aa.x + aa.x) % aa.x, (y % aa.y + aa.y) % aa.y };
	}
	inline void print() {
		cout << x << ' ';
		cout << y << endl;
	}
};
struct my_hash {
  static uint64_t splitmix64(uint64_t x) {
    x += 0x9e3779b97f4a7c15;
    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
    return x ^ (x >> 31);
  }

  size_t operator()(uint64_t x) const {
    static const uint64_t FIXED_RANDOM =
        chrono::steady_clock::now().time_since_epoch().count();
    return splitmix64(x + FIXED_RANDOM);
  }

  // 针对 std::pair<int, int> 作为主键类型的哈希函数
  size_t operator()(Hash x) const {
    static const uint64_t FIXED_RANDOM =
        chrono::steady_clock::now().time_since_epoch().count();
    return splitmix64(x.x + FIXED_RANDOM) ^
           (splitmix64(x.y + FIXED_RANDOM) >> 1);
  }
};
const Hash P = {P1, P2};
const Hash B = {b1, b2};
unordered_map<Hash, int, my_hash> mp;
struct TT {
	Hash sum[MaxN], power[MaxN];
	void pre(string s1, int N) {
		power[0] = Hash(1);
		for (int i = 1; i <= N; i++) {
			sum[i] = (sum[i - 1] * B + Hash(s1[i])) % P;
			power[i] = power[i - 1] * B % P;
		}
	}
	Hash query(int l, int r) {
		Hash ans = sum[r] - sum[l - 1] * power[r - l + 1] % P;
		ans.js();
		return ans;
	}
} TT[2];
```
### 单哈希
```cpp
const int P1 = 1e9 + 7;
const int P2 = 1e9 + 9;
const int b1 = 33331;
const int b2 = 32141;
struct Hash {
	ll x;
	Hash(): x(0) {}
	Hash(ll x): x(x) {}
	Hash(ll t1, ll t2): x(t1) {}
	inline bool operator==(const Hash &aa) const {
		if (x == aa.x) return 1;
		return 0;
	}
	inline bool operator!=(const Hash &aa) const {
		return !(*this == aa);
	}
	inline void js(){
		x = (x % P1 + P1) % P1;
	}
	inline bool operator<(const Hash &aa) const {
		return x < aa.x;
	}
	inline Hash operator+(const Hash &aa) const {
		return (Hash){ x + aa.x };
	}
	inline Hash operator-(const Hash &aa) const {
		return (Hash){ x - aa.x };
	}
	inline Hash operator*(const Hash &aa) const {
		return (Hash){ x * aa.x };
	}
	inline Hash operator*(const ll &aa) const {
		return (Hash){ x * aa };
	}
	inline Hash operator%(const Hash &aa) const {
		return (Hash){ (x % aa.x + aa.x) % aa.x };
	}
	inline void print() {
		cout << x << ' ';
	}
};
struct my_hash {
  static uint64_t splitmix64(uint64_t x) {
    x += 0x9e3779b97f4a7c15;
    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
    return x ^ (x >> 31);
  }

  size_t operator()(uint64_t x) const {
    static const uint64_t FIXED_RANDOM =
        chrono::steady_clock::now().time_since_epoch().count();
    return splitmix64(x + FIXED_RANDOM);
  }

};
const Hash P = {P1};
const Hash B = {b1};
unordered_map<Hash, int, my_hash> mp;
struct TT {
	vector<Hash> sum, power;
	void pre(string s1, int N) {
		sum.assign(N + 1, 0);
		power.assign(N + 1, 0);
		power[0] = Hash(1);
		for (int i = 1; i <= N; i++) {
			sum[i] = (sum[i - 1] * B + Hash(s1[i])) % P;
			power[i] = power[i - 1] * B % P;
		}
	}
	Hash query(int l, int r) {
		Hash ans = sum[r] - sum[l - 1] * power[r - l + 1] % P;
		ans.js();
		return ans;
	}
} TT, Ta[MaxN];
```
## Mod网赛
```cpp
template<class T>
constexpr T ksm(T x, ll y) {
	T res = 1;
	while (y) {
		if (y & 1) res = res * x;
		x = x * x;
		y >>= 1;
	}
	return res;
}

constexpr ll mul(ll a, ll b, ll p) { //快速乘 
    ll x = (long double)a / p * b;
    return ((ull)a * b - (ull)x * p + p) % p;
}

template<ll P>
struct MLong {
    ll x;
    constexpr MLong() : x{} {}
    constexpr MLong(ll x) : x{norm(x % getMod())} {}
    
    static ll Mod;
    constexpr static ll getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(ll Mod_) {
        Mod = Mod_;
    }
    constexpr ll norm(ll x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr ll val() const {
        return x;
    }
    explicit constexpr operator ll() const {
        return x;
    }
    constexpr MLong operator-() const {
        MLong res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MLong inv() const {
        assert(x != 0);
        return ksm(*this, getMod() - 2);
    }
    constexpr MLong &operator*=(MLong rhs) & {
        x = mul(x, rhs.x, getMod());
        return *this;
    }
    constexpr MLong &operator+=(MLong rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MLong &operator-=(MLong rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MLong &operator/=(MLong rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MLong operator*(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MLong operator+(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MLong operator-(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MLong operator/(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {
        ll v;
        is >> v;
        a = MLong(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MLong lhs, MLong rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MLong lhs, MLong rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<>
ll MLong<0LL>::Mod = (ll)(1E18) + 9;

template<int P>
struct MInt {
	int x;
	constexpr MInt() : x{} {}
	constexpr MInt(ll x) : x{norm(x % getMod())} {}

	static int Mod;
	static int getMod() {
		if (P > 0) {
			return P;
		} else {
			return Mod;
		}
	}
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return ksm(*this, getMod() - 2);
    }
    constexpr MInt &operator*=(MInt rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        ll v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};

template<>
int MInt<0>::Mod = 998244353;
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();

constexpr int P = 1e9 + 7;
using Z = MInt<P>;
```
## 普通莫队

给出一个长度为n 的数列，$a_{1}$​ ,$a_{2}$​ ,...,$a_{n}$ ，有q 个询问，每个询问给出数对$(i,j)$，需要你给出$a_{i}$​ ，$a_{i+1}$​ ，...，$a_{j}$​ 这一段中有多少不同的数字

## 样例 #1

### 样例输入 #1

```
5
1 1 2 1 3
3
1 5
2 4
3 5
```

### 样例输出 #1

```
3
2
3
```
```cpp
    #include<bits/stdc++.h>
    using namespace std;
    #define ll long long 
    #define int ll
    #define zuo p<<1
    #define you p<<1|1
    #define lowbit(x) ((x)&(-x))
    const int MaxN=1e6+100;
    int N,M,K,b[MaxN],ans[MaxN],sum;
    int vis[MaxN];
    struct point
    {
        int l, r, t, id;
		inline bool operator<(const Point &aa) const {
			if (t != aa.t) return t < aa.t;
			if (t & 1) return r < aa.r;
			return r > aa.r;
		}
    }a[MaxN];
    inline void move(int x,int v)
    {
        vis[b[x]]+=v;
        if(v==1&&vis[b[x]]==1) sum++;
        if(v==-1&&vis[b[x]]==0) sum--;
    }
    inline void md()
    {
        sort(a+1,a+1+M);
        int l=0,r=0;
        for(int i=1;i<=M;i++)
        {
            while(l>a[i].l) move(--l,1);
            while(r<a[i].r) move(++r,1);
            while(l<a[i].l) move(l++,-1);
            while(r>a[i].r) move(r--,-1);
            ans[a[i].id]=sum;
        }
    }
    signed main()
    {
        qread(N);
        for(int i=1;i<=N;i++) qread(b[i]);
        K=sqrt(N);qread(M); //K = 1000可能会比较快
        for(int i=1;i<=M;i++)
        {
            qread(a[i].l);qread(a[i].r);
            a[i].t=a[i].l/K;
            a[i].id=i;
        }
        md();
        for(int i=1;i<=M;i++)
        qput(ans[i]),putchar('\n');
    }
```
## 树上莫队
$ 题意：给你一棵树，树上第 i 个点颜色为 c_i，每次询问一条路径 u_i,v_i, 求这条路径上的 $   
$\sum_{c} {val_c \sum_{i=1}^{cnt_c} w_i }$  
$ 其中：val 表示该颜色的价值，cnt 表示颜色出现的次数，w 表示该颜色出现 i 次后的价值 $
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define int ll
const int MaxN = 1e6 + 100;
const int INF = 1e9;
int T, N, M, K;
int a[MaxN], b[MaxN], vis[MaxN], c[MaxN], s[MaxN];
int dep[MaxN], fa[MaxN][31];
int d[MaxN], top, fr[MaxN], la[MaxN], num1, num2, ans;
int jg[MaxN];
vector<int> G1[MaxN];
struct point
{
	int l, r, time, id;
	inline bool operator<(const point &aa)const
	{
		if (l / T == aa.l / T && r / T == aa.r / T)
		{
			return time < aa.time;
		}
		if (l / T == aa.l / T)
		{
			return r / T > aa.r / T;
		}
		return l / T < aa.l / T;
	}
}q1[MaxN], q2[MaxN];
void dfs1(int x, int f)
{
	d[++top] = x;
	fr[x] = top;
	dep[x] = dep[f] + 1;
	fa[x][0] = f;
	for (int i = 1; i <= 20; i++)
	{
		fa[x][i] = fa[fa[x][i - 1]][i - 1];
	}
	for (int i = 0; i < (int)G1[x].size(); i++)
	{
		int y = G1[x][i];
		if (y == f)
		{
			continue;
		}
		dfs1(y, x);
	}
	d[++top] = x;
	la[x] = top;
}
int lca(int x, int y)
{
	if (dep[x] < dep[y])
		swap(x, y);
	for (int i = 20; i >= 0; i--)
	{
		if (dep[fa[x][i]] >= dep[y])
		{
			x = fa[x][i];
		}
		if (x == y)
			return x;
	}
	for (int i = 20; i >= 0; i--)
	{
		if (fa[x][i] != fa[y][i])
		{
			x = fa[x][i];
			y = fa[y][i];
		}
	}
	return fa[x][0];
}
inline void add1(int x)
{
	int t = d[x];
	vis[t] ^= 1;
	if (vis[t] == 1)
	{
		s[c[t]]++;
		ans += a[c[t]] * b[s[c[t]]];
	}
	else
	{
		ans -= a[c[t]] * b[s[c[t]]];
		s[c[t]]--;
	}
}
void upt(int x, int t)
{
	if (vis[q2[t].l])
	{
		add1(fr[q2[t].l]);
		swap(c[q2[t].l], q2[t].r);
		add1(fr[q2[t].l]);
		return;
	}
	swap(c[q2[t].l], q2[t].r);
}
void md()
{
	sort(q1 + 1, q1 + num1 + 1);
	int l = 1, r = 1, t = 0;
	s[c[1]]++;
	ans = a[c[1]] * b[1];
	vis[1] = 1;
	for (int i = 1; i <= num1; i++)
	{
		int li = q1[i].l, ri = q1[i].r;
		while (li < l) add1(--l);
		while (ri > r) add1(++r);
		while (li > l) add1(l++);
		while (ri < r) add1(r--);
		while (t < q1[i].time) upt(i, ++t);
		while (t > q1[i].time) upt(i, t--);
		int k = lca(d[li], d[ri]);
		if (k != d[li] && k != d[ri])
		{
			jg[q1[i].id] = ans + a[c[k]] * b[s[c[k]] + 1];
		}
		else
		jg[q1[i].id] = ans;
	}
}
inline void Solve()
{
	qread(N); qread(M); qread(K);
//	K = 4;
	T = pow(2 * N, 0.6666);
	for (int i = 1; i <= M; i++)
	{
		qread(a[i]);
	}
	for (int i = 1; i <= N; i++)
	{
		qread(b[i]);
	}
	for (int i = 1; i < N; i++)
	{
		int x, y;
		qread(x); qread(y);
		G1[x].push_back(y);
		G1[y].push_back(x);
	}
	dfs1(1, 0);
	for (int i = 1; i <= N; i++)
	{
		qread(c[i]);
	}
	for (int i = 1; i <= K; i++)
	{
		int opt, x, y;
		qread(opt);qread(x);qread(y);
		if (opt == 0)
		{
			++num2;
			q2[num2].l = x;
			q2[num2].id = num2;
			q2[num2].r = y;
		}
		if (opt == 1)
		{
			++num1;
			if (fr[x] > fr[y])
				swap(x, y);
			q1[num1].id = num1;
			if (lca(x, y) == x)
				q1[num1].l = fr[x];
			else
				q1[num1].l = la[x];
			q1[num1].r = fr[y];
			q1[num1].time = num2; 
		}
	}
	md();
	for (int i = 1; i <= num1; i++)
	{
		qput(jg[i]);putchar('\n');
	}
}
signed main()
{
	Solve();
}
```
## 整体二分
### [国家集训队]矩阵乘法

#### 题目描述

给你一个 $n \times n$ 的矩阵，不用算矩阵乘法，但是每次询问一个子矩形的第 $k$ 小数。

#### 输入格式

第一行有两个整数，分别表示矩阵大小 $n$ 和询问组数 $q$。

第 $2$ 到第 $(n + 1)$ 行，每行 $n$ 个整数，表示这个矩阵。第 $(i + 1)$ 行的第 $j$ 个数表示矩阵第 $i$ 行第 $j$ 列的数 $a_{i, j}$。

接下来 $q$ 行，每行五个整数 $x_1, y_1, x_2, y_2, k$，表示一组询问，要求找到以 $(x_1, y_1)$ 为左上角，$(x_2, y_2)$ 为右下角的子矩形中的第 $k$ 小数。

#### 输出格式

对于每组询问，输出一行一个整数表示答案。

#### 样例 #1

###### 样例输入 #1

```
2 2
2 1
3 4
1 2 1 2 1
1 1 2 2 3
```

#### 样例输出 #1

```
1
3
```
#### 数据规模与约定
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 500$，$1 \leq q \leq 6 \times 10^4$，$0 \leq a_{i, j} \leq 10^9$。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define int ll
#define ls p << 1
#define rs p << 1 | 1
#define lowbit(x) ((x) & (-x))
const int MaxN = 501;
const int MaxM = 1e6 + 100;
const int INF = 1e9;
int T, N, M, K;
int a[MaxN][MaxN], c[MaxM], tot;
int ans[MaxM];
int tree[MaxN][MaxN];
vector<pair<int, int> > G1[MaxM];
struct point
{
	int x1, x2;
	int y1, y2;
	int k, id;
}b[MaxM], q1[MaxM], q2[MaxM];
int ef(int x)
{
	int l = 1, r = tot;
	while (l <= r)
	{
		int mid = (l + r) >> 1;
		if (c[mid] >= x) r = mid - 1;
		else l = mid + 1;
	}
	return l;
}
void add1(int x, int y, int v)
{
	for (int i = x; i <= N; i += lowbit(i))
	{
		for (int j = y; j <= N; j += lowbit(j))
		{
			tree[i][j] += v;
		}
	}
}
int query(int x, int y)
{
	int ans = 0;
	for (int i = x; i; i -= lowbit(i))
	{
		for (int j = y; j; j -= lowbit(j))
		{
			ans += tree[i][j];
		}
	}
	return ans;
}
int query1(int x1, int y1, int x2, int y2)
{
	return query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);
}
void solve(int l, int r, int x, int y)
{
	if (l == r)
	{
		for (int i = x; i <= y; i++)
		{
			ans[b[i].id] = l;
		}
		return;
	}
	int mid = (l + r) >> 1;
	int sum1 = x - 1;
	int sum2 = y + 1;
	for (int i = l; i <= mid; i++)
	{
		for (int j = 0; j < (int)G1[i].size(); j++)
		{
			int x = G1[i][j].first;
			int y = G1[i][j].second;
			add1(x, y, 1);
		}
	}
	for (int i = x; i <= y; i++)
	{
		int k = query1(b[i].x1, b[i].y1, b[i].x2, b[i].y2);
		if (k >= b[i].k) q1[++sum1] = b[i];
		else q2[--sum2] = b[i];
	}
	for (int i = x; i <= sum1; i++)
	{
		b[i] = q1[i];
	}
	for (int i = sum2; i <= y; i++)
	{
		b[i] = q2[i];
	}
	solve(mid + 1, r, sum2, y);
	for (int i = l; i <= mid; i++)
	{
		for (int j = 0; j < (int)G1[i].size(); j++)
		{
			int x = G1[i][j].first;
			int y = G1[i][j].second;
			add1(x, y, -1);
		}
	}
	solve(l, mid, x, sum1);
}
inline void Solve()
{
	cin >> N >> M;
	for (int i = 1; i <= N; i++)
	{
		for (int j = 1; j <= N; j++)
		{
			cin >> a[i][j];
			c[++tot] = a[i][j];
		}
	}
	sort(c + 1, c + tot + 1);
	tot = unique(c + 1, c + tot + 1) - (c + 1);
	for (int i = 1; i <= N; i++)
	{
		for (int j = 1; j <= N; j++)
		{
			a[i][j] = ef(a[i][j]);
			G1[a[i][j]].push_back(make_pair(i, j));
		}
	}
	for (int i = 1; i <= M; i++)
	{
		b[i].id = i;
		cin >> b[i].x1;
		cin >> b[i].y1;
		cin >> b[i].x2;
		cin >> b[i].y2;
		cin >> b[i].k;
	}
	solve(1, tot, 1, M);
	for (int i = 1; i <= M; i++)
	{
		cout << c[ans[i]] << endl;
	}
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	T = 1;
	while (T--)
		Solve();
}
```
## cdq分治
### 【模板】三维偏序（陌上花开）
$ 1 \leq n \leq 10^5$，$1 \leq a_i, b_i, c_i \le k \leq 2 \times 10^5 $。
三维比较，先按 $a$ 排序, 在分治中按 $b$ 排序, 将 $c$ 放入树状数组求解。
```cpp
// map<pair<int, int>, int> ans;
int ans[MaxN];
struct CDQ {
	int tree[MaxN];
	// 求 a_i <= a_j, b_i <= b_j, c_i <= c_j 的数量
    // c范围要求为 1 到 MAXN
    int MAXN = 2e5, p;
    struct Point {
        int a, b, c;
        int cnt, ans; // 这个点的数量,答案
		int id;
        inline bool operator!=(const Point &aa) const {
            if (a != aa.a) return 1;
            if (b != aa.b) return 1;
            if (c != aa.c) return 1;
            return 0;
        }
		inline bool operator<(const Point &aa) const {
			if (a != aa.a) return a < aa.a;
			if (b != aa.b) return b < aa.b;
			return c < aa.c;
		}
    } a[MaxN], b[MaxN];
    void add1(int x, int v) {
        x++;
        for (; x <= MAXN; x += lowbit(x)) {
            tree[x] += v;
        }
    }
    int query(int x) {
        x++;
        int ans = 0;
        for (; x; x -= lowbit(x)) {
            ans += tree[x];
        }
        return ans;
    }
    inline bool cmp1(Point &x, Point &y) {
        if (x.a != y.a) return x.a < y.a;
        if (x.b != y.b) return x.b < y.b;
        return x.c < y.c;
    }
    void cdq(int l, int r) {
        if (l == r) return;
        int mid = (l + r) >> 1;
        cdq(l, mid);
        cdq(mid + 1, r);
        sort(b + l, b + mid + 1, [&](Point x, Point y) {
			if (x.b != y.b) return x.b < y.b;
			return x.c < y.c;
		});
        sort(b + mid + 1, b + r + 1, [&](Point x, Point y) {
			if (x.b != y.b) return x.b < y.b;
			return x.c < y.c;
		});
        int i = l;
        int j = mid + 1;
        while (j <= r) {
            while (i <= mid && b[i].b <= b[j].b) {
                add1(b[i].c, b[i].cnt);
                i++;
            }
            b[j].ans += query(b[j].c);
            j++;
        }
        for (int k = l; k < i; k++) {
            add1(b[k].c, -b[k].cnt);
        }
    }
    void clear() {
        ans.clear();
        p = 0;
    }
    void insert(int x, int y, int z, int cnt, int ans, int id) {
        a[++p] = { x, y, z, cnt, ans, id };
    }
	void solve() {
        int l = 1, r = p;
		sort(a + l, a + 1 + r);
		int tot = 0, sum = 0;
		for (int i = l; i <= r; i++) {
			sum += a[i].cnt;
			if (i == r || a[i] != a[i + 1]) {
				b[++tot] = a[i];
				b[tot].cnt = sum;
				sum = 0;
			}
		}
		cdq(1, tot);
		for (int i = 1; i <= tot; i++) {
			// if (b[i].c == 1) ans[make_pair(b[i].a, b[i].b)] = b[i].ans;

			ans[b[i].ans + b[i].cnt - 1] += b[i].cnt;
		}
	}
} TT;
```
## KD-Tree
```cpp
struct KDT {
    struct Point {
        int x[2];
        int v, sum;
        int l, r;
        int L[2], R[2];
        int d;
    } t[MaxN], l, h;
    int rt[LogN];
    int b[MaxN], cnt, tot;
    void clear() {
        for (int i = 0; i < LogN; i++) {
            rt[i] = 0;
        }
        tot = 0;
    }
    void upd(int p) {
        t[p].sum = t[t[p].l].sum + t[t[p].r].sum + t[p].v;
        for (int k : {0, 1}) {
            t[p].L[k] = t[p].R[k] = t[p].x[k];
            if (t[p].l) {
                t[p].L[k] = min(t[p].L[k], t[t[p].l].L[k]);
                t[p].R[k] = max(t[p].R[k], t[t[p].l].R[k]);
            }
            if (t[p].r) {
                t[p].L[k] = min(t[p].L[k], t[t[p].r].L[k]);
                t[p].R[k] = max(t[p].R[k], t[t[p].r].R[k]);
            }
        }
    }
    inline bool cmp1(int x, int y) { return t[x].x[0] < t[y].x[0]; }
    inline bool cmp2(int x, int y) { return t[x].x[1] < t[y].x[1]; }
    int build(int l, int r) {
        int mid = (l + r) >> 1;
        ld ave1 = 0, ave2 = 0, fc1 = 0, fc2 = 0;
        for (int i = l; i <= r; i++) {
            ave1 += t[b[i]].x[0];
            ave2 += t[b[i]].x[1];
        }
        ave1 /= (r - l + 1);
        ave2 /= (r - l + 1);
        for (int i = l; i <= r; i++) {
            fc1 += (t[b[i]].x[0] - ave1) * (t[b[i]].x[1] - ave1);
            fc2 += (t[b[i]].x[1] - ave2) * (t[b[i]].x[1] - ave2);
        }
        if (fc1 > fc2) {
            nth_element(b + l, b + mid, b + r + 1, [this](int x, int y) { return t[x].x[0] < t[y].x[0]; });
            t[b[mid]].d = 1;
        } else {
            nth_element(b + l, b + mid, b + r + 1, [this](int x, int y) { return t[x].x[1] < t[y].x[1]; });
            t[b[mid]].d = 2;
        }

        int x{b[mid]};
        if (l < mid) t[x].l = build(l, mid - 1);
        if (mid < r) t[x].r = build(mid + 1, r);
        upd(x);
        return x;
    }
    void append(int &p) {
        if (!p) return;
        b[++cnt] = p;
        append(t[p].l);
        append(t[p].r);
        p = 0;
    }
    int query(int p) {
        if (!p || t[p].L[0] > h.x[0] || t[p].R[0] < l.x[0] || t[p].L[1] > h.x[1] || t[p].R[1] < l.x[1]) return 0;
        if (t[p].L[0] >= l.x[0] && t[p].R[0] <= l.x[0] && t[p].R[1] <= h.x[1] && t[p].L[1] >= l.x[1]) return t[p].sum;
        int res = 0;
        if (t[p].x[0] >= l.x[0] && t[p].x[0] <= h.x[0] && t[p].x[1] >= l.x[1] && t[p].x[1] <= h.x[1]) {
            res += t[p].v;
        }
        return query(t[p].l) + query(t[p].r) + res;
    }
    void insert(int x, int y, int z) {
        t[++tot] = {x, y, z};
        b[cnt = 1] = tot;
        for (int i = 0; ; i++) {
            if (!rt[i]) {
                rt[i] = build(1, cnt);
                break;
            } else {
                append(rt[i]);
            }
        }
    }
    int query(int x1, int y1, int x2, int y2) {
        l = {x1, y1};
        h = {x2, y2};
        int ans = 0;
        for (int i = 0; i < LogN; i++) {
            ans += query(rt[i]);
        }
        return ans;
    }
} TT;
```
 ## 并查集
```cpp
struct DSU{
    vector<int> fn;
    DSU(int n){
        for(int i=0;i<=n;i++){
            fn.push_back(i);
        }
    }
    int find(int x){
        if(fn[x]==x){
            return x;
        }
        return fn[x]=find(fn[x]);
    }
    void join(int x,int y){
        int fx=find(x),fy=find(y);
        if(fx!=fy){
            fn[fx]=fy;
        }
    }
};
```
## 带权并查集
一行，一个整数，表示假话的总数。
### 题解
$g[x]$表示$x$到根节点的权值和
```cpp
struct DSU {
	vector<int> fa, siz, sum, g;
    vector<pair<int, int>> tmp;
	DSU(int n) {
		fa.assign(n + 1, 0);
		siz.assign(n + 1, 1);
		sum.assign(n + 1, 0);
		g.assign(n + 1, 0);
		for (int i = 1; i <= n; i++) {
			fa[i] = i;
			sum[i] = i;
		}
	}
	// int find(int x) {
	// 	if (fa[x] == x) return x;
	// 	auto f = find(fa[x]);
	// 	g[x] += g[fa[x]];
	// 	return fa[x] = f;
	// }
    int find(int x) {
        if (fa[x] == x) return x;
        return find(fa[x]);
    }
	void hebin(int x, int y) {
		x = find(x);
		y = find(y);
		if (x == y) {
            tmp.emplace_back(-1, -1);
            return;
        }
		if (siz[x] < siz[y]) swap(x, y);
        tmp.emplace_back(x, y);
		fa[y] = x;
		siz[x] += siz[y];
		sum[x] += sum[y];
	}
    void undone() { //撤销
        auto [x, y] = tmp.back();
        tmp.pop_back();
        if (x == -1) return;
        fa[y] = y;
        siz[x] -= siz[y];
        sum[x] -= sum[y];
    }
	void move(int x, int y) { // x -> y
		auto fx = find(x), fy = find(y);
		if (fx == fy) return;
		fa[x] = fy;
		--siz[fx], ++siz[fy];
		sum[fx] -= x, sum[fy] += x;
	}
};
```
## 离散化
```cpp
template<typename T> 
struct Map{
    vector<T> nums;

    Map() {}

    void add(T x){
        nums.push_back(x);
    }

    void build(){
        sort(nums.begin(), nums.end());
        nums.erase(unique(nums.begin(), nums.end()), nums.end());
    }

    int get(T x){
        return int(lower_bound(nums.begin(), nums.end(), x) - nums.begin()) + 1;
    }

    T val(int x){
        return nums[x - 1];
    }

    int size(){
        return (int)nums.size();
    }
};
```
## 手打队列
```cpp
    struct node
    {
        int l,r,v;
    }p[MaxN<<1];
    inline int newnode(int l,int r,int v)
    {
        p[++tot]=node{l,r,v};
        return tot;
    }
    struct que
    {
        int star,end,len;
        inline void push_back(int x)
        {
            if(!len) star=end=newnode(0,0,x);
            else p[end].r=newnode(end,0,x),end=p[end].r;
            len++;
        }
        inline int size()
        {
            return len;
        }
        inline int front()
        {
            return p[star].v;
        }
        inline int back()
        {
            return p[end].v;
        }
        inline void pop_front()
        {
            star=p[star].r;len--;
        }
        inline void pop_back()
        {
            end=p[end].l;
            len--;
        }
        inline void push(int x)
        {
            while(!size()&&a[back()]>a[x]) pop_back();
            push_back(x);
        }
    }dui[MaxN<<1],dui1[MaxN<<1],*q=dui+MaxN,*q1=dui1+MaxN;
```
## 点分治
### 【模板】点分治1

#### 题目描述

给定一棵有 $n$ 个点的树，询问树上距离为 $k$ 的点对是否存在。

#### 输入格式

第一行两个数 $n,m$。

第 $2$ 到第 $n$ 行，每行三个整数 $u, v, w$，代表树上存在一条连接 $u$ 和 $v$ 边权为 $w$ 的路径。

接下来 $m$ 行，每行一个整数 $k$，代表一次询问。

#### 输出格式

对于每次询问输出一行一个字符串代表答案，存在输出 `AYE`，否则输出 `NAY`。
##### 数据规模与约定。
- 对于 $100\%$ 的数据，保证 $1 \leq n\leq 10^4$，$1 \leq m\leq 100$，$1 \leq k \leq 10^7$，$1 \leq u, v \leq n$，$1 \leq w \leq 10^4$。
```cpp
struct dfz {
	int siz[MaxN], maxp[MaxN], vis[MaxN], dis[MaxN];
	bool judge[100000001];
	int a[MaxN], ans[MaxN];
	int tot, rt;
    inline void getzx(int x, int f) {
        siz[x] = 1;
        maxp[x] = 0;
        for (auto &[y, z] : G1[x]) {
            if (y == f || vis[y]) continue;
            getzx(y, x);
            siz[x] += siz[y];
            maxp[x] = max(maxp[x], siz[y]);
        }
        maxp[x] = max(maxp[x], tot - siz[x]);
        if (maxp[x] < maxp[rt]) rt = x;
    }
    void getdis(int x, int f, queue<int> &q) {
        q.push(dis[x]);
        for (auto &[y, z] : G1[x]) {
            if (vis[y] || y == f) continue;
            dis[y] = dis[x] + z;
            getdis(y, x, q);
        }
    }
    inline void clac(int x) {
        queue<int> q1;
        for (auto &[y, z]: G1[x]) {
            if (vis[y]) continue;
            queue<int> q;
            dis[y] = z;
            getdis(y, x, q);
            queue<int> q2 = q;
            while (!q.empty()) {
                auto now = q.front(); q.pop();
                for (int j = 1; j <= M; j++)
                    if (a[j] >= now) {
                        ans[j] |= judge[a[j] - now];
                    }
 
            }
            while (!q2.empty()) {
                auto now = q2.front(); q2.pop();
                judge[now] = 1;
                q1.push(now);
            }
            
        }
        while (!q1.empty()) {
            int x = q1.front();
            q1.pop();
            judge[x] = 0;
        }
    }
    void solve(int x) {
        vis[x] = 1;
        judge[0] = 1;
        clac(x);
        judge[0] = 0;
        for (auto &[y, z]: G1[x]) {
            if (vis[y]) continue;
            tot = siz[y];
            maxp[rt = 0] = INF;
            getzx(y, 0);
            solve(rt);
        }
    }
	void Solve() {
		tot = N;
		maxp[rt = 0] = INF;
		getzx(1, 0);
		solve(rt);
	}
} TT;
```
## 树上启发式合并
```cpp
struct Point {
	int maxn = 0;
	int sum = 0;
	map<int, int> mp;
	vector<int> li;
	void add1(int x) {
		mp[a[x]]++;
		if (mp[a[x]] > maxn) {
			maxn = mp[a[x]];
			sum = a[x];
		} else if (mp[a[x]] == maxn) {
			sum += a[x];
		}
		li.push_back(x);
	}
	int size() {
		return li.size();
	}
} sub[MaxN];
void dfs1(int x, int f) {
	int son = 0, maxn = 0;
	for (auto& y : G1[x]) {
		if (y == f) continue;
		dfs1(y, x);
		if (sub[fa[y]].size() > maxn) {
			maxn = sub[fa[y]].size();
			son = y;
		}
	}
	if (son) fa[x] = fa[son];
	for (auto& y : G1[x]) {
		if (y == son) continue;
		if (y == f) continue;
		for (auto& z : sub[fa[y]].li) {
			sub[fa[x]].add1(z);
		}
	}
	sub[fa[x]].add1(x);
	ans[x] = sub[fa[x]].sum;
}
```

# 数据结构
## ST 表
```cpp
struct ST {
	int LogN, N;
	vector<vector<int>> F1, F2;
	vector<int> logn;
	ST() {
		init(0);
	}
	ST(int n) {
		init(n);
	}
	inline void init(int n) {
		N = n;
		logn.assign(N + 1, 0);
		logn[0] = -1;
		for (int i = 1; i <= N; i++) {
			logn[i] = logn[i >> 1] + 1;
		}
		LogN = logn[N] + 1;
		F1.assign(N + 1, vector<int>(LogN + 1));
		F2.assign(N + 1, vector<int>(LogN + 1));
	}
    inline void pre() {
        for (int j = 1; j <= LogN; j++) {
            for (int i = 1; i + (1 << (j - 1)) <= N; i++) {
                F1[i][j] = max(F1[i][j - 1], F1[i + (1 << (j - 1))][j - 1]);
            }
        }
        for (int j = 1; j <= LogN; j++) {
            for (int i = 1; i + (1 << (j - 1)) <= N; i++) {
                F2[i][j] = min(F2[i][j - 1], F2[i + (1 << (j - 1))][j - 1]);
            }
        }
    }
    inline int querymax(int l, int r) {
        int s = logn[r - l + 1];
        return max(F1[l][s], F1[r - (1 << s) + 1][s]);
    }
    inline int querymin(int l, int r) {
        int s = logn[r - l + 1];
        return min(F2[l][s], F2[r - (1 << s) + 1][s]);
    }
};
```
## FHQ-treap
### 平衡树维护Hash
```cpp
struct FHQ_TREAP {
	struct Point {
		int l, r, p, s;
		Hash v, sum;
	} tree[MaxN];
	int tot = 0;
	inline void pushdown(int p) {

	}
	inline void pushup(int p) {
		tree[p].s = tree[tree[p].l].s + tree[tree[p].r].s + 1;
		tree[p].sum = tree[tree[p].l].sum * power[tree[tree[p].r].s + 1] +
						tree[tree[p].r].sum + tree[p].v * power[tree[tree[p].r].s];
		tree[p].sum = tree[p].sum % P;
	}
	inline Point pushup(Point now, Point l, Point r) {
		now.s = l.s + r.s + 1;
		now.sum = (l.sum * power[r.s + 1] % P + r.sum + now.v * power[r.s] % P) % P;
		return now;
	}
	inline int newnode(Hash v) {
		int x = ++tot;
		tree[x].v = tree[x].sum = v;
		tree[x].l = tree[x].r = 0;
		tree[x].p = rand() * rand();
		tree[x].s = 1;
		return x;
	}
	int hebin(int x, int y) {
		if (!x || !y) return x + y;
		if (tree[x].p < tree[y].p) {
			pushdown(x);
			tree[x].r = hebin(tree[x].r, y);
			pushup(x);
			// tree[x] = pushup(tree[x], tree[tree[x].l], tree[tree[x].r]);
			return x;
		} else {
			pushdown(y);
			tree[y].l = hebin(x, tree[y].l);
			pushup(y);
			// tree[y] = pushup(tree[y], tree[tree[y].l], tree[tree[y].r]);
			return y;
		}
	}
	void split(int x, int k, int &l, int &r) {
		if (!x) {
			l = r = 0;
			return;
		}
		pushdown(x);
		if (tree[tree[x].l].s + 1 <= k) {
			l = x;
			split(tree[x].r, k - (tree[tree[x].l].s + 1), tree[x].r, r);
		} else {
			r = x;
			split(tree[x].l, k, l, tree[x].l);
		}
		pushup(x);
		// tree[x] = pushup(tree[x], tree[tree[x].l], tree[tree[x].r]);
	}

	string a;
	int Build(int l, int r) {
		if (l == r) return newnode(a[l]);
		int mid = (l + r) >> 1;
		return hebin(Build(l, mid), Build(mid + 1, r));
	}
	Hash query(int l, int r) {
		int t1 = 0, t2 = 0, t3 = 0;
		split(rt, l - 1, t1, t2);
		split(t2, r - l + 1, t2, t3);
		Hash ans = tree[t2].sum;
		// dfs1(t2);
		// cerr << endl;
		rt = hebin(hebin(t1, t2), t3);
		return ans;
	}
	void change(int k, Hash v) {
		int t1 = 0, t2 = 0, t3 = 0;
		split(rt, k - 1, t1, t2);
		split(t2, 1, t2, t3);
		tree[t2].v = tree[t2].sum = v;
		rt = hebin(hebin(t1, t2), t3);
	}
	void add1(int k, Hash v) {
		int t1 = 0, t2 = 0, t3 = 0;
		split(rt, k, t1, t3);
		t2 = newnode(v);
		rt = hebin(hebin(t1, t2), t3);
	}
	void dfs1(int x) {
		if (!x) return;
		dfs1(tree[x].l);
		cerr << x << ' ';
		dfs1(tree[x].r);
	}
} TT;
```
### 普通平衡树
```cpp
struct FHQ_TREAP {
	struct Point {
		int l, r, p, s;
		int v, sum;
	} tree[MaxN];
	int tot = 0;
	inline void pushdown(int p) {

	}
	inline void pushup(int p) {
		tree[p].s = tree[tree[p].l].s + tree[tree[p].r].s + 1;

	}
	inline Point pushup(Point now, Point l, Point r) {
		now.s = l.s + r.s + 1;
		return now;
	}
	inline int newnode(int v) {
		int x = ++tot;
		tree[x].v = tree[x].sum = v;
		tree[x].l = tree[x].r = 0;
		tree[x].p = rand() * rand();
		tree[x].s = 1;
		return x;
	}
	int hebin(int x, int y) {
		if (!x || !y) return x + y;
		if (tree[x].p < tree[y].p) {
			pushdown(x);
			tree[x].r = hebin(tree[x].r, y);
			pushup(x);
			// tree[x] = pushup(tree[x], tree[tree[x].l], tree[tree[x].r]);
			return x;
		} else {
			pushdown(y);
			tree[y].l = hebin(x, tree[y].l);
			pushup(y);
			// tree[y] = pushup(tree[y], tree[tree[y].l], tree[tree[y].r]);
			return y;
		}
	}
	void split_v(int x, int k, int &l, int &r) {
		if (!x) {
			l = r = 0;
			return;
		}
		pushdown(x);
		if (tree[x].v <= k) {
			l = x;
			split_v(tree[x].r, k, tree[x].r, r);
		} else {
			r = x;
			split_v(tree[x].l, k, l, tree[x].l);
		}
		pushup(x);
	}
	void split(int x, int k, int &l, int &r) {
		if (!x) {
			l = r = 0;
			return;
		}
		pushdown(x);
		if (tree[tree[x].l].s + 1 <= k) {
			l = x;
			split(tree[x].r, k - (tree[tree[x].l].s + 1), tree[x].r, r);
		} else {
			r = x;
			split(tree[x].l, k, l, tree[x].l);
		}
		pushup(x);
		// tree[x] = pushup(tree[x], tree[tree[x].l], tree[tree[x].r]);
	}

	int Build(int l, int r) {
		if (l == r) return newnode(a[l]);
		int mid = (l + r) >> 1;
		return hebin(Build(l, mid), Build(mid + 1, r));
	}
	int query(int l, int r) {
		int t1 = 0, t2 = 0, t3 = 0;
		split(rt, l - 1, t1, t2);
		split(t2, r - l + 1, t2, t3);
		int ans = tree[t2].sum;
		// dfs1(t2);
		// cerr << endl;
		rt = hebin(hebin(t1, t2), t3);
		return ans;
	}
	void change(int k, int v) {
		int t1 = 0, t2 = 0, t3 = 0;
		split(rt, k - 1, t1, t2);
		split(t2, 1, t2, t3);
		tree[t2].v = tree[t2].sum = v;
		rt = hebin(hebin(t1, t2), t3);
	}
	void add1(int v) { //插入一个数 $x$
		int t1 = 0, t2 = 0, t3 = 0;
		split_v(rt, v, t1, t3);
		t2 = newnode(v);
		rt = hebin(hebin(t1, t2), t3);
	}
	void delet(int v) { //删除一个数 $x$（若有多个相同的数，应只删除一个）
		int t1 = 0, t2 = 0, t3 = 0;
		split_v(rt, v - 1, t1, t2);
		split_v(t2, v, t2, t3);
		t2 = hebin(tree[t2].l, tree[t2].r);
		rt = hebin(hebin(t1, t2), t3);
	}
	int rank(int v) { //定义排名为比当前数小的数的个数 +1。查询x的排名。
		int t1 = 0, t2 = 0, t3 = 0;
		split_v(rt, v - 1, t1, t3);
		int ans = tree[t1].s + 1;
		rt = hebin(hebin(t1, t2), t3);
		return ans;
	}
	int find_min(int  x) {
		while (tree[x].l) {
			x = tree[x].l;
		}
		return tree[x].v;
	}
	int find_max(int x) {
		while (tree[x].r) {
			x = tree[x].r;
		}
		return tree[x].v;
	}
	int ith(int k) { //查询数据结构中排名为x的数
		int t1 = 0, t2 = 0, t3 = 0;
		split(rt, k, t1, t3);
		int ans = find_max(t1);
		rt = hebin(hebin(t1, t2), t3);
		return ans;
	}
	int get_pre(int v) { //求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）。
		int t1 = 0, t2 = 0, t3 = 0;
		split_v(rt, v - 1, t1, t3);
		int ans = find_max(t1);
		rt = hebin(hebin(t1, t2), t3);
		return ans;
	}
	int get_next(int v) { //求 $x$ 的后继（后继定义为大于 $x$，且最小的数）
		int t1 = 0, t2 = 0, t3 = 0;
		split_v(rt, v, t1, t3);
		int ans = find_min(t3);
		rt = hebin(hebin(t1, t2), t3);
		return ans;
	}
	void dfs1(int x) {
		if (!x) return;
		dfs1(tree[x].l);
		cerr << tree[x].v << ' ';
		dfs1(tree[x].r);
	}
} TT;
```

#### 添点
```cpp
inline void add1(int x, int v) {
    tree[x].v = v;
    tree[x].l = tree[x].r = 0;
    tree[x].p = rand();
    tree[x].s = 1;
}
```
#### 合并
```cpp
int hebin(int x, int y) {
    if (!x || !y) return x + y;
    if (tree[x].p < tree[y].p) {
        pushdown(x);
        tree[x].r = hebin(tree[x].r, y);
        pushup(x);
        return x;
    } else {
        pushdown(y);
        tree[y].l = hebin(x, tree[y].l);
        pushup(y);
        return y;
    }
}
void split(int x, int k, int &l, int &r) {
    if (!x) {
        l = r = 0;
        return;
    }
    pushdown(x);
    if (tree[x].v <= k) {
        l = x;
        split(tree[x].r, k, tree[x].r, r);
    } else {
        r = x;
        split(tree[x].l, k, l, tree[x].l);
    }
    pushup(x);
}
```
#### 分裂
##### 普通
```cpp
void split(int x, int key, int &l, int &r) {
    if (!x) {
        l = r = 0;
        return;
    }
    pushdown(x);
    if (tree[tree[x].l].s + 1 <= key) {
        l = x;
        split(tree[x].r, key - (tree[tree[x].l].s + 1), tree[x].r, r);
    } else {
        r = x;
        split(tree[x].l, key, l, tree[x].l);
    }
    updata(x);
}
```
##### 区间分裂
```cpp
void split_new(int x,int k)
{
    if(k>=tree[x].y-tree[x].x+1) return;
    int t=tree[x].x+k-1;
    int nn=newnode(t+1,tree[x].y);
    tree[x].y=t;
    tree[x].r=hebin(nn,tree[x].r);
    updata(x);
}
void split(int x,int k,int &l,int &r)
{
    if(!x)
    {
        l=r=0;
        return;
    }
    if(tree[tree[x].l].s>=k)
    {
        r=x;
        split(tree[x].l,k,l,tree[x].l);
    }
    else
    {
        l=x;
        split_new(x,k-tree[tree[x].l].s);
        split(tree[x].r,k-(tree[tree[x].l].s
        +tree[x].y-tree[x].x+1),tree[x].r,r);
    }
    updata(x);
}
```
### $\mathcal{O}(1)$建树
```cpp
inline int Build(int l,int r)
{
    if(l==r) return add1(a[l]);
    int mid=l+r;mid>>=1;
    return hebin(Build(l,mid),Build(mid+1,r));
}
```
### FHQ-Treap给编号寻位置
```cpp
int ith(int x)
{
    int ans=tree[x].s-tree[tree[x].r].s;
    while(x!=rt)
    {
        if(tree[tree[x].fa].r==x) 
        ans+=tree[tree[x].fa].s-tree[x].s;
        x=tree[x].fa;
    }
    return ans;
}

int t=(--mp.lower_bound(x+1))->second;
```
## 【模板】文艺平衡树（Splay）

### 题目描述

您需要写一种数据结构（可参考题目标题），来维护一个有序数列。  

其中需要提供以下操作：翻转一个区间，例如原有序序列是 $5\ 4\ 3\ 2\ 1$，翻转区间是 $[2,4]$ 的话，结果是 $5\ 2\ 3\ 4\ 1$。

#### 输入格式

第一行两个正整数 $n,m$，表示序列长度与操作个数。序列中第 $i$ 项初始为 $i$。  
接下来 $m$ 行，每行两个正整数 $l,r$，表示翻转的区间。

#### 输出格式

输出一行 $n$ 个正整数，表示原始序列经过 $m$ 次变换后的结果。
#### 思路  
Splay区间操作思想，如果修改区间$[l,r]$，则将$[l,r]$区间放到一颗子树上。  
将$(l-1)$移到根部，$(r+1)$移动到根部的右子树上，那么要修改的所有区间都在他的左子树上，放个懒标记修改就好。 
由于涉及到$l-1和r+1$所以将$0和N+1$加入到子树中  
***$l=ith(l),r=ith(r+2)$***  
$l-1$的排名在第$l$位置   ,$r+1$的排名在第$r+2$位置   
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define int ll
#define zuo p<<1
#define you p<<1|1
#define lowbit(x) ((x)&(-x))
const int MaxN=1e6+100;
int N,M,rt,tot;
struct point
{
    int s,fa,ch[2],v,lan;
}tree[MaxN];
inline void push_up(int x)
{
    tree[x].s=tree[tree[x].ch[0]].s+tree[tree[x].ch[1]].s+1;
    // tree[tree[x].ch[0]].fa=x;
    // tree[tree[x].ch[1]].fa=x;
}
inline void overturn(int x)
{
    swap(tree[x].ch[0],tree[x].ch[1]);
    tree[x].lan^=1;
}
inline void push_down(int x)
{
    if(tree[x].lan)
    {
        if(tree[x].ch[0])
        overturn(tree[x].ch[0]);
        if(tree[x].ch[1])
        overturn(tree[x].ch[1]);
        tree[x].lan=0;
    }
}
inline bool get(int x)
{
    return x==tree[tree[x].fa].ch[1];
}
inline void rotate(int x)
{
    int y=tree[x].fa,z=tree[y].fa,chk=get(x);
    tree[y].ch[chk]=tree[x].ch[chk^1];
    if(tree[x].ch[chk^1]) tree[tree[x].ch[chk^1]].fa=y;
    tree[x].ch[chk^1]=y;
    tree[y].fa=x;
    tree[x].fa=z;
    if(z) tree[z].ch[y==tree[z].ch[1]]=x;
    push_up(y);
    push_up(x);
}
inline void splay(int x,int k)
{
    for(int f=tree[x].fa;f=tree[x].fa,f!=k;rotate(x))
        if(tree[f].fa!=k) rotate(get(x)==get(f)?f:x);
    if(k==0)
    rt=x;
}
inline int add1(int v)
{
    int x=++tot;
    tree[x].s=1;
    tree[x].ch[0]=0;
    tree[x].ch[1]=0;
    tree[x].v=v;
    return x;
}
void ins(int v)
{
    if(!rt)
    {
        rt=add1(v);
        push_up(rt);
        return ;
    }
    int x=rt,f=0;
    while(1)
    {
        push_down(x);
        f=x;
        if(v<=tree[x].v)
            x=tree[x].ch[0];
        else
            x=tree[x].ch[1];
        if(!x)
        {
            x=add1(v);
            tree[x].fa=f;
            tree[f].ch[v>tree[f].v]=x;
            push_up(x);
            push_up(f);
            splay(x,0);
            break;
        }
    }
}
inline int ith(int k)
{
    int x=rt;
    while(x)
    {
        push_down(x);
        if(tree[tree[x].ch[0]].s+1==k)
            return x;
        else if(tree[tree[x].ch[0]].s+1>k)
            x=tree[x].ch[0];
        else if(tree[tree[x].ch[0]].s+1<k)
        {
            k-=(tree[tree[x].ch[0]].s+1);
            x=tree[x].ch[1];
        }
    }
    return 0;
}
inline void change(int x,int y)
{
    int l=ith(x),r=ith(y+2);
    splay(l,0);
    splay(r,l);
    int pos=tree[rt].ch[1];
    overturn(tree[pos].ch[0]);
}
inline void dfs1(int x)
{
    push_down(x);
    if(tree[x].ch[0]) dfs1(tree[x].ch[0]);
    if(tree[x].v&&tree[x].v!=N+1)
    qput(tree[x].v),putchar(' ');
    if(tree[x].ch[1]) dfs1(tree[x].ch[1]);
}
signed main()
{
    qread(N);qread(M);
    for(int i=0;i<=N+1;i++) ins(i);
//	dfs1(rt);putchar('\n');
    for(int i=1;i<=M;i++)
    {
        int x,y;qread(x);qread(y);
        change(x,y);
//		dfs1(rt);putchar('\n');
    }
    dfs1(rt);
}
```
## 树状数组
```cpp
template <typename T>
struct Fenwick {
    int n;
    std::vector<T> a;
    
    Fenwick(int n_ = 0) {
        init(n_);
    }
    
    void init(int n_) {
        n = n_;
        a.assign(n + 1, T{});
    }
    
    void add(int x, const T &v) {
        for (int i = x; i <= n; i += i & -i) {
            a[i] = a[i] + v;
        }
    }
    
    T sum(int x) {
        T ans{};
        for (int i = x; i; i -= i & -i) {
            ans = ans + a[i];
        }
        return ans;
    }
    
    T sum(int l, int r) {
        return sum(r) - sum(l - 1);
    }
    
    int select(const T &k) {
        int x = 0;
        T cur{};
        for (int i = 1 << std::__lg(n); i; i /= 2) {
            if (x + i <= n && cur + a[x + i] <= k) {
                x += i;
                cur = cur + a[x];
            }
        }
        return x;
    }
};
```
## 线段树
```cpp
struct Segment {
	struct Point {
		int sum, lsum, rsum, lans, rans, ans, segans;
		Point (): sum(0), lsum(INF), rsum(0), lans(-INF), rans(-INF), segans(-INF) {};
		void print() {
			cerr << sum << ' ';
			cerr << lsum << ' ';
			cerr << rsum << ' ';
			cerr << lans << ' ';
			cerr << rans << ' ';
			cerr << ans << ' ';
		}
	} tree[MaxN << 2], ts;
	inline Point pushup(Point L, Point R) {
		Point now = Point();
		now.sum = L.sum + R.sum;
		now.lsum = min(L.lsum, L.sum + R.lsum);
		now.rsum = max(R.rsum, L.rsum + R.sum);

		now.lans = L.sum - R.lsum;
		now.lans = max(now.lans, L.lans);
		now.lans = max(now.lans, L.sum + R.lans);
		now.lans = max(now.lans, L.segans - R.lsum);
		
		now.rans = L.rsum - R.sum;
		now.rans = max(now.rans, R.rans);
		now.rans = max(now.rans, L.rsum + R.segans);
		now.rans = max(now.rans, L.rans - R.sum);

		now.segans = max({L.segans - R.sum, L.sum + R.segans, L.sum - R.sum});

		now.ans = L.rsum - R.lsum;
		now.ans = max(now.ans, L.rsum + R.lans);
		now.ans = max(now.ans, L.ans);
		now.ans = max(now.ans, R.ans);
		now.ans = max(now.ans, L.rans - R.lsum);
		return now;
	}
	void build(int p, int l, int r) {
		if (l == r) {
			tree[p].sum = a[l];
			tree[p].lsum = a[l];
			tree[p].rsum = a[l];
			tree[p].lans = -INF;
			tree[p].rans = -INF;
			tree[p].ans = -INF;
			tree[p].segans = -INF;
			return;
		}
		int mid = (l + r) >> 1;
		build(ls, l, mid);
		build(rs, mid + 1, r);
		tree[p] = pushup(tree[ls], tree[rs]);
	}
	void change(int p, int l, int r, int k, int v) {
		if (l == r) {
			tree[p].sum = v;
			tree[p].lsum = v;
			tree[p].rsum = v;
			tree[p].lans = -INF;
			tree[p].rans = -INF;
			tree[p].ans = -INF;
			tree[p].segans = -INF;
			return;
		}
		int mid = (l + r) >> 1;
		if (mid >= k) change(ls, l, mid, k, v);
		else change(rs, mid + 1, r, k, v);
		tree[p] = pushup(tree[ls], tree[rs]);
	}
	Point query(int p, int l, int r, int x, int y) {
		if (l >= x && r <= y) {
			return tree[p];
		}
		int mid = (l + r) >> 1;
		if (mid >= x && mid < y) {
			return pushup(query(ls, l, mid, x, y), query(rs, mid + 1, r, x, y));
		}
		if (mid >= x) return query(ls, l, mid, x, y);
		if (mid < y) return query(rs, mid + 1, r, x, y);
		return Point();
	}
} TT;
```
```cpp
struct LazySegment {
	struct Point {
		int sum, lan, minn, v;
	} tree[MaxN << 2], ts;
	inline void js(int p, int l, int r, int v) {
		tree[p].sum += v * (r - l + 1);
		tree[p].minn += v;
		tree[p].lan += v;
	}
	inline void pushdown(int p, int l, int r) {
		int mid{(l + r) >> 1};
		js(ls, l, mid, tree[p].lan);
		js(rs, mid + 1, r, tree[p].lan);
		tree[p].lan = 0;
	}
	inline Point pushup(Point L, Point R) {
		Point now = {};
		now.sum = L.sum + R.sum;
		now.minn = min(L.minn, R.minn);
		return now;
	}
	void build(int p, int l, int r) {
		if (l == r) {
			tree[p] = {};
			return;
		}
		int mid = (l + r) >> 1;
		pushdown(p, l, r);
		build(ls, l, mid);
		build(rs, mid + 1, r);
		tree[p] = pushup(tree[ls], tree[rs]);
	}
	void change(int p, int l, int r, int x, int y, int v) {
		if (l >= x && r <= y) {
			js(p, l, r, v);
			return;
		}
		int mid = (l + r) >> 1;
		pushdown(p, l, r);
		if (mid >= x) change(ls, l, mid, x, y, v);
		if (mid < y) change(rs, mid + 1, r, x, y, v);
		tree[p] = pushup(tree[ls], tree[rs]);
	}
	Point query(int p, int l, int r, int x, int y) {
		if (l >= x && r <= y) {
			return tree[p];
		}
		int mid = (l + r) >> 1;
		pushdown(p, l, r);
		if (mid >= x && mid < y) {
			return pushup(query(ls, l, mid, x, y), query(rs, mid + 1, r, x, y));
		}
		if (mid >= x) return query(ls, l, mid, x, y);
		if (mid < y) return query(rs, mid + 1, r, x, y);
		return Point();
	}
} TT;
```
### Introl
```cpp
struct segment{
	struct Tree{
		int l, r;
		int tag, sum, mex;
	}t[MaxN<<2];
	#define ls p<<1
	#define rs p<<1|1
	int midd(int p){
		return (t[p].l + t[p].r) >> 1;
	}
	void push_up(int p){
		t[p].sum = t[ls].sum + t[rs].sum;
		t[p].mex = max(t[ls].mex,t[rs].mex);
	}
	void pls(int p, int k){
		t[p].tag += k;
		t[p].sum += (t[p].r - t[p].l + 1) * k;
		t[p].mex += k;
	}
	void push_down(int p){
		if(t[p].tag){
			pls(ls, t[p].tag);
			pls(rs, t[p].tag);
			t[p].tag = 0;
		}
	}
	void build(int p, int l, int r){
		t[p].l = l, t[p].r = r;
		if(l == r){
			t[p].sum = a[l];
			t[p].mex = a[l];
			return ;
		}
		build(ls, l, midd(p));
		build(rs, midd(p) + 1, r);
		push_up(p);
	}
	void dfs(int p,int l,int r){
        if(l==r){
            a[l]=t[p].mex;
        }
        int mid=midd(p);
        push_down(p);
        dfs(ls,l,mid);
        dfs(rs,mid+1,r);
        push_up(p);
    }
	void change(int p, int nl, int nr, int k){
		int l = t[p].l, r = t[p].r;
		if(nl <= l &&r <= nr){
			pls(p, k);
			return ;
		}
		int mid = midd(p);
		push_down(p);
		if(nl <= mid){
			change(ls, nl, nr, k);
		}
		if(mid < nr){
			change(rs, nl, nr, k);
		}
		push_up(p);
	}
	int query_sum(int p, int nl, int nr){
		int l = t[p].l, r = t[p].r;
		if(nl <= l && r <= nr){
			return t[p].sum;
		}
		int mid = midd(p), ans = 0;
		push_down(p);
		if(nl <= mid){
			ans += query_sum(ls, nl, nr);
		}
		if(mid < nr){
			ans += query_sum(rs, nl, nr);
		}
		return ans;
	}
	int query_max(int p, int nl, int nr){
		int l = t[p].l, r = t[p].r;
		if(nl <= l&& r <= nr){
			return t[p].mex;
		}
		int mid = midd(p), maxn = -INF;
		push_down(p);
		if(nl <= mid){
			maxn = max(maxn, query_max(ls, nl, nr));
		}
		if(mid < nr){
			maxn=max(maxn, query_max(rs, nl, nr));
		}
		return maxn;
	}
};
```
```cpp
struct segment{
	struct Tree{
		int l, r;
		int add, sum, mex, mul = 1;
	}t[MaxN<<2];
	#define ls p<<1
	#define rs p<<1|1
	int midd(int p){
		return (t[p].l + t[p].r) >> 1;
	}
	void push_up(int p){
		t[p].sum = (t[ls].sum + t[rs].sum)%mod;
		t[p].mex = max(t[ls].mex,t[rs].mex);
	}
	void push_down(int p){
		t[ls].sum = (t[ls].sum * t[p].mul + t[p].add * (t[ls].r - t[ls].l + 1)) % mod;
		t[rs].sum = (t[rs].sum * t[p].mul + t[p].add * (t[rs].r - t[rs].l + 1)) % mod;

        t[ls].mex = (t[ls].mex * t[p].mul + t[p].add) % mod;
        t[rs].mex = (t[rs].mex * t[p].mul + t[p].add) % mod;

        t[ls].mul = (t[ls].mul * t[p].mul) % mod;
        t[rs].mul = (t[rs].mul * t[p].mul) % mod;
        
        t[ls].add = (t[ls].add * t[p].mul + t[p].add) % mod;
        t[rs].add = (t[rs].add * t[p].mul + t[p].add) % mod;

        t[p].add=0;
        t[p].mul=1;
	}
	void build(int p, int l, int r){
		t[p].l = l, t[p].r = r;
		if(l == r){
			t[p].sum = a[l];
			t[p].mex = a[l];
			return ;
		}
		build(ls, l, midd(p));
		build(rs, midd(p) + 1, r);
		push_up(p);
	}
	void dfs(int p,int l,int r){
        if(l==r){
            a[l]=t[p].mex;
        }
        int mid=midd(p);
        push_down(p);
        dfs(ls,l,mid);
        dfs(rs,mid+1,r);
        push_up(p);
    }
    void changeMul(int p, int nl, int nr, int k){
        int l = t[p].l, r = t[p].r;
        if(nl <= l && r <= nr){
            t[p].add = (t[p].add * k) % mod;
            t[p].mul = (t[p].mul * k) % mod;
            t[p].sum = (t[p].sum * k) % mod;
            t[p].mex = (t[p].sum * k) % mod;
            return ;
        }
        int mid = midd(p);
        push_down(p);
        if(nl <= mid){
            changeMul(ls, nl, nr, k);
        }
        if(mid < nr){
            changeMul(rs, nl, nr, k);
        }
        push_up(p);
    }
	void changeAdd(int p, int nl, int nr, int k){
		int l = t[p].l, r = t[p].r;
		if(nl <= l && r <= nr){
			t[p].add = (t[p].add + k) % mod;
		    t[p].sum = (t[p].sum + (t[p].r - t[p].l + 1) * k) % mod;
		    t[p].mex = (t[p].mex + k) % mod;
			return ;
		}
		int mid = midd(p);
		push_down(p);
		if(nl <= mid){
			changeAdd(ls, nl, nr, k);
		}
		if(mid < nr){
			changeAdd(rs, nl, nr, k);
		}
		push_up(p);
	}
	int query_sum(int p, int nl, int nr){
		int l = t[p].l, r = t[p].r;
		if(nl <= l && r <= nr){
			return t[p].sum;
		}
		int mid = midd(p), ans = 0;
		push_down(p);
		if(nl <= mid){
			ans += query_sum(ls, nl, nr);
		}
		if(mid < nr){
			ans += query_sum(rs, nl, nr);
		}
		return ans;
	}
	int query_max(int p, int nl, int nr){
		int l = t[p].l, r = t[p].r;
		if(nl <= l&& r <= nr){
			return t[p].mex;
		}
		int mid = midd(p), maxn = -INF;
		push_down(p);
		if(nl <= mid){
			maxn = max(maxn, query_max(ls, nl, nr));
		}
		if(mid < nr){
			maxn=max(maxn, query_max(rs, nl, nr));
		}
		return maxn;
	}
}Tree;
```
## 权值线段树
```cpp
struct Segment {
	struct Point {
		int l, r, sum;
	};
	int tot;
	vector<Point> tree;
	Segment() {
		init();
	}
	Segment(int _n) {
		init(_n);
	}
	void init() {
		tree.clear();
		tot = 0;
	}
	void init(int _n) {
		tree.clear();
		tot = 0;
		tree.assign(_n, {});
	}

	inline Point pushup(Point L, Point R) {
		Point now = Point();
		now.sum = L.sum + R.sum;
		return now;
	}

	inline void pushup(int p) {
		tree[p].sum = tree[tree[p].l].sum + tree[tree[p].r].sum;
	}

	int change(int p, int l, int r, int k, int v) {
		while (tree.size() <= tot + 10) tree.push_back({});
		if (!p) {
			p = ++tot;
		}
		if (l == r) {
			tree[p].sum += v;
			return p;
		}
		int mid = (l + r) >> 1;
		if (mid >= k) tree[p].l = change(tree[p].l, l, mid, k, v);
		else tree[p].r = change(tree[p].r, mid + 1, r, k, v);
		pushup(p);
		return p;
	}

	int query(int p, int l, int r, int k) {
		if (l == r) return l;
		int now = tree[tree[p].l].sum;
		int mid = (l + r) >> 1;
		if (now >= k) return query(tree[p].l, l, mid, k);
		else return query(tree[p].r, mid + 1, r, k - now);
	}
} TT(MaxN);
```
## 树链剖分
```cpp
struct TT {
	int deep[MaxN], father[MaxN], siz[MaxN], son[MaxN];//deep->深度 father->父节点 siz->子树大小 son->重儿子
	int seg[MaxN], top[MaxN], rev[MaxN];
	inline void dfs1(int x, int f) {
		deep[x] = deep[f] + 1;
		father[x] = f;
		siz[x] = 1;
		for (auto y : G1[x]) {
			if (y == f) continue;
			dfs1(y, x);
			siz[x] += siz[y];
			if (siz[son[x]] < siz[y])
				son[x] = y;
		}
	}
	inline void dfs2(int x, int f) {
		if (son[x]) {
			seg[son[x]] = ++seg[0];
			top[son[x]] = top[x];
			rev[seg[0]] = son[x];
			dfs2(son[x], x);
		}
		for (auto y : G1[x]) {
			if (y != son[x] && y != f) {
				top[y] = y;
				seg[y] = ++seg[0];
				rev[seg[0]] = y;
				dfs2(y, x);
			}
		}
	}
	void pre() {
		dfs1(1, 0);
		seg[0] = seg[1] = rev[1] = top[1] = 1;
		dfs2(1, 0);
	}
	void print(int x){
		
	}
	struct Point {
		int sum, lan, maxn;
	} tree[MaxN << 2];
	inline void pushup(int p) {
		tree[p].sum = tree[ls].sum + tree[rs].sum;
		tree[p].maxn = max(tree[ls].maxn, tree[rs].maxn);
	}
	void build(int p, int l, int r) {
		if (l == r) {
			tree[p].sum = tree[p].maxn = deep[rev[l]];
			return;
		}
		int mid = (l + r) >> 1;
		build(ls, l, mid);
		build(rs, mid + 1, r);
		pushup(p);
	}
	inline void js(int p, int l, int r, int z) {
		tree[p].sum += (r - l + 1) * z;
		tree[p].lan += z;
		tree[p].maxn += z;
	}
	inline void pushdown(int p, int l, int r) {
		int mid = (l + r) >> 1;
		js(ls, l, mid, tree[p].lan);
		js(rs, mid + 1, r, tree[p].lan);
		tree[p].lan = 0;
	}
	void change(int p, int l, int r, int x, int y, int z) {
		if (l >= x && r <= y) {
			js(p, l, r, z);
			return;
		}
		pushdown(p, l, r);
		int mid = (l + r) >> 1;
		if (mid >= x) change(ls, l, mid, x, y, z);
		if (mid < y) change(rs, mid + 1, r, x, y, z);
		pushup(p);
	}
	int query(int p, int l, int r, int x, int y) {
		if (l >= x && r <= y) {
			return tree[p].maxn;
		}
		pushdown(p, l, r);
		int mid = (l + r) >> 1;
		int maxn = 0;
		if (mid >= x) maxn = max(maxn, query(ls, l, mid, x, y));
		if (mid < y) maxn = max(maxn, query(rs, mid + 1, r, x, y));
		return maxn;
	}
	inline void change1(int x, int y, int z) { //x -> y 链上值+z
		int fx = top[x], fy = top[y];
		while (fx != fy) {
			if (deep[fx] < deep[fy]) swap(x, y), swap(fx, fy);
			change(1, 1, seg[0], seg[fx], seg[x], 1);
			x = father[fx];
			fx = top[x];
		}
		if (deep[x] < deep[y]) swap(x, y);
		change(1, 1, seg[0], seg[y], seg[x], z);
	}
	inline void changeroot(int x, int z) {
		int l = seg[x];
		int r = seg[x] + siz[x] - 1;
		change(1, 1, seg[0], l, r, z);
	}
	inline int query1(int x) { // x为根的最大值
		int l = seg[x];
		int r = seg[x] + siz[x] - 1;
		int ans = query(1, 1, seg[0], l, r);
		return ans;
	}
	inline int lca(int x, int y) {
		int fx = top[x], fy = top[y];
		while (fx != fy) {
			if (deep[fx] < deep[fy]) swap(x, y), swap(fx, fy);
			x = father[fx];
			fx = top[x];
		}
		return deep[x] < deep[y] ? x : y;
	}
} TT;
```
### Introl
```cpp
struct TT{
    int dep[MaxN],father[MaxN],siz[MaxN],son[MaxN];
    //dep表示深度，father表示父节点，siz表示子树大小，son表示重儿子
    int dfn[MaxN],top[MaxN],rnk[MaxN];
    //dfn表示DFS序，top表示重链的顶部节点，rnk表示DFS序表示的节点编号，rnk(dfn(x))=x
    
    void dfs1(int x,int fa){
        dep[x]=dep[fa]+1;
        father[x]=fa;
        siz[x]=1;
        for(auto y:G1[x]){
            if(y==fa)continue;
            dfs1(y,x);
            siz[x]+=siz[y];
            if(siz[son[x]]<siz[y])
                son[x]=y;
        }
    }
    void dfs2(int x,int fa){
        if(son[x]){
            dfn[son[x]]=++dfn[0];
            top[son[x]]=top[x];
            rnk[dfn[0]]=son[x];
            dfs2(son[x],x);
        }
        for(auto y:G1[x]){
            if(y!=son[x]&&y!=fa){
                top[y]=y;
                dfn[y]=++dfn[0];
                rnk[dfn[0]]=y;
                dfs2(y,x);
            }
        }
    }
    void init(){
        dfs1(1,0);
        dfn[0]=dfn[1]=rnk[1]=top[1]=1;
        dfs2(1,0);
    }
    void init(int root){
        dfs1(root,0);
        dfn[0]=dfn[root]=1;
        top[root]=root;
        rnk[1]=root;
        dfs2(root,0);
    }


    void debug(int x){
        cerr<<x<<" "<<dfn[x]<<endl;
    }


    
    struct Point{
        int l,r;
        int tag;
        int sum,mex;
    }t[MaxN<<2];
    #define ls p<<1
    #define rs p<<1|1
    int midd(int p){
        return (t[p].l+t[p].r)>>1;
    }
    void push_up(int p){
        t[p].mex=max(t[ls].mex,t[rs].mex);
        t[p].sum+=t[rs].sum;
    }
    void build(int p,int l,int r){
        t[p].l=l,t[p].r=r;
        if(l==r){
            t[p].mex=t[p].sum=a[rnk[l]];
            return;
        }
        int mid=midd(p);
        build(ls,l,mid);
        build(rs,mid+1,r);
        push_up(p);
    }
    void pls(int p,int k){
        t[p].sum+=(t[p].r-t[p].l+1)*k);
        t[p].tag+=k;
        t[p].mex+=k;
    }
    void push_down(int p){
        if(t[p].tag){
            pls(ls,t[p].tag);
            pls(rs,t[p].tag);
            t[p].tag=0;
        }
    }
    void change(int p,int nl,int nr,int k){
        int l=t[p].l,r=t[p].r;
        if(nl<=l&&r<=nr){
            pls(p,k);
            return;
        }
        int mid=midd(p);
        push_down(p); 
        if(nl<=mid){
            change(ls,nl,nr,k);
        }
        if(mid<nr){
            change(rs,nl,nr,k);
        }
        push_up(p);
    }
    int query_max(int p,int nl,int nr){
        int l=t[p].l,r=t[p].r;
        if(nl<=l&&r<=nr){
            return t[p].mex;
        }
        int mid=midd(p),maxn=-INF;
        push_down(p);
        if(nl<=mid){
            maxn=max(maxn,query_max(ls,nl,nr));
        }
        if(mid<nr){
            maxn=max(maxn,query_max(rs,nl,nr));
        }
        return maxn;
    }
    int query_sum(int p,int nl,int nr){
        int l=t[p].l,r=t[p].r;
        if(nl<=l&&r<=nr){
            return t[p].sum;
        }
        int mid=midd(p),res=0;
        push_down(p);
        if(nl<=mid){
            res+=query_sum(ls,nl,nr);
        }
        if(mid<nr){
            res+=query_sum(rs,nl,nr);
        }
        return res;
    }


    void treechange(int x,int y,int z){//(x->y)+z
        int fx=top[x],fy=top[y];
        while(fx!=fy){
            if(dep[fx]<dep[fy]){
                swap(x,y);
                swap(fx,fy);
            }
            change(1,dfn[fx],dfn[x],z);
            x=father[fx];
            fx=top[x];
            // cnt++;
            // cerr<<cnt<<endl;
        }
        if(dep[x]>dep[y])swap(x,y);
        change(1,dfn[x],dfn[y],z);
    }
    int treesum(int x,int y){
        int fx=top[x],fy=top[y];
        int res=0;
        while(fx!=fy){
            if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);
            res+=query_sum(1,dfn[fx],dfn[x]);
            x=father[fx];
            fx=top[x];
        }   
        if(dep[x]>dep[y])swap(x,y);
        res+=query_sum(1,dfn[x],dfn[y]);
        return res;
    }

    void changeroot(int x,int z){
        int l=dfn[x];
        int r=dfn[x]+siz[x]-1;
        // cerr<<dfn[x]<<" "<<dfn[x]+siz[x]-1<<endl;
        // cerr<<query_sum(1,l,r)<<endl;
        
        change(1,l,r,z);
    }
    int queryroot(int x){
        int l=dfn[x];
        int r=dfn[x]+siz[x]-1;
        // debug(x);
        int ans=query_sum(1,l,r);
        // cerr<<"debug"<<rnk[dfn[x]]<<endl;
        // cerr<<"ans:"<<query_sum(1,3,3)<<endl;
        return ans;
    }


    int lca(int x,int y){
        int fx=top[x],fy=top[y];
        while(fx!=fy){
            if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);
            x=father[fx];
            fx=top[x];
        }
        return dep[x]<dep[y]?x:y;
    }
    
}Tree;
```

## 【模板】可持久化线段树 1（可持久化数组） 
### 题目描述

如题，你需要维护这样的一个长度为 $ N $ 的数组，支持如下几种操作


1. 在某个历史版本上修改某一个位置上的值

2. 访问某个历史版本上的某一位置的值


```cpp
struct Segment {
	struct Point {
		int l, r, sum;
	};
	int tot;
	vector<Point> tree;
	Segment() {
		init();
	}
	Segment(int _n) {
		init(_n);
	}
	void init() {
		tree.clear();
		tot = 0;
	}
	void init(int _n) {
		tree.clear();
		tot = 0;
		tree.assign(_n, {});
	}

	int change(int p, int l, int r, int k, int v) {
		while (tree.size() <= tot + 10) tree.push_back({});
		tree[++tot] = tree[p];
		p = tot;

		if (l == r) {
			tree[p].sum = v;
			return p;
		}

		int mid = (l + r) >> 1;
		if (mid >= k) tree[p].l = change(tree[p].l, l, mid, k, v);
		else tree[p].r = change(tree[p].r, mid + 1, r, k, v);
		return p;
	}

	int query(int p, int l, int r, int k) {
		if (l == r) return tree[p].sum;
		int mid = (l + r) >> 1;
		if (mid >= k) return query(tree[p].l, l, mid, k);
		else return query(tree[p].r, mid + 1, r, k);
	}
};
```
## 【模板】可持久化线段树 2(主席树)
```cpp 
struct Segment {
	struct Point {
		int l, r, sum;
	};
	int tot;
	vector<Point> tree;
	Segment() {
		init();
	}
	Segment(int _n) {
		init(_n);
	}
	void init() {
		tree.clear();
		tot = 0;
	}
	void init(int _n) {
		tree.clear();
		tot = 0;
		tree.assign(_n, {});
	}

	int change(int p, int l, int r, int k, int v) {
		while (tree.size() <= tot + 10) tree.push_back({});
		tree[++tot] = tree[p];
		p = tot;

		tree[p].sum += v;
		if (l == r) return p;

		int mid = (l + r) >> 1;
		if (mid >= k) tree[p].l = change(tree[p].l, l, mid, k, v);
		else tree[p].r = change(tree[p].r, mid + 1, r, k, v);
		return p;
	}

	int query(int p1, int p2, int l, int r, int k) { //第k小
		if (l == r) return l;
		int now = tree[tree[p2].l].sum - tree[tree[p1].l].sum;
		int mid = (l + r) >> 1;
		if (now >= k) return query(tree[p1].l, tree[p2].l, l, mid, k);
		else return query(tree[p1].r, tree[p2].r, mid + 1, r, k - now);
	}
};
``` 
## 可持久化并查集
```cpp
int rt[MaxN];
struct PersistantUnionSet{
	struct Point {
		int l, r, f, dep;
	};
	int tot;
	Point tree[MaxM];
	PersistantUnionSet() {
		init();
	}
	PersistantUnionSet(int _n) {
		init(_n);
	}
	void init() {
		// tree.clear();
		tot = 0;
	}
	void init(int _n) {
		// tree.clear();
		tot = 0;
		// tree.assign(_n, {});
	}

	int change(int p, int l, int r, int k, int f, int siz) {
		// while (tree.size() <= tot + 10) tree.push_back({});
		tree[++tot] = tree[p];
		p = tot;

		
		if (l == r) {
            tree[p].dep = siz;
            tree[p].f = f;
            return p;
        }

		int mid = (l + r) >> 1;
		if (mid >= k) tree[p].l = change(tree[p].l, l, mid, k, f, siz);
		else tree[p].r = change(tree[p].r, mid + 1, r, k, f, siz);
		return p;
	}

	Point query(int p, int l, int r, int k) { //第k小
		if (l == r) return tree[p];
		int mid = (l + r) >> 1;
		if (mid >= k) return query(tree[p].l, l, mid, k);
		else return query(tree[p].r, mid + 1, r, k);
	}

    pair<int, int> queryFa(int p, int pos) {
          auto [l, r, f, siz] = query(p, 1, N, pos);
          if (f == pos) return { f, siz };
          return queryFa(p, f);
    }
};
```
## ODT
```cpp
struct ODT {
    struct Point {
        int l, r;
        mutable int v;
        Point (int l, int r, int v) : l(l), r(r), v(v) {}
        inline bool operator<(const Point &aa) const {
            return l < aa.l;
        }
    };
    set<Point> odt;
    auto split(int x) { // [l, x) [x, r],指向后者 
        if (x > N) return odt.end();
        auto it = --odt.upper_bound(Point(x, 0, 0));
        if (it->l == x) return it;
        auto [l, r, v] = *it;
        odt.erase(it);
        odt.insert(Point(l, x - 1, v));
        return odt.insert(Point(x, r, v)).first;
    }

    void assign(int l, int r, int v) {
        auto itr = split(r + 1), itl = split(l);
        odt.erase(itl, itr);
        odt.insert(Point(l, r, v));
    }

    void insert(int l, int r, int v) {
        odt.insert(Point(l, r, v));
    }

    void performance(int l, int r) {
        auto itr = split(r + 1), itl = split(l);
        for (; itl != itr; ++itl) {
            auto &[l, r, v] = *itl;
            // Perform Operations here
        }
    }
};
```
## 【模板】左偏树（可并堆）

### 题目描述

如题，一开始有 $n$ 个小根堆，每个堆包含且仅包含一个数。接下来需要支持两种操作：

1. `1 x y`：将第 $x$ 个数和第 $y$ 个数所在的小根堆合并（若第 $x$ 或第 $y$ 个数已经被删除或第 $x$ 和第 $y$ 个数在用一个堆内，则无视此操作）。

2. `2 x`：输出第 $x$ 个数所在的堆最小数，并将这个最小数删除（若有多个最小数，优先删除先输入的；若第 $x$ 个数已经被删除，则输出 $-1$ 并无视删除操作）。

#### 输入格式

第一行包含两个正整数 $n, m$，分别表示一开始小根堆的个数和接下来操作的个数。

第二行包含 $n$ 个正整数，其中第 $i$ 个正整数表示第 $i$ 个小根堆初始时包含且仅包含的数。

接下来 $m$ 行每行 $2$ 个或 $3$ 个正整数，表示一条操作，格式如下：

操作 $1$：`1 x y`

操作 $2$：`2 x`

#### 输出格式

输出包含若干行整数，分别依次对应每一个操作 $2$ 所得的结果。
```cpp
int rt[MaxN], boo[MaxN];
struct LeftTree {
    struct Point {
		int d, l, r;
		int v;
		int s, sum;
	} tree[MaxN];
	void clear() {
		for (int i = 1; i <= N; i++) {
			rt[i] = i;
			tree[i].s = 1;
		}
		tree[0].d = -1;
	}
    int find1(int x) {
        if (x == rt[x]) return x;
        return rt[x] = find1(rt[x]);
    }
	inline void pushdown(int x) {}
	inline void pushup(int x) {
		tree[x].s = tree[tree[x].l].s + tree[tree[x].r].s + 1;
		tree[x].sum = tree[tree[x].l].sum + tree[tree[x].r].sum + tree[x].v;
	}
    int hebin(int x, int y) {
        if (!x || !y) return x + y;
        if (tree[x].v < tree[y].v) swap(x, y);
		pushdown(x);
        tree[x].r = hebin(tree[x].r, y);
        if (tree[tree[x].l].d < tree[tree[x].r].d) swap(tree[x].l, tree[x].r);
        tree[x].d = tree[tree[x].r].d + 1;
		pushup(x);
        return x;
    }
	int get(int x) {
		x = find1(x);
		return tree[x].v;
	}
	void delet(int x) {
		x = find1(x);
		boo[x] = 1;
		rt[tree[x].l] = rt[tree[x].r] = rt[x] = hebin(tree[x].l, tree[x].r);
		tree[x].l = tree[x].r = tree[x].d = 0;
		tree[x].s = tree[x].sum = 0;
	}
} TT;
```
## 【模板】可持久化平衡树

#### 题目背景

本题为题目 **普通平衡树** 的可持久化加强版。

#### 题目描述

您需要写一种数据结构（可参考题目标题），来维护一个可重整数集合，其中需要提供以下操作（ **对于各个以往的历史版本** ）：


1、 插入 $x$

2、 删除 $x$（若有多个相同的数，应只删除一个，**如果没有请忽略该操作**）


3、 查询 $x$ 的排名（排名定义为比当前数小的数的个数 $+1$）


4、查询排名为 $x$ 的数


5、 求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数，**如不存在输出** $-2^{31}+1$ ）


6、求 $x$ 的后继（后继定义为大于 $x$，且最小的数，**如不存在输出** $2^{31}-1$ ）


**和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本。（操作3, 4, 5, 6即保持原版本无变化）**

每个版本的编号即为操作的序号（版本0即为初始状态，空树）

#### 输入格式

第一行包含一个正整数 $n$ ，表示操作的总数。

接下来 $n$ 行，每行包含三个整数，第 $i$ 行记为 $v_i, \text{opt}_i, x_i$。

$v_i$ 表示基于的过去版本号，$\text{opt}_i$ 表示操作的序号， $x_i$ 表示参与操作的数值

#### 输出格式

每行包含一个整数，依次为各个 $3,4,5,6$ 操作所对应的答案

对于 $100\%$ 的数据， $ 1 \leq n \leq 5 \times  10^5 $ , $|x_i| \leq {10}^9$，$0 \le v_i < i$，$1\le \text{opt} \le 6$。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define INF 2147483647
const int MaxN=5e5+100;
const int MaxM=5e7+100;
int N,M;
int a[MaxN],rt[MaxN],tot,t1,t2,t3;
struct point
{
    int x,l,r,v,p,s;
}tree[MaxM];
template<class T>
inline void qread(T &sum)
{
    sum=0;int boo=1;
    char x=getchar();
    while(x<'0'||x>'9'){if(x=='-')boo=-1;x=getchar();}
    while(x>='0'&&x<='9'){sum=(sum<<1)+(sum<<3)+x-'0';x=getchar();}
    sum*=boo;
}
template<class T>
void qput(T x)
{
    if(x<0) {x=-x;putchar('-');}
    if(x>9){qput(x/10);}
    putchar(x%10+48);
}
inline int newnode(int v)
{
    int x=++tot;
    tree[x].l=tree[x].r=0;
    tree[x].p=rand();
    tree[x].v=v;
    tree[x].s=1;
    return x;
}
inline void updata(int x)
{
    tree[x].s=tree[tree[x].l].s+tree[tree[x].r].s+1;
}
inline int hebin(int x,int y)
{
    if(!x||!y) return x+y;
    if(tree[x].p<tree[y].p)
    {
        int p=newnode(0);
        tree[p]=tree[x];
        tree[p].r=hebin(tree[p].r,y);
        updata(p);
        return p;
    }
    else
    {
        int p=newnode(0);
        tree[p]=tree[y];
        tree[p].l=hebin(x,tree[p].l);
        updata(p);
        return p;
    }
}
void split(int x,int k,int &l,int &r)
{
    if(!x)
    {
        l=r=0;
        return;
    }
    int p=newnode(0);
    tree[p]=tree[x];
    if(tree[p].v<=k)
    {
        l=p;
        split(tree[p].r,k,tree[p].r,r);
    }
    else
    {
        r=p;
        split(tree[p].l,k,l,tree[p].l);
    }
    updata(p);
}
int ith(int x,int k)
{
    while(x)
    {
        if(k<=tree[tree[x].l].s)
        {
            x=tree[x].l;
        }
        else if(k==tree[tree[x].l].s+1)
        {
            return tree[x].v;
        }
        else
        {
            k-=(tree[tree[x].l].s+1);
            x=tree[x].r;
        }
    }
    return 0;
}
inline int query1(int x)
{
    int ans=-INF;
    while(x)
    {
        ans=max(ans,tree[x].v);
        x=tree[x].r;
    }
    return ans;
}
inline int query2(int x)
{
    int ans=INF;
    while(x)
    {
        ans=min(ans,tree[x].v);
        x=tree[x].l;
    }
    return ans;
}
signed main()
{
    qread(N);
    for(int i=1;i<=N;i++)
    {
        int v,opt,x;
        qread(v);qread(opt);qread(x);
        if(opt==1)
        {
            split(rt[v],x-1,t1,t2);
            int p=newnode(x);
            rt[i]=hebin(hebin(t1,p),t2);
        }
        if(opt==2)
        {
            split(rt[v],x,t1,t3);
            split(t1,x-1,t1,t2);
            t2=hebin(tree[t2].l,tree[t2].r);
            rt[i]=hebin(hebin(t1,t2),t3);
        }
        if(opt==3)
        {
            rt[i]=rt[v];
            split(rt[v],x-1,t1,t3);
            int ans=tree[t1].s+1;
            qput(ans);putchar('\n');
        }
        if(opt==4)
        {
            rt[i]=rt[v];
            int ans=ith(rt[i],x);
            qput(ans);putchar('\n');
        }
        if(opt==5)
        {
            rt[i]=rt[v];
            split(rt[i],x-1,t1,t2);
            int ans=query1(t1);
            qput(ans);putchar('\n');
        }
        if(opt==6)
        {
            rt[i]=rt[v];
            split(rt[i],x,t1,t2);
            int ans=query2(t2);
            qput(ans);putchar('\n');
        }
    }
}
```
## 【模板】可持久化文艺平衡树

#### 题目描述

您需要写一种数据结构，来维护一个序列，其中需要提供以下操作（**对于各个以往的历史版本**）：

1. 在第 $p$ 个数后插入数 $x$ 。
2. 删除第 $p$ 个数。
3. 翻转区间 $[l,r]$，例如原序列是 $\{5,4,3,2,1\}$，翻转区间 $[2,4]$ 后，结果是 $\{5,2,3,4,1\}$。
4. 查询区间 $[l,r]$ 中所有数的和。

**和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本（操作 $4$ 即保持原版本无变化），新版本即编号为此次操作的序号。**

**本题强制在线。**

#### 输入格式

第一行包含一个整数 $n$，表示操作的总数。

接下来 $n$ 行，每行前两个整数 $v_i, \mathrm{opt}_i$，$v_i$ 表示基于的过去版本号（$0 \le v_i < i$），$\mathrm{opt}_i$ 表示操作的序号（$1 \le \mathrm{opt}_i \le 4$）。

若 $\mathrm{opt}_i=1$，则接下来两个整数 $p_i, x_i$，表示操作为在第 $p_i$ 个数后插入数 $x$ 。  
若 $\mathrm{opt}_i=2$，则接下来一个整数 $p_i$，表示操作为删除第 $p_i$ 个数。  
若 $\mathrm{opt}_i=3$，则接下来两个整数 $l_i, r_i$，表示操作为翻转区间 $[l_i, r_i]$。  
若 $\mathrm{opt}_i=4$，则接下来两个整数 $l_i, r_i$，表示操作为查询区间 $[l_i, r_i]$ 的和。

**强制在线规则：**  
**令当前操作之前的最后一次 $4$ 操作的答案为 $lastans$（如果之前没有 $4$ 操作，则 $lastans=0$）。**  
**则此次操作的 $p_i,x_i$ 或 $l_i,r_i$ 均按位异或上 $lastans$ 即可得到真实的 $p_i,x_i$ 或 $l_i,r_i$。**

#### 输出格式

对于每个序号为 $4$ 的查询操作，输出一行一个数表示区间的和。

#### 提示

**强制在线：以下针对 $p_i, x_i, l_i, r_i$ 的限制均是按位异或 $lastans$ 后的限制。**

对于 $100\%$ 的数据，$1 \le n \le 2 \times {10}^5$，$|x_i| < {10}^6$。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define int ll
#define ls p<<1
#define rs p<<1|1
#define lowbit(x) ((x)&(-x))
const int MaxN=2e7+100;
const int INF=1e9;
int N,M,T,tot,rt[MaxN],ans,t1,t2,t3;
struct point
{
	int s,l,r,sum,lan,p,v;
}tree[MaxN];
template<class T>
inline int newnode(int v)
{
    int x=++tot;
    tree[x].l=tree[x].r=0;
    tree[x].p=rand();
    tree[x].v=v;
	tree[x].sum=v;
    tree[x].s=1;
    return x;
}
inline void updata(int x)
{
    tree[x].s=tree[tree[x].l].s+tree[tree[x].r].s+1;
	tree[x].sum=tree[tree[x].l].sum+tree[tree[x].r].sum+tree[x].v;
}
inline void overturn(int x)
{
	swap(tree[x].l,tree[x].r);
	tree[x].lan^=1;
}
inline void pushdown(int x)
{
	if(!tree[x].lan) return;
	if(tree[x].l)
	{
		int p=++tot;
		tree[p]=tree[tree[x].l];
		tree[x].l=p;
		overturn(p);
	}
	if(tree[x].r)
	{
		int p=++tot;
		tree[p]=tree[tree[x].r];
		tree[x].r=p;
		overturn(p);
	}
	tree[x].lan=0;
}
inline int hebin(int x,int y)
{
    if(!x||!y) return x+y;
    if(tree[x].p<tree[y].p)
    {
        int p=newnode(0);
        tree[p]=tree[x];
		pushdown(p);
        tree[p].r=hebin(tree[p].r,y);
        updata(p);
        return p;
    }
    else
    {
        int p=newnode(0);
        tree[p]=tree[y];
		pushdown(p);
        tree[p].l=hebin(x,tree[p].l);
        updata(p);
        return p;
    }
}
void split(int x,int k,int &l,int &r)
{
    if(!x)
    {
        l=r=0;
        return;
    }
    int p=newnode(0);
    tree[p]=tree[x];
	pushdown(p);
    if(tree[tree[p].l].s+1<=k)
    {
        l=p;
        split(tree[p].r,k-(tree[tree[p].l].s+1),tree[p].r,r);
    }
    else
    {
        r=p;
        split(tree[p].l,k,l,tree[p].l);
    }
    updata(p);
}
void print(int x)
{
	pushdown(x);
	if(tree[x].l) print(tree[x].l);
	qput(tree[x].v);putchar(' ');
	if(tree[x].r) print(tree[x].r);
}
inline void Solve()
{
	qread(N);
	for(int i=1;i<=N;i++)
	{
		int v,opt;qread(v);qread(opt);
		int x,y;
		if(opt==1)
		{
			qread(x);qread(y);
			x^=ans;y^=ans;
			split(rt[v],x,t1,t3);
			t2=newnode(y);
			rt[i]=hebin(hebin(t1,t2),t3);
		}
		if(opt==2)
		{
			qread(x);
			x^=ans;
			split(rt[v],x,t1,t3);
			split(t1,x-1,t1,t2);
			rt[i]=hebin(t1,t3);
		}
		if(opt==3)
		{
			qread(x);qread(y);
			x^=ans;y^=ans;
			split(rt[v],y,t1,t3);
			split(t1,x-1,t1,t2);
			overturn(t2);
			rt[i]=hebin(hebin(t1,t2),t3);
		}
		if(opt==4)
		{
			rt[i]=rt[v];
			qread(x);qread(y);
			x^=ans;y^=ans;
			split(rt[i],y,t1,t3);
			split(t1,x-1,t1,t2);
			ans=tree[t2].sum;
			qput(ans);putchar('\n');
		}
//		print(rt[i]);putchar('\n');
	}
}
signed main()
{
	T=1;
	while(T--) Solve();
}
```
## LCA
```cpp
struct LCA {
    int dep[MaxN], fa[MaxN][21];
    inline void dfs1(int x, int f) {
        fa[x][0] = f;
        dep[x] = dep[f] + 1;
        for (int j = 1; j <= 20; j++) {
            fa[x][j] = fa[fa[x][j - 1]][j - 1];
        }
        for (int i = 0; i < (int)G1[x].size(); i++) {
            int y = G1[x][i];
            if (y == f) continue;
            dfs1(y, x);
        }
    }
    int lca(int x, int y) {
        if (dep[x] < dep[y]) swap(x, y);
        for (int i = 20; i >= 0; i--) {
            if (dep[fa[x][i]] >= dep[y]) x = fa[x][i];
            if (x == y) return x;
        }
        for (int i = 20; i >= 0; i--) {
            if (fa[x][i] != fa[y][i]) {
                x = fa[x][i];
                y = fa[y][i];
            }
        }
        return fa[x][0];
    }
} LCA;
```
```cpp
struct LCA {
	vector<int> dep, re, st, logn;
	vector<vector<int>> F;
	static const int LogN = 21;
	int top;
	void dfs1(int x, int f) {
		dep[x] = dep[f] + 1;
		st[++top] = x;
		re[x] = top;
		for (int i = 0; i < (int)G1[x].size(); i++) {
			int y = G1[x][i];
			if (y == f) continue;
			dfs1(y, x);
			st[++top] = x;
		}
	}
	int lca(int x, int y) {
		int l = re[x];
		int r = re[y];
		if (l > r) swap(l, r);
		int k = logn[r - l + 1];
		return dep[F[l][k]] < dep[F[r - (1 << k) + 1][k]]
				? F[l][k]
				: F[r - (1 << k) + 1][k];
	}
	inline void clear(int N) {
		dep.assign(N, 0);
		re.assign(N, 0);
		st.assign(N, 0);
		logn.assign(N, 0);
		top = 0;
		F.assign(N, vector<int>(LogN, 0));
	}
	inline void solve(int rt, int N) {
		clear(2 * N + 1);
		dfs1(rt, 0);
        for (int i = 1; i <= 2 * N; i++) {
            F[i][0] = st[i];
        }
		for (int j = 1; j < LogN; j++) {
			for (int i = 1; i + (1 << j) - 1 <= 2 * N; i++) {
				F[i][j] = dep[F[i][j - 1]] < dep[F[i + (1 << (j - 1))][j - 1]]
							? F[i][j - 1]
							: F[i + (1 << (j - 1))][j - 1];
			}
		}

		logn[0] = -1;
		for (int i = 1; i <= 2 * N; i++) {
			logn[i] = logn[i / 2] + 1;
		}
	}
} Lca;
```
## [Vani有约会]雨天的尾巴 /【模板】线段树合并

### 题目描述

首先村落里的一共有 $n$ 座房屋，并形成一个树状结构。然后救济粮分 $m$ 次发放，每次选择两个房屋 $(x,~y)$，然后对于 $x$ 到 $y$ 的路径上(含 $x$ 和 $y$)每座房子里发放一袋 $z$ 类型的救济粮。

然后深绘里想知道，当所有的救济粮发放完毕后，每座房子里存放的最多的是哪种救济粮。

#### 输入格式

输入的第一行是两个用空格隔开的正整数，分别代表房屋的个数 $n$ 和救济粮发放的次数 $m$。

第 $2$ 到 第 $n$ 行，每行有两个用空格隔开的整数 $a,~b$，代表存在一条连接房屋 $a$ 和 $b$ 的边。

第 $(n + 1)$ 到第 $(n + m)$ 行，每行有三个用空格隔开的整数 $x,~y,~z$，代表一次救济粮的发放是从 $x$ 到 $y$ 路径上的每栋房子发放了一袋 $z$ 类型的救济粮。

#### 输出格式

输出 $n$ 行，每行一个整数，第 $i$ 行的整数代表 $i$ 号房屋存放最多的救济粮的种类，如果有多种救济粮都是存放最多的，输出种类编号最小的一种。

如果某座房屋没有救济粮，则输出 $0$。

#### 样例 #1

##### 样例输入 #1

```
5 3
1 2
3 1
3 4
5 3
2 3 3
1 5 2
3 3 3
```

##### 样例输出 #1

```
2
3
3
0
2
```

#### 提示

- 对于 $20\%$ 的数据，保证 $n, m \leq 100$。
- 对于 $50\%$ 的数据，保证 $n, m \leq 2 \times 10^3$。
- 对于 $100\%$ 测试数据，保证 $1 \leq n, m \leq 10^5$，$1 \leq a,b,x,y \leq n$，$1 \leq z \leq 10^5$。  
##### 思路  
利用树上差分:  
想要再$(x,y)$区间内加v；  
则$d[x]+=v;d[y]+=y;d[lca(x,y)]-=v;d[fa[lca(x,y)]]-=v;$
然后最后把数据递增到$root$上   
```cpp
struct TT {
    struct Point {
        int l, r, v;
    } tree[MaxN * 40];
    int tot = 0;
    int change1(int p, int l, int r, int k, int v) {
        int now = ++tot;
        int mid = (l + r) >> 1;
        tree[now] = tree[p];
        if (l == r) {
            tree[now].v += v;
            return now;
        }
        if (k <= mid)
            tree[now].l = change1(tree[now].l, l, mid, k, v);
        else
            tree[now].r = change1(tree[now].r, mid + 1, r, k, v);
        tree[now].v = max(tree[tree[now].l].v, tree[tree[now].r].v);
        return now;
    }
    int hebin(int x, int y) {
        if (!x || !y) return x + y;
        tree[x].l = hebin(tree[x].l, tree[y].l);
        tree[x].r = hebin(tree[x].r, tree[y].r);
        if (!tree[x].l && !tree[x].r) {
            tree[x].v += tree[y].v;
            return x;
        }
        tree[x].v = max(tree[tree[x].l].v, tree[tree[x].r].v);
        return x;
    }
    int hebin(int x, int y) {
        if (!x || !y) return x + y;
		int p = ++tot;
        tree[p].l = hebin(tree[x].l, tree[y].l);
        tree[p].r = hebin(tree[x].r, tree[y].r);
        if (!tree[p].l && !tree[p].r) {
			tree[p].sum = tree[x].sum + tree[y].sum;
			tree[p].id = tree[x].id;
            return p;
        }
        tree[p] = pushup(tree[tree[p].l], tree[tree[p].r], tree[p].l, tree[p].r);
        return p;
    }
    int bina(int x, int l, int r) {
        if (l == r) return l;
        int mid = (l + r) >> 1;
        if (tree[tree[x].l].v >= tree[tree[x].r].v) return bina(tree[x].l, l, mid);
        else return bina(tree[x].r, mid + 1, r);
    }
    void solve(int x, int f) {
        for (auto y : G1[x]) {
            if (y == f) continue;
            solve(y, x);
            rt[x] = hebin(rt[x], rt[y]);
        }
        if (!tree[rt[x]].v) ans[x] = 0;
        else ans[x] = bina(rt[x], 1, INF);
    }
} TT;
```
## 【模板】线段树分裂

### 题目描述

给出一个可重集 $a$（编号为 $1$），它支持以下操作：

`0 p x y`：将可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值移动到一个新的可重集中（新可重集编号为从 $2$ 开始的正整数，是上一次产生的新可重集的编号+1）。

`1 p t`：将可重集 $t$ 中的数放入可重集 $p$，且清空可重集 $t$（数据保证在此后的操作中不会出现可重集 $t$）。

`2 p x q`：在 $p$ 这个可重集中加入 $x$ 个数字 $q$。

`3 p x y`：查询可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值的个数。

`4 p k`：查询在 $p$ 这个可重集中第 $k$ 小的数，不存在时输出 `-1`。

#### 输入格式

第一行两个整数 $n,m$，表示可重集中的数在 $1\sim n$ 的范围内，有 $m$ 个操作。

接下来一行 $n$ 个整数，表示 $1 \sim n$ 这些数在 $a$ 中出现的次数 $(a_{i} \leq m)$。

接下来的 $m$ 行每行若干个整数，第一个数为操作的编号 $opt$（$0 \leq opt \leq 4$），以**题目描述**为准。

#### 输出格式

依次输出每个查询操作的答案。

#### 样例 #1

##### 样例输入 #1

```
5 12
0 0 0 0 0
2 1 1 1
2 1 1 2
2 1 1 3
3 1 1 3
4 1 2
2 1 1 4
2 1 1 5
0 1 2 4
2 2 1 4
3 2 2 4
1 1 2
4 1 3
```

##### 样例输出 #1

```
3
2
4
3
```
```cpp
struct TT {
	struct Point {
		int sum, l, r;
	} tree[MaxM];
	int tot = 0;
	void del(int x) {
		tree[x].sum = 0;
		tree[x].l = tree[x].r = 0;
	}
	int newnode() {
		int x = ++tot;
		tree[x].sum = 0;
		tree[x].l = tree[x].r = 0;
		return x;
	}
	void pushup(int x) {
		tree[x].sum = tree[tree[x].l].sum + tree[tree[x].r].sum;
	}
	void split(int x, int &y, int k) {
		if (!x) return;
		y = newnode();
		int v = tree[tree[x].l].sum;
		if (k > v) {
			split(tree[x].r, tree[y].r, k - v);
		} else {
			swap(tree[x].r, tree[y].r);
		}
		if (k < v) {
			split(tree[x].l, tree[y].l, k);
		}
		tree[y].sum = tree[x].sum - k;
		tree[x].sum = k;
	}
	int hebin(int x, int y) {
		if (!x || !y) return x + y;
		tree[x].l = hebin(tree[x].l, tree[y].l);
		tree[x].r = hebin(tree[x].r, tree[y].r);
		if (!tree[x].l && !tree[x].r) {
			tree[x].sum += tree[y].sum;
			return x;
		}
		tree[x].sum = tree[tree[x].l].sum + tree[tree[x].r].sum;
        del(y);
		return x;
	}
	int query(int p, int l, int r, int k) { //左留k个
		if (l == r) {
			return l;
		}
		int mid = (l + r) >> 1;
		if (tree[tree[p].l].sum >= k)
			return query(tree[p].l, l, mid, k);
		else
			return query(tree[p].r, mid + 1, r, k - tree[tree[p].l].sum);
	}
	int query1(int p, int l, int r, int x, int y) {
		if (l >= x && r <= y) {
			return tree[p].sum;
		}
		int mid = (l + r) >> 1;
		int ans = 0;
		if (mid >= x) ans += query1(tree[p].l, l, mid, x, y);
		if (mid < y) ans += query1(tree[p].r, mid + 1, r, x, y);
		return ans;
	}
	int change(int p, int l, int r, int k, int v) {
		if (!p) p = newnode();
		if (l == r) {
			tree[p].sum += v;
			return p;
		}
		int mid = (l + r) >> 1;
		if (mid >= k)
			tree[p].l = change(tree[p].l, l, mid, k, v);
		else
			tree[p].r = change(tree[p].r, mid + 1, r, k, v);
		pushup(p);
		return p;
	}
} TT;
inline void Solve() {
	cin >> N >> M;
	int num = 1;
	for (int i = 1; i <= N; i++) {
		cin >> a[i];
		rt[1] = TT.change(rt[1], 1, N, i, a[i]);
	}
	for (int i = 1; i <= M; i++) {
		int opt, x, y, p;
		cin >> opt;
		if (opt == 0) {
			cin >> p >> x >> y;
			int k1 = TT.query1(rt[p], 1, N, 1, y);
			int k2 = TT.query1(rt[p], 1, N, x, y);
			int tt = 0;
			TT.split(rt[p], rt[++num], k1 - k2);
			TT.split(rt[num], tt, k2);
			rt[p] = TT.hebin(rt[p], tt);
		} else if (opt == 1) {
			cin >> p >> x;
			rt[p] = TT.hebin(rt[p], rt[x]);

		} else if (opt == 2) {
			cin >> p >> x >> y;
			rt[p] = TT.change(rt[p], 1, N, y, x);
		} else if (opt == 3) {
			cin >> p >> x >> y;
			int ans = TT.query1(rt[p], 1, N, x, y);
			cout << ans << endl;
		} else if (opt == 4) {
			cin >> p >> x;
			int ans = -1;
			if (TT.tree[rt[p]].sum >= x) ans = TT.query(rt[p], 1, N, x);
			cout << ans << endl;
		}
	}
}
```
## 树套树
### 1.线段树套FHQ-treap  
每个线段树维护一个对应区间的平衡树 

------------

#### 【模板】二逼平衡树（树套树）

#### 题目描述

您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：

1. 查询 $k$ 在区间内的排名

2. 查询区间内排名为 $k$ 的值

3. 修改某一位值上的数值

4. 查询 $k$ 在区间内的前驱（前驱定义为严格小于 $x$，且最大的数，**若不存在输出 `-2147483647`**）

5. 查询 $k$ 在区间内的后继（后继定义为严格大于 $x$，且最小的数，**若不存在输出 `2147483647`**）

#### 输入格式

第一行两个数 $n,m$，表示长度为 $n$ 的有序序列和 $m$ 个操作。

第二行有 $n$ 个数，表示有序序列。

下面有 $m$ 行，$opt$ 表示操作标号。

若 $opt=1$，则为操作 $1$，之后有三个数 $l~r~k$，表示查询 $k$ 在区间 $[l,r]$ 的排名。

若 $opt=2$，则为操作 $2$，之后有三个数 $l~r~k$，表示查询区间 $[l,r]$ 内排名为    $k$ 的数。

若 $opt=3$，则为操作 $3$，之后有两个数 $pos~k$，表示将 $pos$ 位置的数修改为 $k$。

若 $opt=4$，则为操作 $4$，之后有三个数 $l~r~k$，表示查询区间 $[l,r]$ 内 $k$ 的前驱。

若 $opt=5$，则为操作 $5$，之后有三个数 $l~r~k$，表示查询区间 $[l,r]$ 内 $k$ 的后继。

#### 输出格式

对于操作 $1,2,4,5$，各输出一行，表示查询结果。

此数据为洛谷原创。**（特别提醒：此数据不保证操作 4、5 一定存在，故请务必考虑不存在的情况。）**  
1. 在对应线段树的范围内找有多少个小于k的数

2. 在区间内二分查找，对结果1进行查找

3. 把线段树对应的平衡树，删除一个数，增加一个数

4. 对于所有比k小的数取max

5. 对于所有比k大的数取min  
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define int ll
#define zuo p<<1
#define you p<<1|1
#define INF 2147483647
const int MaxN=2e6+100;
int N,M,tot,t1,t2,t3;
int a[MaxN];
struct point
{
    int v;
}xds[MaxN];
struct node
{
    int l,r,p,s,v,c;
}tree[MaxN];
inline int newnode(int v)
{
    int x=++tot;
    tree[x].l=tree[x].r=0;
    tree[x].v=v;
    tree[x].s=tree[x].c=1;
    tree[x].p=rand();
    return x;
}
inline void updata(int x)
{
    tree[x].s=tree[tree[x].l].s+tree[tree[x].r].s+tree[x].c;
}
void split(int x,int k,int &l,int &r)
{
    if(!x)
    {
        l=r=0;
        return;
    }
    if(tree[x].v<=k)
    {
        l=x;
        split(tree[x].r,k,tree[x].r,r);
    }
    else
    {
        r=x;
        split(tree[x].l,k,l,tree[x].l);
    }
    updata(x);
}
int hebin(int x,int y)
{
    if(!x||!y) return x+y;
    if(tree[x].p<tree[y].p)
    {
        tree[x].r=hebin(tree[x].r,y);
        updata(x);
        return x;
    }
    else
    {
        tree[y].l=hebin(x,tree[y].l);
        updata(y);
        return y;
    }
}
int rebuild(int l,int r)
{
    int rt=0;
    for(int i=l;i<=r;i++)
    {
        split(rt,a[i],t1,t3);
        split(t1,a[i]-1,t1,t2);
        if(t2)
        {
            tree[t2].c++;tree[t2].s++;
            rt=hebin(hebin(t1,t2),t3);
        }
        else
        rt=hebin(hebin(t1,newnode(a[i])),t3);
    }
    return rt;
}
void build(int p,int l,int r)
{
    xds[p].v=rebuild(l,r);
    if(l==r)
    {
        return;
    }
    int mid=(l+r)>>1;
    build(zuo,l,mid);
    build(you,mid+1,r);
}
int ith(int x,int v)
{
    int ans=0;
    while(x)
    {
        if(tree[x].v==v)
        {
            ans+=tree[tree[x].l].s;
//			qput(ans);putchar('\n');
            return ans;
        }
        if(tree[x].v<v)
        {
            ans+=tree[tree[x].l].s+tree[x].c;
            x=tree[x].r;
        }
        else if(tree[x].v>v)
        {
            x=tree[x].l;
        }
    }
//	qput(ans);putchar('\n');
    return ans;
}
int query(int p,int l,int r,int x,int y,int k)
{
    if(r<=y&&l>=x)
    {
        return ith(xds[p].v,k);
    }
    int mid=(l+r)>>1;
    int ans=0;
    if(mid>=x) ans+=query(zuo,l,mid,x,y,k);
    if(mid<y) ans+=query(you,mid+1,r,x,y,k);
    return ans;
}
int pre(int x,int v)
{
    int ans=-INF;
    while(x)
    {
        if(tree[x].v<v)
        {
            ans=max(ans,tree[x].v);
            x=tree[x].r;
        }
        if(tree[x].v>=v)
        {
            x=tree[x].l;
        }
    }
    return ans;
}
int query1(int p,int l,int r,int x,int y,int k)
{
    if(r<=y&&l>=x)
    {
        return pre(xds[p].v,k);
    }
    int mid=(l+r)>>1;
    int ans=-INF;
    if(mid>=x) ans=max(ans,query1(zuo,l,mid,x,y,k));
    if(mid<y) ans=max(ans,query1(you,mid+1,r,x,y,k));
    return ans;
}
int ne(int x,int v)
{
    int ans=INF;
    while(x)
    {
        if(tree[x].v>v)
        {
            ans=min(ans,tree[x].v);
            x=tree[x].l;
        }
        if(tree[x].v<=v)
        {
            x=tree[x].r;
        }
    }
    return ans;
}
int query2(int p,int l,int r,int x,int y,int k)
{
    if(r<=y&&l>=x)
    {
        return ne(xds[p].v,k);
    }
    int mid=(l+r)>>1;
    int ans=INF;
    if(mid>=x) ans=min(ans,query2(zuo,l,mid,x,y,k));
    if(mid<y) ans=min(ans,query2(you,mid+1,r,x,y,k));
    return ans;
}
void delet(int &x,int k)
{
    split(x,k,t1,t3);
    split(t1,k-1,t1,t2);
    if(tree[t2].s>1)
    {
        tree[t2].s--;tree[t2].c--;
        x=hebin(hebin(t1,t2),t3);
    }
    else
    {
        x=hebin(t1,t3);
    }
}
void add1(int &x,int k)
{
    split(x,k,t1,t3);
    split(t1,k-1,t1,t2);
    if(t2)
    {
        tree[t2].s++;tree[t2].c++;
        x=hebin(hebin(t1,t2),t3);
    }
    else
    {
        x=hebin(hebin(t1,newnode(k)),t3);
    }
}
void change(int p,int l,int r,int pos,int k)
{
    if(r>=pos&&l<=pos)
    {
//		xds[p].v=rebuild(l,r);
        delet(xds[p].v,a[pos]);
        add1(xds[p].v,k);
    }
    if(l==r) return;
    int mid=(l+r)>>1;
    if(mid>=pos) change(zuo,l,mid,pos,k);
    if(mid<pos) change(you,mid+1,r,pos,k);
}
inline int js(int x,int y,int k)
{
    int l=0,r=1e8;
    while(l<=r)
    {
        int mid=(l+r)>>1;
        if(query(1,1,N,x,y,mid)+1>k) r=mid-1;
        else l=mid+1;
    }
    return r;
}
signed main()
{
    qread(N);qread(M);
    for(int i=1;i<=N;i++) qread(a[i]);
    build(1,1,N);
    for(int i=1;i<=M;i++)
    {
        int opt;qread(opt);
        int l,r,k,pos;
        if(opt==1)
        {
            qread(l);qread(r);qread(k);
            int ans=query(1,1,N,l,r,k);
            qput(ans+1);putchar('\n');
        }
        if(opt==2)
        {
            qread(l);qread(r);qread(k);
            int ans=js(l,r,k);
            qput(ans);putchar('\n');
        }
        if(opt==3)
        {
            qread(pos);qread(k);
//			a[pos]=k;
            change(1,1,N,pos,k);
            a[pos]=k;
        }
        if(opt==4)
        {
            qread(l);qread(r);qread(k);
            int ans=query1(1,1,N,l,r,k);
            qput(ans);putchar('\n');
        }
        if(opt==5)
        {
            qread(l);qread(r);qread(k);
            int ans=query2(1,1,N,l,r,k);
            qput(ans);putchar('\n');
        }
        // for(int i=1;i<=N;i++)
        // qput(a[i]),putchar(' ');putchar('\n');
    }
}
```
### 2.树状数组套主席树
#### 题目描述  
- `Q l r k` 表示查询下标在区间 $[l,r]$ 中的第 $k$ 小的数  
- `C x y` 表示将 $a_x$ 改为 $y$
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define ls p << 1
#define rs p << 1 | 1
#define lowbit(x) ((x) & (-x))
const int MaxN = 1e5 + 100;
const int MAXN = 1e5 + 100;
const int MaxM = 3e7 + 3e6;
const int INF = 1e9;
int T, N, M, K, tot, n;
int a[MaxN], b[MaxN << 1], top;
int tree1[MaxN], rt[MaxN];
int temp1[MaxN], temp2[MaxN];
int t1[MaxN], t2[MaxN], t3[MaxN];
char pd[MaxN];
int cnt1, cnt2;
struct point
{
	int l, r, sum;
}tree[MaxM];
int ef(int x)
{
	int l = 1, r = n;
	while(l <= r)
	{
		int mid = (l + r) >> 1;
		if (b[mid] >= x) r = mid - 1;
		else l = mid + 1;
	}
	return l;
}
int add1(int p, int l, int r, int v, int k)
{
	int x = ++tot;
	tree[x] = tree[p];
	tree[x].sum += v;
	if (l == r)
	{
		return x;
	}
	int mid = (l + r)>>1;
	if (mid >= k) tree[x].l = add1(tree[x].l, l, mid, v, k);
	else tree[x].r = add1(tree[x].r, mid + 1, r, v, k);
	return x;
}
inline void add(int x, int v)
{
	int t = ef(a[x]);
	for (; x <= N; x += lowbit(x))
	{
		rt[x] = add1(rt[x], 1, n, v, t);
	}
}
int query1(int l, int r, int k)
{
	if (l == r) return l;
	int sum = 0;
	int mid = (l + r) >> 1;
	for (int i = 1; i <= cnt1; i++)
	{
		sum -= tree[tree[temp1[i]].l].sum;
	}
	for (int i = 1; i <= cnt2; i++)
	{
		sum += tree[tree[temp2[i]].l].sum;
	}
	if (sum >= k)
	{
		for (int i = 1; i <= cnt1; i++)
		{
			temp1[i] = tree[temp1[i]].l;
		}
		for (int i = 1; i <= cnt2; i++)
		{
			temp2[i] = tree[temp2[i]].l;
		}
		return query1(l, mid, k);
	}
	else
	{
		for (int i = 1; i <= cnt1; i++)
		{
			temp1[i] = tree[temp1[i]].r;
		}
		for (int i = 1; i <= cnt2; i++)
		{
			temp2[i] = tree[temp2[i]].r;
		}
		return query1(mid + 1, r, k - sum);
	}
}
inline int query(int l, int r, int k)
{
	cnt1 = 0;
	cnt2 = 0;
	for (int i = l - 1; i; i -= lowbit(i))
	{
		temp1[++cnt1] = rt[i];
	}
	for (int i = r; i; i -= lowbit(i))
	{
		temp2[++cnt2] = rt[i];
	}
	return query1(1, n, k);
}
inline void Solve()
{
	cin >> N >> M;
	for (int i = 1; i <= N; i++)
	{
		cin >> a[i];
		b[++top] = a[i];
	}
	for (int i = 1; i <= M; i++)
	{
		char opt;
		int x, y, z;
		cin >> opt;
		pd[i] = opt;
		if (opt == 'C')
		{
			cin >> x >> y;
			t1[i] = x;
			t2[i] = y;
			b[++top] = y;
		}
		else
		{
			cin >> x >> y >> z;
			t1[i] = x;
			t2[i] = y;
			t3[i] = z;
		}
	}
	sort(b + 1, b + 1 + top);
	n = unique(b + 1, b + 1 + top) - (b + 1);
	for (int i = 1; i <= N; i++)
	{
		add(i, 1);
	}
	for (int i = 1; i <= M; i++)
	{
		char opt;
		int x, y, z;
		opt = pd[i];
		if (opt == 'C')
		{
			x = t1[i];
			y = t2[i];
			add(x, -1);
			a[x] = y;
			add(x, 1);
		}
		else
		{
			x = t1[i];
			y = t2[i];
			z = t3[i];
			int ans = query(x, y, z);
			cout << b[ans] << endl;
		}
	}
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	Solve();
}
```
### 权值线段树套权值线段树(二维单点修改，矩形查询)
```cpp
int n1, n2;
struct Segment {
	struct Point {
		int l, r;
        ll sum;
	} tree[MaxM];
	int tot;
	Segment() {
		init();
	}
	Segment(int _n) {
		init(_n);
	}
	void init() {
		// tree.clear();
        // tree.push_back({});
		tot = 0;
	}
	void init(int _n) {
		// tree.clear();
		tot = 0;
		// tree.assign(_n, {});
	}

	inline Point pushup(Point L, Point R) {
		Point now = Point();
		now.sum = L.sum + R.sum;
		return now;
	}

	inline void pushup(int p) {
		tree[p].sum = tree[tree[p].l].sum + tree[tree[p].r].sum;
	}

	int change(int p, int l, ll r, int k, int v) {
		// while (tree.size() <= tot + 1) tree.push_back({});
		if (!p) {
			p = ++tot;
		}
		if (l == r) {
			tree[p].sum += v;
			return p;
		}
		int mid = (l + r) >> 1;
		if (mid >= k) tree[p].l = change(tree[p].l, l, mid, k, v);
		else tree[p].r = change(tree[p].r, mid + 1, r, k, v);
		pushup(p);
		return p;
	}

	ll query(int p, int l, ll r, int x, int y) {
        if (p > tot) return 0;
		if (l >= x && r <= y) {
            return tree[p].sum;
        }
		int mid = (l + r) >> 1;
        ll ans = 0;
		if (mid >= x) ans += query(tree[p].l, l, mid, x, y);
		if (mid < y) ans += query(tree[p].r, mid + 1, r, x, y);
        return ans;
	}
};
struct Segment2 {
    Segment segment;
	struct Point {
		int l, r, rt;
	} tree[MaxN * 10];
	int tot;
	Segment2() {
		init();
	}
	Segment2(int _n) {
		init(_n);
	}
	void init() {
		// tree.clear();
        // tree.push_back({});
		tot = 0;
        segment.init(MaxN * 400);
	}
	void init(int _n) {
		// tree.clear();
		tot = 0;
		// tree.assign(_n, {});
	}


	int change(int p, int l, ll r, int k, int k2, int v) {
		// while (tree.size() <= tot + 10) tree.push_back({});
		if (!p) {
			p = ++tot;
		}
        tree[p].rt = segment.change(tree[p].rt, 1, n2, k2, v);
		if (l == r) {
			return p;
		}
		int mid = (l + r) >> 1;
		if (mid >= k) tree[p].l = change(tree[p].l, l, mid, k, k2, v);
		else tree[p].r = change(tree[p].r, mid + 1, r, k, k2, v);
		return p;
	}

	ll query(int p, int l, ll r, int x, int y, int x2, int y2) {
        if (p > tot) return 0;
		if (l >= x && r <= y) {
            return segment.query(tree[p].rt, 1, n2, x2, y2);
        }
		int mid = (l + r) >> 1;
        ll ans = 0;
		if (mid >= x) ans += query(tree[p].l, l, mid, x, y, x2, y2);
		if (mid < y) ans += query(tree[p].r, mid + 1, r, x, y, x2, y2);
        return ans;
	}
};
```
## 【模板】动态树（Link Cut Tree）

### 题目描述

给定 $n$ 个点以及每个点的权值，要你处理接下来的 $m$ 个操作。  
操作有四种，操作从 $0$ 到 $3$ 编号。点从 $1$ 到 $n$ 编号。


- `0 x y` 代表询问从 $x$ 到 $y$ 的路径上的点的权值的 $\text{xor}$ 和。保证 $x$ 到 $y$ 是联通的。
- `1 x y` 代表连接 $x$ 到 $y$，若 $x$ 到 $y$ 已经联通则无需连接。
- `2 x y` 代表删除边 $(x,y)$，不保证边 $(x,y)$ 存在。
- `3 x y` 代表将点 $x$ 上的权值变成 $y$。

### 输入格式

第一行两个整数，分别为 $n$ 和 $m$，代表点数和操作数。

接下来 $n$ 行，每行一个整数，第 $(i + 1)$ 行的整数 $a_i$ 表示节点 $i$ 的权值。

接下来 $m$ 行，每行三个整数，分别代表操作类型和操作所需的量。

### 输出格式

对于每一个 $0$ 号操作，你须输出一行一个整数，表示 $x$ 到 $y$ 的路径上点权的 $\text{xor}$ 和。

### 样例 #1

#### 样例输入 #1

```
3 3 
1
2
3
1 1 2
0 1 2 
0 1 1
```

#### 样例输出 #1

```
3
1
```

### 样例 #2

#### 样例输入 #2

```
5 14
114
514
19
19
810
1 1 2
0 1 2
2 1 2
1 1 2
1 2 3
2 1 3
1 1 3
1 4 5
1 2 5
0 3 5
0 3 4
3 5 233333
0 1 5
0 2 5
```

#### 样例输出 #2

```
624
315
296
232709
232823
```
动态树lct模板  
```cpp 
struct LCT {
	struct Point {
		int s, fa, ch[2], v, lan, sum;
	} tree[MaxN];
	inline void pushup(int x) {
		tree[x].s = tree[tree[x].ch[0]].s + tree[tree[x].ch[1]].s + 1;
		tree[x].sum = tree[tree[x].ch[0]].sum ^ tree[tree[x].ch[1]].sum ^ tree[x].v;
	}
	inline bool isroot(int x) {
		return tree[tree[x].fa].ch[0] != x && tree[tree[x].fa].ch[1] != x;
	}
	inline void overturn(int x) {
		swap(tree[x].ch[0], tree[x].ch[1]);
		tree[x].lan ^= 1;
	}
	inline void pushdown(int x) {
		if (tree[x].lan) {
			overturn(tree[x].ch[0]);
			overturn(tree[x].ch[1]);
			tree[x].lan = 0;
		}
	}
	inline void updata(int x) {
		if (!isroot(x)) updata(tree[x].fa);
		pushdown(x);
	}
	inline bool get(int x) {
		return x == tree[tree[x].fa].ch[1];
	}
	inline void rotate(int x) {
		int y = tree[x].fa, z = tree[y].fa, k = get(x);
		if (!isroot(y)) tree[z].ch[tree[z].ch[1] == y] = x;
		tree[y].ch[k] = tree[x].ch[k ^ 1];
		tree[tree[x].ch[k ^ 1]].fa = y;
		tree[x].ch[k ^ 1] = y;
		tree[y].fa = x;
		tree[x].fa = z;
		pushup(y); pushup(x);
	}
	inline void splay(int x) {
		updata(x);
		for (int f; f = tree[x].fa, !isroot(x); rotate(x)) {
			if (!isroot(f)) rotate(get(f) == get(x)? f : x);
		}
	}
	inline int access(int x) {
		int p;
		for (p = 0; x; p = x, x = tree[x].fa) {
			splay(x); tree[x].ch[1] = p; pushup(x);
		}
		return p;
	}
	inline void makeroot(int p) {
		access(p); splay(p);
		overturn(p);
	}
	inline int find(int x) {
		access(x);
		splay(x);
		while (tree[x].ch[0]) {
			pushdown(x);
			x = tree[x].ch[0];
		}
		splay(x);
		return x;
	}
	inline bool link(int x, int y) {
		makeroot(x);
		if (find(y) == x) return 0;
		tree[x].fa = y; 
		return 1;
	}
	inline void split(int x, int y) {
		makeroot(x);
		access(y);
		splay(y);
	}
	inline void cut(int x, int y) {
		makeroot(x);
		if (find(y) == x && tree[y].fa == x && tree[y].ch[0] == 0) {
			tree[y].fa = tree[x].ch[1] = 0;
			pushup(x);
		}
	}
	inline int findf(int x) {
		while (tree[x].ch[1]) {
			pushdown(x);
			x = tree[x].ch[1];
		}
		return x;
	}
	inline void cutTree(int x, int y) { // 以x为根，分离y和fa[y]
		split(x, y);
		x = findf(tree[y].ch[0]);
		cut(x, y);
	}
	inline int lca(int x, int y) {
		access(x);
		return access(y);
	}
	inline bool lt(int x, int y) { // 是否联通
		makeroot(x);
		if (find(y) == x) return 1;
		return 0;
	}
} TT;

inline void Solve() {
	cin >> N >> M;
	for (int i = 1; i <= N; i++) {
		cin >> TT.tree[i].v;
	}
	for (int i = 1; i <= M; i++) {
		int opt, x, y;
		cin >> opt >> x >> y;
		if (opt == 0) {
			TT.split(x, y);
			int ans = TT.tree[y].sum;
			cout << ans << endl;
		}
		else if (opt == 1) {
			TT.link(x, y);
		}
		else if (opt == 2) {
			TT.cut(x, y);
		}
		else {
			TT.splay(x); TT.tree[x].v = y;
			TT.pushup(x);
		}
	}
}

```
### 维护子树大小
```cpp
	makeroot(1);
	access(now);
	splay(now);
	// ans = 自己虚树值 + 自己的值 + 右子树的值
	return TT.tree[now].t + TT.tree[now].v + TT.tree[TT.tree[now].ch[1]].sum;
	inline void pushup(int x) {
		tree[x].s = tree[tree[x].ch[0]].s + tree[tree[x].ch[1]].s + 1 + tree[x].sum;
		// tree[x].sum = tree[tree[x].ch[0]].sum ^ tree[tree[x].ch[1]].sum ^ tree[x].v;
	}
	inline int access(int x) {
		int p;
		for (p = 0; x; p = x, x = tree[x].fa) {
			splay(x);
			tree[x].sum += tree[tree[x].ch[1]].s;
			tree[x].sum -= tree[p].s;
			tree[x].ch[1] = p;
			pushup(x);
		}
		return p;
	}
	inline bool link(int x, int y) {
		makeroot(x);
		if (find(y) == x) return 0;
		access(y);
		splay(y);
		tree[x].fa = y;
		tree[y].sum += tree[x].s; 
		return 1;
	}
```
### 无makeroot
```cpp
	inline void link(int x, int y) {
		access(y);
		splay(y);
		tree[x].fa = y;
		tree[y].t += tree[x].sum; 
		pushup(y);
	}
	inline void cut(int x) {
		access(x);
		splay(x);
		tree[tree[x].ch[0]].fa = 0;
		tree[x].ch[0] = 0;
		pushup(x);
	}
```
### 乘法加法混合
```cpp
struct LCT {
	struct Point {
		int s, fa, ch[2], lan;
		Z v, sum;
		Z add, mul = 1;
	} tree[MaxN];
	inline void pushup(int x) {
		tree[x].s = tree[tree[x].ch[0]].s + tree[tree[x].ch[1]].s + 1;
		tree[x].sum = tree[tree[x].ch[0]].sum + tree[tree[x].ch[1]].sum + tree[x].v;
	}
	inline bool isroot(int x) {
		return tree[tree[x].fa].ch[0] != x && tree[tree[x].fa].ch[1] != x;
	}
	inline void overturn(int x) {
		swap(tree[x].ch[0], tree[x].ch[1]);
		tree[x].lan ^= 1;
	}
	void changeadd(int x, Z v) {
		tree[x].v += v;
		tree[x].sum += v * tree[x].s;
		tree[x].add += v;
	}
	void changemul(int x, Z v) {
		tree[x].mul *= v;
		tree[x].v *= v;
		tree[x].add *= v;
		tree[x].sum *= v;
	}
	inline void pushdown(int x) {
		if (tree[x].lan) {
			overturn(tree[x].ch[0]);
			overturn(tree[x].ch[1]);
			tree[x].lan = 0;
		}

		if (tree[x].ch[0]) changemul(tree[x].ch[0], tree[x].mul);
		if (tree[x].ch[1]) changemul(tree[x].ch[1], tree[x].mul);

		tree[x].mul = 1;

		if (tree[x].ch[0]) changeadd(tree[x].ch[0], tree[x].add);
		if (tree[x].ch[1]) changeadd(tree[x].ch[1], tree[x].add);
		tree[x].add = 0;

	}
	inline void updata(int x) {
		if (!isroot(x)) updata(tree[x].fa);
		pushdown(x);
	}
	inline bool get(int x) {
		return x == tree[tree[x].fa].ch[1];
	}
	inline void rotate(int x) {
		int y = tree[x].fa, z = tree[y].fa, k = get(x);
		if (!isroot(y)) tree[z].ch[tree[z].ch[1] == y] = x;
		tree[y].ch[k] = tree[x].ch[k ^ 1];
		tree[tree[x].ch[k ^ 1]].fa = y;
		tree[x].ch[k ^ 1] = y;
		tree[y].fa = x;
		tree[x].fa = z;
		pushup(y); pushup(x);
	}
	inline void splay(int x) {
		updata(x);
		for (int f; f = tree[x].fa, !isroot(x); rotate(x)) {
			if (!isroot(f)) rotate(get(f) == get(x)? f : x);
		}
	}
	inline int access(int x) {
		int p;
		for (p = 0; x; p = x, x = tree[x].fa) {
			splay(x); tree[x].ch[1] = p; pushup(x);
		}
		return p;
	}
	inline void makeroot(int p) {
		access(p); splay(p);
		overturn(p);
	}
	inline int find(int x) {
		access(x);
		splay(x);
		while (tree[x].ch[0]) {
			pushdown(x);
			x = tree[x].ch[0];
		}
		splay(x);
		return x;
	}
	inline bool link(int x, int y) {
		makeroot(x);
		if (find(y) == x) return 0;
		tree[x].fa = y; 
		return 1;
	}
	inline void split(int x, int y) {
		makeroot(x);
		access(y);
		splay(y);
	}
	inline void cut(int x, int y) {
		makeroot(x);
		if (find(y) == x && tree[y].fa == x && tree[y].ch[0] == 0) {
			tree[y].fa = tree[x].ch[1] = 0;
			pushup(x);
		}
	}
	inline int findf(int x) {
		while (tree[x].ch[1]) {
			pushdown(x);
			x = tree[x].ch[1];
		}
		return x;
	}
	inline void cutTree(int x, int y) { // 以x为根，分离y和fa[y]
		split(x, y);
		x = findf(tree[y].ch[0]);
		cut(x, y);
	}
	inline int lca(int x, int y) {
		access(x);
		return access(y);
	}
} TT;
```
## K-D Tree
### 简单题

#### 题目描述

你有一个$N \times N$的棋盘，每个格子内有一个整数，初始时的时候全部为 $0$，现在需要维护两种操作：

- `1 x y A`    $1\le x,y\le N$，$A$ 是正整数。将格子`x`,`y`里的数字加上 $A$。
- `2 x1 y1 x2 y2`    $1 \le x_1 \le x_2 \le N$，$1 \le y_1\le y_2 \le N$。输出 $x_1, y_1, x_2, y_2$ 这个矩形内的数字和
- `3`    无 终止程序

#### 输入格式

输入文件第一行一个正整数 $N$。

接下来每行一个操作。每条命令除第一个数字之外，均要异或上一次输出的答案 `last_ans`，初始时 `last_ans` $=0$。

#### 输出格式

对于每个 $2$ 操作，输出一个对应的答案。

#### 样例 #1

##### 样例输入 #1

```
4
1 2 3 3
2 1 1 3 3
1 1 1 1
2 1 1 0 7
3
```

##### 样例输出 #1

```
3
5
```

#### 提示

$1\leq N\leq 5\times 10^5$，操作数不超过 $2\times 10^5$ 个，内存限制 $20\texttt{MB}$，保证答案在 int 范围内并且解码之后数据仍合法。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define ld long double
#define ls p << 1
#define rs p << 1 | 1
#define lowbit(x) ((x) & (-x))
const int MaxN = 2e5 + 100;
const int INF = 1e9;
int T, N, M, K, lastans, tot, rt;
int st[MaxN], top;
ld api = 0.7;
int xl, yl, xr, yr;
struct point
{
	int x, y, z;
} a[MaxN];
struct edge
{
	int L, R, U, D;
	int l, r, d;
	int sum, s;
} tree[MaxN];
void maintain(int x)
{
	tree[x].sum = tree[tree[x].l].sum + tree[tree[x].r].sum + a[x].z;
	tree[x].s = tree[tree[x].l].s + tree[tree[x].r].s + 1;
	tree[x].L = tree[x].R = a[x].x;
	tree[x].U = tree[x].D = a[x].y;
	if (tree[x].l)
	{
		tree[x].L = min(tree[x].L, tree[tree[x].l].L);
		tree[x].R = max(tree[x].R, tree[tree[x].l].R);
		tree[x].U = max(tree[x].U, tree[tree[x].l].U);
		tree[x].D = min(tree[x].D, tree[tree[x].l].D);
	}
	if (tree[x].r)
	{
		tree[x].L = min(tree[x].L, tree[tree[x].r].L);
		tree[x].R = max(tree[x].R, tree[tree[x].r].R);
		tree[x].U = max(tree[x].U, tree[tree[x].r].U);
		tree[x].D = min(tree[x].D, tree[tree[x].r].D);
	}
}
inline bool cmp1(int x, int y)
{
	return a[x].x < a[y].x;
}
inline bool cmp2(int x, int y)
{
	return a[x].y < a[y].y;
}
int build(int l, int r)
{
	if (l > r) return 0;
	int mid = (l + r) >> 1;
	ld ave1 = 0, ave2 = 0, fc1 = 0, fc2 = 0;
	for (int i = l; i <= r; i++)
	{
		ave1 += a[st[i]].x;
		ave2 += a[st[i]].y;
	}
	ave1 /= (r - l + 1);
	ave2 /= (r - l + 1);
	for (int i = l; i <= r; i++)
	{
		fc1 += (a[st[i]].x - ave1) * (a[st[i]].x - ave1);
		fc2 += (a[st[i]].y - ave2) * (a[st[i]].y - ave2);
	}
	if (fc1 > fc2)
	{
		nth_element(st + l, st + mid, st + r + 1, cmp1);
		tree[st[mid]].d = 1;
	}
	else
	{
		nth_element(st + l, st + mid, st + r + 1, cmp2);
		tree[st[mid]].d = 2;
	}
	tree[st[mid]].l = build(l, mid - 1);
	tree[st[mid]].r = build(mid + 1, r);
	maintain(st[mid]);
	return st[mid];
}
inline bool bad(int x)
{
	return api * tree[x].s <= max(tree[tree[x].l].s, tree[tree[x].r].s);
}
void print(int x)
{
	if (tree[x].l)
		print(tree[x].l);
	st[++top] = x;
	if (tree[x].r)
		print(tree[x].r);
}
void rebuild(int &x)
{
	top = 0;
	print(x);
	x = build(1, top);
}
void insert(int &x, int k)
{
	if (!x)
	{
		x = k;
		maintain(x);
		return;
	}
	if (tree[x].d == 1)
	{
		if (a[k].x <= a[x].x)
			insert(tree[x].l, k);
		else
			insert(tree[x].r, k);
	}
	else
	{
		if (a[k].y <= a[x].y)
			insert(tree[x].l, k);
		else
			insert(tree[x].r, k);
	}
	maintain(x);
	if (bad(x)) rebuild(x);

}
int query(int x)
{
	if (!x || tree[x].L > xr || tree[x].R < xl || tree[x].U < yl || tree[x].D > yr) 
        return 0;
	if (tree[x].L >= xl && tree[x].R <= xr && tree[x].U <= yr && tree[x].D >= yl) 
        return  tree[x].sum;
	int res = 0;
	if (a[x].x >= xl && a[x].x <= xr && a[x].y >= yl && a[x].y <= yr)
	{
		res += a[x].z;
	}
	return query(tree[x].l) + query(tree[x].r) + res;
}
inline void Solve()
{
	cin >> N;
	int opt;
	while (cin >> opt)
	{
		if (opt == 3)
			break;
		if (opt == 1)
		{
			int x, y, z;
			cin >> x >> y >> z;
			x ^= lastans;
			y ^= lastans;
			z ^= lastans;
			tot++;
			a[tot].x = x;
			a[tot].y = y;
			a[tot].z = z;
			insert(rt, tot);
		}
		else
		{
			cin >> xl >> yl >> xr >> yr;
			xl ^= lastans;
			xr ^= lastans;
			yl ^= lastans;
			yr ^= lastans;
			lastans = query(rt);
			cout << lastans << '\n';
		}
	}
}
signed main()
{
	Solve();
}
```
# 数论
## sqrt求根号
```cpp
int safe_sqrt(int x) {
	int ans = sqrtf(x);
	while ((ans + 1) * (ans + 1) <= x) ans++;
	while (ans * ans > x) ans--;
	return ans;
}
```
## 质数筛
```cpp
inline void pre() {
    for (int i = 2; i <= N; i++) {
        if (!vis[i]) {
            vis[i] = i;
            prime[++tot] = i;
        }
        for (int j = 1; j <= tot; j++) {
            if (prime[j] > N / i || prime[j] > vis[i]) break;
            vis[prime[j] * i] = prime[j];
        }
    }
}
```
## exgcd求逆元
```cpp
void exgcd(int a, int b, int &d, int &x, int &y) {
	int t;
	if (b == 0) {
		d = a; x = 1; y = 0;
	} else {
		exgcd(b, a % b, d, x ,y);
		t = x; x = y; y = t - (a / b) * y;
	}
}
int ny(int a, int P) {
	int x, y, d;
	exgcd(a, P, d, x, y);
	return (x % P + P) % P;
}
```
## 组合数
```cpp
struct Math {
	int jc[MaxN], ijc[MaxN], ip[MaxN];
	int ksm(int x, int y) {
		int res = 1;
		while (y) {
			if (y & 1) res = res * x % P;
			x = x * x % P;
			y >>= 1;
		}
		return res;
	}
	inline void pre(int N) {
		jc[0] = ijc[0] = 1;
		for (int i = 1; i <= N; i++) {
			jc[i] = jc[i - 1] * i % P;
		}
		ijc[N] = ksm(jc[N], P - 2);
		for (int i = N; i >= 1; i--) {
			ijc[i - 1] = ijc[i] * i % P;
		}
	}
	inline void pre1(int N) {
		jc[0] = ijc[0] = 1;
		for (int i = 1; i <= N; i++) {
			jc[i] = jc[i - 1] * i % P;
		}
		ip[1] = 1;
		for (int i = 2; i <= N; i++) {
			ip[i] = (P - P / i) * ip[P % i] % P;
		}
		for (int i = 1; i <= N; i++) {
			ijc[i] = ijc[i - 1] * ip[i] % P;
		}
	}
	inline int C(int n, int m) {
		if (m > n) return 0;
		return jc[n] * ijc[m] % P * ijc[n - m] % P;
	}
	int lucas(int n, int m) {
		if(m == 0) return 1;
		return lucas(n / P, m / P) * C(n % P, m % P) % P;
	}
	int js(int n, int m) {// n个相同的小球放入m个不同的箱子中
		return C(n + m - 1, m - 1);
	}
} TT;
```

## 【模板】扩展中国剩余定理（EXCRT）

#### 题目描述

给定  $n$ 组非负整数  $a_i, b_i$ ，求解关于  $x$ 的方程组的最小非负整数解。
$$\begin{cases} x \equiv b_1\ ({\rm mod}\ a_1) \\ x\equiv b_2\ ({\rm mod}\ a_2) \\ ... \\ x \equiv b_n\ ({\rm mod}\ a_n)\end{cases}$$

#### 输入格式

输入第一行包含整数 $n$。

接下来 $n$ 行，每行两个非负整数 $a_i, b_i$。

#### 输出格式

输出一行，为满足条件的最小非负整数 $x$。

#### 样例 #1

##### 样例输入 #1

```
3
11 6
25 9
33 17
```

##### 样例输出 #1

```
809
```

#### 提示

对于 $100 \%$ 的数据，$1 \le n \le {10}^5$，$1 \le b_i,a_i \le {10}^{12}$，保证所有 $a_i$ 的最小公倍数不超过 ${10}^{18}$。

**请注意程序运行过程中进行乘法运算时结果可能有溢出的风险。**

数据保证有解。   
#### 题解：  
与中国剩余定理的区别在$b$不互质上  
可以考虑数学归纳法，已经求出前$k-1$个方程的解$ans$  
记$M=lcm(m_1,m_2,...,m_{k-1})$  
考虑求第k个方程求出一个$x$使得$ans+x \cdot M\equiv a_k(\bmod m_k)$  
该方程等价于$x \cdot M\equiv a_k-ans(\bmod m_k)$   
令$c=a_k-ans$  
则求$x \cdot M+m_k \cdot y=c$  
利用$exgcd(M,b_i,d,x,y)$可求出x;   
$x=x \cdot \frac{c}{d}$ ;  
则$ans'=ans+x \cdot M$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define int ll
const int MaxN=1e5+100;
int N,M=1;
int a[MaxN],b[MaxN];
template<class T>
inline void qread(T &sum)
{
    sum=0;int boo=1;
    char x=getchar();
    while(x<'0'||x>'9'){if(x=='-')boo=-1;x=getchar();}
    while(x>='0'&&x<='9'){sum=(sum<<1)+(sum<<3)+x-'0';x=getchar();}
    sum*=boo;
}
template<class T>
void qput(T x)
{
    if(x<0) {x=-x;putchar('-');}
    if(x>9){qput(x/10);}
    putchar(x%10+48);
}
void exgcd(int a,int b,int &d,int &x,int &y)
{
	if(!b)
	{
		d=a;x=1;y=0;
		return;
	}
	exgcd(b,a%b,d,x,y);
	int t=x;
	x=y;y=t-a/b*y;
}
int mul(int x,int y,int p)//龟速乘
{
	int res=0;
	while(y)
	{
		if(y&1) res=(res+x)%p;
		x=(x+x)%p;
		y>>=1;
	}
	return res;
}
int excrt()
{
	int ans=a[1],M=b[1];
	for(int i=2;i<=N;i++)
	{
		int d,x,y,ts,c=((a[i]-ans)%b[i]+b[i])%b[i];
		exgcd(M,b[i],d,x,y);
		if(c%d!=0) return -1;
		ts=b[i]/d;
		x=mul(x,c/d,ts);
//		x=x*c/d%ts;
		ans+=x*M;
		M=M*ts;
		ans=(ans%M+M)%M;
	}
	return ans;
}
signed main()
{
	qread(N);
	for(int i=1;i<=N;i++)
	qread(b[i]),qread(a[i]);
	int ans=excrt();
	qput(ans);
}
```
## 【模板】Pollard-Rho算法
注意：1和质数的情况，都会使用dfs死循环
```cpp
struct PollardRho {
    vector<ll> G1; 
    inline ll mul(ll a, ll b, ll p) { //快速乘 
        ll x = (long double)a / p * b;
        return ((ull)a * b - (ull)x * p + p) % p;
    }
    inline ll ksm(ll x, ll y, ll p) {
        ll res = 1;
        while (y) {
            if (y & 1) res = mul(res, x, p);
            x = mul(x, x, p);
            y >>= 1;
        }
        return res;
    }
    ll gcd(ll x, ll y) {
        if (y == 0) return x;
        return gcd(y, x % y);
    }
    inline bool check(ll x) {
        if (x == 0 || x == 1) return 0;
        if (x == 2) return 1;
        if (x % 2 == 0) return 0;
        ll p = x - 1, q = 0;
        while (p % 2 == 0)
            q++, p /= 2;
        for (int i = 1; i <= 10; i++) {
            int a = rand() % (x - 1) + 1;
            ll v = ksm(a, p, x);
            if (v == 1) continue;
            int j;
            for (j = 1; j <= q; j++) {
                if (v == x - 1) break;
                v = mul(v, v, x);
            }
            if (j > q) return 0;
        }
        return 1;
    }
    inline ll f(ll x, ll c, ll p) { return (mul(x, x, p) + c) % p; }
    inline ll PR(ll n) {
        if (n == 4) return 2;
        ll x = rand() % (n - 1) + 1, y = x, c = rand() % (n - 1) + 1;
        x = f(x, c, n), y = f(f(y, c, n), c, n);
        for (int i = 1; x != y; i = min(i << 1, 128ll)) {
            ll cnt = 1;
            for (int j = 0; j < i; j++) {
                cnt = mul(cnt, abs(x - y), n)   ;
                if (!cnt) break;
                x = f(x, c, n), y = f(f(y, c, n), c, n);
            }
            ll d = gcd(cnt, n);
            if (d != 1) return d;
        }
        return n;
    }
    void dfs(ll n) {
        ll d = PR(n);
        while (d == n) d = PR(n);
        ll d2 = n / d;
        if (check(d)) G1.push_back(d);
        else dfs(d);
        if (check(d2)) G1.push_back(d2);
        else dfs(d2);
    }
    inline vector<ll> solve(ll x) {
		G1.clear();
        if (check(x)) G1.push_back(x);
        else dfs(x);
		sort(G1.begin(), G1.end());
		return G1;
    }
	inline vector<pair<int, int> > solve1(ll x) { // 每个质数以及出现的数量
		vector<ll> G1 = solve(x);
		vector<pair<int, int> > ans;
		int cnt = 0;
		for (int i = 0; i < (int)G1.size(); i++) {
			cnt++;
			if (i == (int)G1.size() - 1 || G1[i] != G1[i + 1]) {
				ans.push_back(make_pair(G1[i], cnt));
				cnt = 0;
			}
		}
		return ans;
	} 
} PR;
```

# 字符串
## Trie 
```cpp
struct trie{
	int nex[MaxN][26],cnt;
	bool exist[MaxN];
	inline void insert(string s){
		int p=0;
		for(int i=0;i<s.size();i++){
			int c=s[i]-'a';
			if(!nex[p][c]){
				nex[p][c]=++cnt;
			}
			p=nex[p][c];
		}
		exist[p]=1;
	}
	inline bool find(string s){
		int p=0;
		for(int i=0;i<s.size();i++){
			int c=s[i]-'a';
			if(!nex[p][c]){
				return 0;
			}
			p=nex[p][c];
		}
		return exist[p];
	}
};
```
## kmp
```cpp
struct KMP {
	vector<int> getP(string s1) { //下标1开始
		int n = s1.size() - 1;
		int j = 0;
		vector<int> p(n + 1);
		for (int i = 1; i < n; i++) {
			while (j > 0 && s1[i + 1] != s1[j + 1]) j = p[j];
			if (s1[i + 1] == s1[j + 1]) j++;
			p[i + 1] = j;
		}
		return p;
	}
	int solve(string s1, string s2) { //下标从0开始
		s1 = " " + s1;
		s2 = " " + s2;
		int n = s1.size() - 1;
		int m = s2.size() - 1;
		vector<int> p = getP(s2);
		int j = 0;
		int res = 0;
		for (int i = 0; i < n; i++) {
			while (j > 0 && s1[i + 1] != s2[j + 1]) j = p[j];
			if (s1[i + 1] == s2[j + 1]) j++;
			if (j == m) {
				res += 1;
				j = p[j];
			}
		}
		return res;
	}
} kmp;
```
## Manacher
```cpp
struct Manacher {
	int d1[MaxN], d2[MaxN], d[MaxN];
	char s1[MaxN];
	void solve(string ss) {
		int N = ss.size() - 1;
		for (int i = 1; i <= 2 * N; i++) {
			d1[i] = d2[i] = 0;
		}
		s1[1] = '#';
		for (int i = 1; i <= N; i++) {
			s1[i << 1] = ss[i];
			s1[i << 1 | 1] = '#';
		}
		N = 2 * N + 1;
		for (int i = 1, l = 1, r = 0; i <= N; i++) {
			int k = (i > r) ? 1 : min(d[l + r - i], r - i + 1);
			while (1 <= i - k && i + k <= N && s1[i - k] == s1[i + k])
				k++;
			d[i] = k--;
			if (i + k > r) {
				l = i - k;
				r = i + k;
			}
		}
		for (int i = 2; i <= N; i++) {
			if (i % 2 == 0) {
				int t = (d[i] / 2 - 1) * 2 + 1;
				d1[i / 2] = t;
			} else {
				int t = (d[i] - 1);
				d2[i / 2 + 1] = t;
			}
    	}
	}
} Manacher;
```
## 【模板】扩展 KMP（Z 函数）

### 题目描述

给定两个字符串 $a,b$，你要求出两个数组：

- $b$ 的 $z$ 函数数组 $z$，即 $b$ 与 $b$ 的每一个后缀的 LCP 长度。
- $b$ 与 $a$ 的每一个后缀的 LCP 长度数组 $p$。

对于一个长度为 $n$ 的数组 $a$，设其权值为 $\operatorname{xor}_{i=1}^n i \times (a_i + 1)$。

### 输入格式

两行两个字符串 $a,b$。  
$z[i]$表示从$i$开始和从头开始匹配，一样的部分有多长。 

```cpp
inline void getz()
{
    z[1]=len2;
    int l=0,r=0;
    for(int i=2;i<=len2;i++)
    {
        if(i>r)
        {
            while(s2[z[i]+1]==s2[z[i]+i]) z[i]++;
            l=i;r=z[i]+i-1;
        }
        else if(z[i-l+1]<r-i+1)
        {
            z[i]=z[i-l+1];
        }
        else
        {
            z[i]=r-i;
            while(s2[z[i]+1]==s2[z[i]+i]) z[i]++;
            l=i;r=z[i]+i-1;
        }
    }
}
inline void getp()
{
    int l=0,r=0;
    for(int i=1;i<=len1;i++)
    {
        if(i>r)
        {
            while(p[i]+1<=len2&&p[i]+i<=len1&&
            s2[p[i]+1]==s1[p[i]+i]) p[i]++;
            l=i;r=p[i]+i-1;
        }
        else if(z[i-l+1]<r-i+1)
        {
            p[i]=z[i-l+1];
        }
        else
        {
            p[i]=r-i;
            while(p[i]+1<=len2&&
            p[i]+i<=len1&&s2[p[i]+1]==s1[p[i]+i]) p[i]++;
            l=i;r=p[i]+i-1;
        }
    }
}
```
## 后缀数组
```cpp
struct SA {
	int sa[MaxN], rk[MaxN], oldrk[MaxN << 1], id[MaxN], key1[MaxN], cnt[MaxN], height[MaxN];
	int st[MaxN][25], logn[MaxN];
	int n;
	void init(string s1, int _n) {
		n = _n;
		for (int i = 0; i <= max(n + 1, 127); i++) {
			sa[i] = 0;
			rk[i] = 0;
			oldrk[i] = 0;
			id[i] = 0;
			key1[i] = 0;
			cnt[i] = 0;
			height[i] = 0;
		}
		getsa(s1);
		getheight(s1);
	}
	bool cmp(int x, int y, int w) {
		return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];
	}
	inline void getsa(string s) {
		int i, m = 127, p, w;
		// sa[i]表示后缀排序第i小的编号
		// rk[i]表示后缀i的排名
		for (i = 1; i <= n; ++i) ++cnt[rk[i] = s[i]];
		for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
		for (i = n; i >= 1; --i) sa[cnt[rk[i]]--] = i;

		for (w = 1;; w <<= 1, m = p) { // m=p 就是优化计数排序值域
			for (p = 0, i = n; i > n - w; --i) id[++p] = i;
			for (i = 1; i <= n; ++i) 
				if (sa[i] > w) id[++p] = sa[i] - w;
			memset(cnt, 0, (m + 1) * sizeof(int));
			for (i = 1; i <= n; ++i) ++cnt[key1[i] = rk[id[i]]];
			// 注意这里px[i] != i，因为rk没有更新，是上一轮的排名数组

			for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
			for (i = n; i >= 1; --i) sa[cnt[key1[i]]--] = id[i];
			memcpy(oldrk + 1, rk + 1, n * sizeof(int));
			for (p = 0, i = 1; i <= n; ++i) rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;
			if (p == n) break;
		}
	}
	inline void getheight(string s){
		// height[i]=lcp(sa[i],sa[i-1])
		int i, k;
		for (i = 1, k = 0; i <= n; ++i) {
			if (rk[i] == 0) continue;
			if (k) --k;
			while (i + k <= n && sa[rk[i] - 1] + k <= n && s[i + k] == s[sa[rk[i] - 1] + k]) ++k;
			height[rk[i]] = k;
		}
	}
	inline void pre() {
		logn[0] = -1;
		for (int i = 1; i <= n; i++) logn[i] = logn[i / 2] + 1;
		for (int i = 1; i <= n; i++) st[i][0] = height[i];
		for (int j = 1; j <= 20; j++) {
			int pj = 1 << (j - 1);
			for (int i = 1; i <= n; i++) {
				if (i + pj <= n)
					st[i][j] = min(st[i][j - 1], st[i + pj][j - 1]);
				else
					st[i][j] = st[i][j - 1];
			}
		}
	}
	inline int lcp(int l, int r) {
		if (l == r) return n - l + 1;
		l = rk[l];
		r = rk[r];
		if (l > r) swap(l, r);
		l++;
		int lp = r - l + 1;
		int n = 1 << logn[lp];
		return min(st[l][logn[lp]], st[r - n + 1][logn[lp]]);
	}
} SA;
```
## 【模板】后缀自动机（SAM）

#### 题目描述

给定一个只包含小写字母的字符串 $S$。

请你求出 $S$ 的所有出现次数不为 $1$ 的子串的出现次数乘上该子串长度的最大值。

#### 输入格式

一行一个仅包含小写字母的字符串 $S$。

#### 输出格式

一个整数，为所求答案。

#### 样例 #1

##### 样例输入 #1

```
abab
```

##### 样例输出 #1

```
4
```
### 后缀自动机(SAM)
```cpp
struct SAM {
	struct Point { // 2 * MaxN
		int ch[26];
		int len, fa;
		int firstPos;
	} tree[MaxN];
	int tot = 1, last = 1, F[MaxN], id[MaxN];
	inline void clear() {
		for (int i = 0; i <= tot; i++) {
			F[i] = 0;
			tree[i].len = tree[i].fa = tree[i].firstPos = 0;
			memset(tree[i].ch, 0, sizeof(tree[i].ch));
		}
		tot = 1; last = 1;
	}
	void add1(int c) {
		int p = last, np = last = ++tot;
		F[tot] = 1;
		tree[np].len = tree[p].len + 1;
		tree[np].firstPos = tree[np].len - 1;
		for (; p && !tree[p].ch[c]; p = tree[p].fa) {
			tree[p].ch[c] = np;
		} 
		if (!p) {
			tree[np].fa = 1;
		} else {
			int q = tree[p].ch[c]; 
			if (tree[q].len == tree[p].len + 1) {
				tree[np].fa = q;
			} else {
				int nq = ++tot;
				tree[nq] = tree[q];
				tree[nq].len = tree[p].len + 1;
				tree[q].fa = tree[np].fa = nq;
				for (; p && tree[p].ch[c] == q; p = tree[p].fa) {
					tree[p].ch[c] = nq;
				}
			}
		}
	}
	void sort1() {
		vector<int> vis(tot + 1);
		for (int i = 1; i <= tot; i++) vis[tree[i].len]++;
		for (int i = 1; i <= tot; i++) vis[i] += vis[i - 1];
		for (int i = tot; i >= 1; i--) id[vis[tree[i].len]--] = i;
	}
	void insert(string s1) {
		for (auto x : s1) {
			add1(x - 'A');
		}
	}
	int getF() { //出现次数
		int ans = 0;
		sort1();
		for (int i = tot; i >= 1; i--) {
			int t = id[i];
			F[tree[t].fa] += F[t];
			if (F[t] > 1) ans = max(ans, F[t] * tree[t].len);
		}
		return ans;
	}
	pair<int, int> getMinOne() { //出现一次最短的字符串长度和位置
		getF();
		int len = INF, p = 0;
		for (int i = tot; i >= 1; i--) {
			int x = id[i], f = tree[x].fa;
			if (F[x] != 1) continue;
			if (tree[f].len + 1 < len) {
				len = tree[f].len + 1;
				p = tree[x].firstPos;
			} else if (tree[f].len + 1 == len) {
				p = min(p, tree[x].firstPos);
			}
		}
		return make_pair(len, p);
	}
} SAM;
```
### EXSAM
```cpp
struct EXSAM {
	struct Point { // 2 * MaxN
		int ch[26];
		int len, fa;
	} tree[MaxN];
	int tot = 1, F[MaxN], id[MaxN];
	int vis[MaxN][10];
	inline void clear() {
		for (int i = 0; i <= tot; i++) {
			F[i] = 0;
			tree[i].len = tree[i].fa = 0;
			memset(tree[i].ch, 0, sizeof(tree[i].ch));
		}
		tot = 1;
		T = 0;
	}
	int add1(int last, int c) {
		int p = tree[last].fa, np = tree[last].ch[c];
		if (tree[np].len) return np;
		tree[np].len = tree[last].len + 1;
		for (; p && !tree[p].ch[c]; p = tree[p].fa) {
			tree[p].ch[c] = np;
		} 
		if (!p) {
			tree[np].fa = 1;
		} else {
			int q = tree[p].ch[c]; 
			if (tree[q].len == tree[p].len + 1) {
				tree[np].fa = q;
			} else {
				int nq = ++tot;
				tree[nq] = tree[q];
       			for (int i = 0; i < 26; ++i)
					tree[nq].ch[i] = tree[tree[q].ch[i]].len? tree[q].ch[i] : 0;
				tree[nq].len = tree[p].len + 1;
				tree[q].fa = tree[np].fa = nq;
				for (; p && tree[p].ch[c] == q; p = tree[p].fa) {
					tree[p].ch[c] = nq;
				}
			}
		}
		return np;
	}
	int insertTire(int x, int c) {
		if (!tree[x].ch[c]) tree[x].ch[c] = ++tot;
		vis[tree[x].ch[c]][T] = 1;
		return tree[x].ch[c];
	}
	void insert(string s1) {
		int root = 1;
		for (auto x : s1) {
			root = insertTire(root, x - 'a');
		}
		T++;
	}
	void build() {
		queue<pair<int, int>> q;
		for (int i = 0; i < 26; i++) {
			if (tree[1].ch[i]) q.push(make_pair(i, 1));
		}
		while (!q.empty()) {
			auto now = q.front(); q.pop();
			auto last = add1(now.second, now.first);
			for (int i = 0; i < 26; i++) {
				if (tree[last].ch[i]) q.push(make_pair(i, last));
			}
		}
	}
	void sort1() {
		vector<int> vis(tot + 1);
		for (int i = 1; i <= tot; i++) vis[tree[i].len]++;
		for (int i = 1; i <= tot; i++) vis[i] += vis[i - 1];
		for (int i = tot; i >= 1; i--) id[vis[tree[i].len]--] = i;
	}
	int solve() {
		int ans = 0;
		sort1();
		for (int t = tot; t >= 1; t--) {
			int i = id[t], now = tree[i].len - tree[tree[i].fa].len;
			for (int j = 0; j < T; j++) {
				vis[tree[i].fa][j] += vis[i][j];
				now *= vis[i][j];
			}
			ans += now;
		}
		return ans;
	}
} EXSAM;
```
```cpp
struct EXSAM {
	struct Point { // 2 * MaxN
		map<int, int> ch;
		int len, fa;
	} tree[MaxN];
	int tot = 1, F[MaxN], id[MaxN];
	int vis[MaxN][10];
	inline void clear() {
		for (int i = 0; i <= tot; i++) {
			F[i] = 0;
			tree[i].len = tree[i].fa = 0;
			tree[i].ch.clear();
		}
		tot = 1;
	}
	int add1(int last, int c) {
		int p = last, np = last = ++tot;
		F[tot] = 1;
		tree[np].len = tree[p].len + 1;
		for (; p && !tree[p].ch[c]; p = tree[p].fa) {
			tree[p].ch[c] = np;
		} 
		if (!p) {
			tree[np].fa = 1;
		} else {
			int q = tree[p].ch[c]; 
			if (tree[q].len == tree[p].len + 1) {
				tree[np].fa = q;
			} else {
				int nq = ++tot;
				tree[nq] = tree[q];
				tree[nq].len = tree[p].len + 1;
				tree[q].fa = tree[np].fa = nq;
				for (; p && tree[p].ch[c] == q; p = tree[p].fa) {
					tree[p].ch[c] = nq;
				}
			}
		}
		return np;
	}
	void insert(string s1) {
		int root = 1;
		for (auto x : s1) {
			root = add1(root, x);
		}
	}
	void sort1() {
		vector<int> vis(tot + 1);
		for (int i = 1; i <= tot; i++) vis[tree[i].len]++;
		for (int i = 1; i <= tot; i++) vis[i] += vis[i - 1];
		for (int i = tot; i >= 1; i--) id[vis[tree[i].len]--] = i;
	}
	int solve() {
		int ans = 0;
		// sort1();
		for (int i = tot; i >= 2; i--) {
			int t = i;
			ans += tree[t].len - tree[tree[t].fa].len;
		}
		return ans;
	}
} EXSAM;
```
### 最长公共子串
```cpp
	void build() {
		sort1();
		for (int i = 1; i <= tot; i++) {
			minn[i] = INF;
		}
	}
	// 求多个字符串最长公共字串，将第一个字符串建SAM，其余solve，最后一个为答案
	int solve(string s1) {
		int x = 1, len = 0;
		for (auto c : s1) {
			while (1) {
				if (tree[x].ch[c]) {
					x = tree[x].ch[c];
					len++;
					break;
				}
				if (!len) break;;
				if (--len == tree[tree[x].fa].len) {
					x = tree[x].fa;
				}
			}
			if (x) {
				maxn[x] = max(maxn[x], len);
			}
		}
		int ans = 0;
		for (int i = tot; i >= 1; i--) {
			int x = id[i], fa = tree[x].fa;
			maxn[fa] = max(maxn[fa], min(tree[fa].len, maxn[x]));
			minn[x] = min(minn[x], maxn[x]);
			maxn[x] = 0;
			ans = max(ans, minn[x]);
		}
		return ans;
	}
```

## 回文自动机（回文树）
```cpp
struct Pam {
	int sz, tot, last;
	int cnt[MaxN], ch[MaxN][26], len[MaxN], fail[MaxN];
	char s[MaxN];
	int node(int l) {  // 建立一个新节点，长度为 l
		sz++;
		memset(ch[sz], 0, sizeof(ch[sz]));
		len[sz] = l;
		fail[sz] = cnt[sz] = 0;
		return sz;
	}

	void clear() {  // 初始化
		sz = -1;
		last = 0;
		s[tot = 0] = '$';
		node(0);
		node(-1);
		fail[0] = 1;
	}

	int getfail(int x) {  // 找后缀回文
		while (s[tot - len[x] - 1] != s[tot]) x = fail[x];
		return x;
	}

	void insert(char c) {  // 建树
		s[++tot] = c;
		int now = getfail(last);
		if (!ch[now][c - 'a']) {
			int x = node(len[now] + 2);
			fail[x] = ch[getfail(fail[now])][c - 'a'];
			ch[now][c - 'a'] = x;
		}
		last = ch[now][c - 'a'];
		cnt[last]++;
	}

	int Solve() {
		for (int i = sz; i >= 0; i--) {
			cnt[fail[i]] += cnt[i];
		}
		int ans = 0;
		for (int i = 1; i <= sz; i++) {
			ans = max(ans, cnt[i] * len[i]);
		}
		return ans;
	}
} pam;

struct Pam {
	int sz, tot, last, num;
	int cnt[MaxN], len[MaxN], fail[MaxN];
	int fir[MaxN], nex[MaxN], go[MaxN], w[MaxN];
	int pos[MaxN];
	char s[MaxN];
	inline void add1(int x, int y, int z) {
		nex[++num] = fir[x];
		fir[x] = num;
		go[num] = y;
		w[num] = z;
	}
	inline int get(int x ,int y) {
		for (int i = fir[x]; i; i = nex[i]) {
			if (go[i] == y) return w[i];
		}
		return 0;
	}
	int node(int l) {  // 建立一个新节点，长度为 l
		sz++;
		len[sz] = l;
		fail[sz] = cnt[sz] = 0;
		return sz;
	}
	void clear() {  // 初始化
		sz = -1;
		last = 0;
		s[tot = 0] = '$';
		node(0);
		node(-1);
		fail[0] = 1;
		memset(fir, 0, sizeof fir);
		num = 0;
	}

	int getfail(int x) {  // 找后缀回文
		while (s[tot - len[x] - 1] != s[tot]) x = fail[x];
		return x;
	}

	void insert(char c) {  // 建树
		s[++tot] = c;
		int now = getfail(last);
		if (!get(now, c - 'a')) {
			int x = node(len[now] + 2);
			fail[x] = get(getfail(fail[now]), c - 'a');
			add1(now, c - 'a', x);
		}
		last = get(now, c - 'a');
		cnt[last] = cnt[fail[last]] + 1;
		pos[tot] = cnt[last];
	}
} pam;
```
## AC自动机(ACM)
```cpp
struct ACM {
	// flag: 这个点和他的nex包含不包含模式串
	// bo: 这个点包含哪几个字符串
	// vis 对应串出现次数
	// rev: 第i个字符串对应的节点
	struct Point {
		int nex;
		vector<int> bo;
		int ch[26];
	} tree[MaxN];
	int flag[MaxN], in[MaxN], ans[MaxN], rev[MaxN], vis[MaxN];
	int cnt;
	void clear() {
		for (int i = 0; i <= cnt; i++) {
			tree[i].nex = 0;
			tree[i].bo.clear();
			memset(tree[i].ch, 0, sizeof tree[i].ch);
			flag[i] = 0;
			in[i] = 0;
			rev[i] = 0;
			vis[i] = 0;
			ans[i] = 0;
		}
		cnt = 1;
	}
	void insert(string s1, int num) {
		int u = 1;
		for (int i = 0; i < (int)s1.size(); i++) {
			int c = s1[i] - 'a';
			if (!tree[u].ch[c]) {
				tree[u].ch[c] = ++cnt;
			}
			u = tree[u].ch[c];
		}
		tree[u].bo.push_back(num);
		rev[num] = u;
		flag[u] = 1;
	}
	void bfs() {
		for (int i = 0; i < 26; i++) {
			tree[0].ch[i] = 1;
		}
		queue<int> q;
		q.push(1);
		tree[1].nex = 0;
		while (!q.empty()) {
			auto u = q.front(); q.pop();
			for (int i = 0; i < 26; i++) {
				if (!tree[u].ch[i]) tree[u].ch[i] = tree[tree[u].nex].ch[i];
				else {
					q.push(tree[u].ch[i]);
					int v = tree[u].nex;
					tree[tree[u].ch[i]].nex = tree[v].ch[i];
					flag[tree[u].ch[i]] += flag[tree[v].ch[i]];
					in[tree[v].ch[i]]++;
				}
			}
		}
	}
	void topu() {
		vector<int> indeg(cnt + 1);
		queue<int> q;
		for (int i = 1; i <= cnt; i++) {
			indeg[i] = in[i];
			if (!indeg[i]) q.push(i);
		}
		while (!q.empty()) {
			int x = q.front(); q.pop();
			int y = tree[x].nex;
			for (auto t : tree[x].bo) {
				vis[t] = ans[x];
			}

			ans[y] += ans[x];
			indeg[y]--;
			if (!indeg[y]) {
				q.push(y);
			}

		}
	}
	void query(string ss) {
		int u = 1;
		for (int i = 0; i < ss.size(); i++) {
			int c = ss[i] - 'a';
			u = tree[u].ch[c];
			ans[u]++;
		}
	}

} ACM;
inline void Solve() {
	cin >> N;
	ACM.clear();
	for (int i = 1; i <= N; i++) {
		cin >> s1;
		ACM.insert(s1, i);
	}
	ACM.bfs();
	cin >> s1;
	ACM.query(s1);
	ACM.topu();
	for (int i = 1; i <= N; i++) {
		cout << ACM.vis[i] << endl;
	}
}
```
# 图论
## tarjan
```cpp
int st[MaxN], top, col, co[MaxN], num, dfn[MaxN], low[MaxN];
vector<int> G1[MaxN], G2[MaxN];
struct Point {
	int x, y;
} b[MaxN]; // 注意边需要存到b里面
int F[MaxN], ans[MaxN];
inline void tarjan(int x) {
    dfn[x] = low[x] = ++num;
    st[++top] = x;
    for (int i = 0; i < (int)G1[x].size(); i++) {
        int y = G1[x][i];
        if (!dfn[y]) {
            tarjan(y);
            low[x] = min(low[x], low[y]);
        }
        else if (!co[y]) {
            low[x] = min(low[x], dfn[y]);
        }
    }
    if (low[x] == dfn[x]) {
        co[x] = ++col;
        while (st[top] != x) {
            co[st[top]] = col;
            top--;
        }
        top--;
    }
}
inline void solve() {
	for (int i = 1; i <= N; i++) {
		if (!dfn[i]) tarjan(i);
	}
	for (int i = 1; i <= M; i++) {
		auto [x, y] = b[i];
		if (co[x] != co[y]) {
			G2[co[y]].push_back(co[x]);
			in[co[x]]++;
		}
	}
	for (int i = 1; i <= N; i++) {
		c[co[i]] += a[i];
		sum[co[i]]++;
	}
	queue<int> q;
	for (int i = 1; i <= col; i++) {
		if (!in[i]) q.push(i);
	}
	
	while (!q.empty()) {
		int x = q.front(); q.pop();
		for (auto y : G2[x]) {
			in[y]--;
			if (!in[y]) {
				q.push(y);
			}
		}
	}
}
```
## 模板】单源最短路径（标准版）
```cpp
struct Dijkstra{
	int d[MaxN], vis[MaxN];
	struct Point {
		int id, x;
		inline bool operator<(const Point &aa)const {
			return x > aa.x;
		}
	};
	priority_queue<Point>q;
	inline void solve(int S) {
		for(int i = 1; i <= N; i++) d[i] = INF, vis[i] = 0;

		d[S] = 0;
		q.push((Point){ S, 0 });
		while(!q.empty()) {
			auto [x, w] = q.top(); q.pop();
			if (vis[x]) continue;
			vis[x] = 1;
			for(auto it : G1[x]) {
				int y = it.first;
				int z = it.second;
				if(d[x] + z < d[y]) {
					d[y] = d[x] + z;
					if(!vis[y])  q.push((Point){ y, d[y] });
				}
			}
		}
	}
} dij;
```
## EK费用流处理负环
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define int ll
#define lowbit(x) (x)&(-x)
#define zuo p<<1
#define you p<<1|1
#define INF 9187201950435737471
const int MaxN=1e5+100;
int a[51][51],N,M,s,t,K,st,tt;
int fir[MaxN],nex[MaxN],go[MaxN],tot=1,w[MaxN],v[MaxN];
int ans,incf[MaxN],d[MaxN],vis[MaxN],pre[MaxN],maxn,ts,ans1,total[MaxN];
template<class T>
inline void qread(T &sum)
{
    sum=0;int boo=1;
    char x=getchar();
    while(x<'0'||x>'9'){if(x=='-')boo=-1;x=getchar();}
    while(x>='0'&&x<='9'){sum=(sum<<1)+(sum<<3)+x-'0';x=getchar();}
    sum*=boo;
}
template<class T>
void qput(T x)
{
    if(x<0) {x=-x;putchar('-');}
    if(x>9){qput(x/10);}
    putchar(x%10+48);
}
inline void add1(int x,int y,int z,int k)
{
    nex[++tot]=fir[x];fir[x]=tot;go[tot]=y;w[tot]=z;v[tot]=k;
    nex[++tot]=fir[y];fir[y]=tot;go[tot]=x;w[tot]=0;v[tot]=-k;
}
inline bool spfa(int s,int t)
{
    queue<int>q;
    memset(d,127,sizeof d);
    memset(vis,0,sizeof v);
    q.push(s);d[s]=0;vis[s]=1;
    incf[s]=INF;
    while(!q.empty())
    {
        int x=q.front();q.pop();
        vis[x]=0;
        for(int i=fir[x];i;i=nex[i])
        {
            int y=go[i],z=w[i],k=v[i];
            if(z&&d[x]+k<d[y])
            {
                d[y]=d[x]+k;
                incf[y]=min(incf[x],z);
                pre[y]=i;
                if(!vis[y])
                {
                    vis[y]=1;
                    q.push(y);
                }
            }
        }
    }
    if(d[t]>=INF) return 0;
    return 1;
}
inline void updata(int s,int t)
{
    int x=t;
    ans=0;
    while(x!=s)
    {
        int i=pre[x];
        ans+=v[i];
        w[i]-=incf[t];
        w[i^1]+=incf[t];
        x=go[i^1];
    }
    maxn+=incf[t]*ans;
    ans1+=incf[t];
}
signed main()
{
    qread(N);qread(M);
    qread(s);qread(t);
    st=N+1;tt=N+2;
    for(int i=1;i<=M;i++)
    {
        int x,y,z,k;
        qread(x);qread(y);qread(z);qread(k);
        if(k>=0)
        add1(x,y,z,k);
        else
        {
            add1(y,x,z,-k);
            total[x]-=z;total[y]+=z;
            maxn+=k*z;
        }
    }
    for(int i=1;i<=N;i++)
    {
        if(!total[i]) continue;
        if(total[i]>0)
        {
            add1(st,i,total[i],0);
        }
        else
        {
            add1(i,tt,-total[i],0);
        }
    }
    while(spfa(st,tt)) updata(st,tt);
    ans1=0;
    while(spfa(s,t)) updata(s,t);
    qput(ans1);putchar(' ');
    qput(maxn);putchar('\n');
}
```
## 最大流（dinic）
```cpp
struct wll {
	int  s, t;
	int fir[MaxN], nex[MaxN], go[MaxN], w[MaxN] , tot = 1;
	int d[MaxN], v[MaxN], cur[MaxN];
	void clear() {
		for (int i = s; i <= t; i++) {
			fir[i] = 0;
		}
		tot = 1;
	}
	void add1(int x, int y, int z) {
		nex[++tot] = fir[x]; fir[x] = tot; go[tot] = y; w[tot] = z;
		nex[++tot] = fir[y]; fir[y] = tot; go[tot] = x; w[tot] = 0;
	}
	inline bool bfs() {
		for (int i = s; i <= t; i++) {
			d[i] = 0;
		}
		queue<int> q;
		q.push(s); d[s] = 1;
        cur[s] = fir[s];
		while (!q.empty()) {
			int x = q.front(); q.pop();
			for (int i = fir[x]; i; i = nex[i]) {
				int y = go[i], z = w[i];
				if (z && !d[y]) {
                    cur[y] = fir[y];
					d[y] = d[x] + 1;
					q.push(y);
					if (y == t) return 1;
				}
			}
		}
		return 0;
	}
	int dinic(int x, int flow) {
		if (x == t) return flow;
		int rest = flow, k;
		for (int i = cur[x]; i && rest; i = nex[i]) {
			int y = go[i], z = w[i];
            cur[x] = i;
			if (z && d[y] == d[x] + 1) {
				k = dinic(y, min(rest, w[i]));
				if (!k) d[y] = 0;
				w[i] -= k;
				w[i ^ 1] += k;
				rest -= k;
			}
		}
		return flow - rest;
	}
	vector<int> vis1, vis2;
	void dfs1(int x) {
		vis1[x] = 1; 
		for (int i = fir[x]; i; i = nex[i]) {
			int y = go[i], z = w[i];
			if (vis1[y]) continue;
			if (z) {
				dfs1(y);
			}
		}
	}
	void dfs2(int x) {
		vis2[x] = 1; 
		for (int i = fir[x]; i; i = nex[i]) {
			int y = go[i], z = w[i];
			if (vis2[y]) continue;
			if (!z) {
				dfs2(y);
			}
		}
	}
	int solve() {
		int ans = 0, flow;
		while (bfs()) {
			while (flow = dinic(s, INF)) ans += flow;
		}
		return ans;
	}
} di;
```

## 费用流
```cpp
struct fyl {
	int fir[MaxN], nex[MaxN], go[MaxN], w[MaxN], v[MaxN], tot = 1;
	int d[MaxN], vis[MaxN], incf[MaxN], pre[MaxN];
	int s, t;
	int minn, ans; // 流量， 费用
	inline void add1(int x, int y, int z, int k) {
		nex[++tot] = fir[x]; fir[x] = tot; go[tot] = y; w[tot] = z; v[tot] = k;
		nex[++tot] = fir[y]; fir[y] = tot; go[tot] = x; w[tot] = 0; v[tot] = -k;
	}
	inline bool bfs() {
		queue<int> q;
		memset(d, 127, sizeof d);
		memset(vis, 0, sizeof vis);
		q.push(s);
		d[s] = 0;
		vis[s] = 1;
		incf[s] = INF;
		while (!q.empty()) {
			int x = q.front(); q.pop();
			vis[x] = 0;
			for (int i = fir[x]; i; i = nex[i]) {
				int y = go[i], z = w[i], k = v[i];
				if (z && d[x] + k < d[y]) {
					d[y] = d[x] + k;
					incf[y] = min(incf[x], z);
					pre[y] = i;
					if (!vis[y]) {
						vis[y] = 1;
						q.push(y);
					}
				}
			}
		}
		if (d[t] == INF) return 0;
		return 1;
	}
	inline void updata() {
		int x = t;
		int sum = 0;
		while (x != s) {
			int i = pre[x];
			sum += v[i];
			w[i] -= incf[t];
			w[i ^ 1] += incf[t];
			x = go[i ^ 1];
		}
		ans += sum * incf[t];
		minn += incf[t];
	}
	inline pair<int, int> solve() {
		while (bfs()) updata();
		return make_pair(minn, ans);
	}
} fyl;
```
## 2-SAT
```cpp
struct TwoSat {
	int st[MaxN], top, col, co[MaxN], num, dfn[MaxN], low[MaxN];
	vector<int> G1[MaxN];
	int N;
	void clear(int n) {
		col = top = num = 0;
		for (int i = 0; i <= 2 * n; i++) {
			st[i] = co[i] = dfn[i] = low[i] = 0;
			G1[i].clear();
		}
	}
	void init(int n) {
		clear(n);
		N = n;
	}

	inline void tarjan(int x) {
		dfn[x] = low[x] = ++num;
		st[++top] = x;
		for (auto y : G1[x]) {
			if (!dfn[y]) {
				tarjan(y);
				low[x] = min(low[x], low[y]);
			}
			else if (!co[y]) {
				low[x] = min(low[x], dfn[y]);
			}
		}
		if (low[x] == dfn[x]) {
			co[x] = ++col;
			while (st[top] != x) {
				co[st[top]] = col;
				top--;
			}
			top--;
		}
	}
	int inv(int x) {
		if (x > N) return x - N;
		return x + N;
	}
	void insert(int x, int y) {
		G1[x].push_back(y);
	}
	void add1(int x, int y) { //蕴含关系
		G1[x].push_back(y);
		G1[inv(y)].push_back(inv(x));
	}
	void equal(int x, int y) {
		add1(x, y);
		add1(inv(x), inv(y));
	}
	void unequal(int x, int y) {
		add1(x, inv(y));
		add1(inv(x), y);
	}
	void either(int x, int y) {
		G1[inv(x)].push_back(y);
		G1[inv(y)].push_back(x);
	}
	void equalTrue(int x) { //设x为真
		G1[inv(x)].push_back(x);
	}
	bool run() {
		for (int i = 1; i <= 2 * N; i++) {
			if (!dfn[i]) tarjan(i);
		}
		for (int i = 1; i <= N; i++) {
			if (co[i] == co[i + N]) return 0;
		}
		return 1;
	}
	vector<int> query() {
		vector<int> now(N);
		for (int i = 1; i <= N; i++) {
			now[i - 1] = co[i] < co[inv(i)];
		}
		return now;
	}
} TS;
```
# dp
## 斜率优化
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define lowbit(x) (x)&(-x)
#define zuo p<<1
#define you p<<1|1
#define INF 2147483647
const int MaxN=1e6+100;
int N,M,l,r;
ll a,b,c,sum[MaxN],F[MaxN],q[MaxN];
double js(int x,int y)
{
	double sum1=-b*sum[y]+a*sum[y]*sum[y]+F[y]-
    (-b*sum[x]+a*sum[x]*sum[x]+F[x]);
	double sum2=sum[y]-sum[x];
	return sum1/sum2;
}
int main()
{
	qread(N);
	qread(a);qread(b);qread(c);
	memset(F,-127,sizeof F);
	F[0]=0;
	for(int i=1;i<=N;i++)
	{
		qread(sum[i]);
		sum[i]+=sum[i-1];
	}
	l=r=1;
	q[l]=0;
	for(int i=1;i<=N;i++)
	{
		while(l<r&&js(q[l],q[l+1])>2*a*sum[i]) l++;
		int j=q[l];
		F[i]=F[j]+a*(sum[i]-sum[j])*(sum[i]-sum[j])+
        b*(sum[i]-sum[j])+c;
		while(l<r&&js(q[r-1],q[r])<js(q[r],i)) r--;
		q[++r]=i;
	}
	qput(F[N]);
}
```

# 计算几何
```cpp
const ld eps = 1e-12;
struct Point {
	ld x, y;
	inline ld Rand() {
		return rand() / (ld)RAND_MAX;
	}
	inline void shake() {
		x += (Rand() - 0.5) * eps;
		y += (Rand() - 0.5) * eps;
	}
	inline bool operator <(const Point &aa) const{
		if (x != aa.x) return x < aa.x;
		return y < aa.y; 
	}
	inline double operator*(const Point &aa) const {
		return x * aa.x + y * aa.y;
	}
	inline ld operator /(const Point &aa) const {
		return x * aa.y - y * aa.x;
	}
	inline Point operator +(const Point &aa) const {
		return (Point){aa.x + x, aa.y + y};
	}
	inline Point operator -(const Point &aa) const {
		return (Point){x - aa.x, y - aa.y};
	}
	inline Point operator ^(const ld k) const {
		return (Point){x * k, y * k};
	}
	inline Point xz() {
		if (x >= 0 && y >= 0)
			return (Point){-y, x};
		else if (x < 0 && y > 0)
			return (Point){-y, x};
		else if (x < 0 && y < 0)
			return (Point){-y, x};
		else
			return (Point){-y, x};
	}
	inline ld len() {
		return sqrt(x * x + y * y);
	}
};

inline bool same(ld x, ld y) { //判断相等
	if (fabs(x - y) < eps) return 1;
	return 0;
}
inline bool cmp2(Point x, Point y) { //极角排序
	if (same(x / y, 0)) {
		return x.len() < y.len();
	}
	return x / y > 0;
}
```
### 二维凸包
```cpp
int st[MaxN], top;
vector<Point> tubao(vector<Point> a) {
	vector<Point> b;
	if (a.size() == 0) return b;
	for (int i = 0; i < (int)a.size(); i++) {
		used[i] = 0;
	}
	sort(a.begin(), a.end());
	top = 0;
	st[++top] = 0;
	for (int i = 1; i < (int)a.size(); i++) {
		while (top >= 2 && (a[st[top]] - a[st[top - 1]]) / (a[i] - a[st[top]]) <= 0) {
			used[st[top--]] = 0;
		}
		used[i] = 1;
		st[++top] = i;
	}
	int tmp = top;
	for (int i = a.size() - 2; i >= 0; i--) {
		if (!used[i]) {
			while (top > tmp && (a[st[top]] - a[st[top - 1]]) / (a[i] - a[st[top]]) <= 0) {
				used[st[top--]] = 0;
			}
			used[i] = 1;
			st[++top] = i;
		}
	}
	for (int i = 1; i <= top; i++) {
		b.push_back(a[st[i]]);
	}
	return b;
}
```
### 两直线交点
```cpp
Point add1(Point a1, Point a2, Point b1, Point b2) {
	Point t1 = a2 - a1;
	Point t2 = b2 - b1;
	Point t3 = b1 - a1;
    if (fabs(t2 / t1) < esp) return (Point){ -1e9 , -1e9 };
	ld t = (t2 / t3) / (t2 / t1);
	t = max(t, -t);
	return a1 + (t1 ^ t);
}
```

### 判断在凸包内
```cpp
int in(Point x) {
	if (x / A[2] > 0 || A[tot] / x > 0) return 0;
	int ps = lower_bound(A + 1, A + 1 + tot, x, cmp2) - (A + 1);
	if (same((x - A[ps]) / (A[ps % tot + 1] - A[ps]), 0) && ps == tot) {
		return x.len() <= A[ps].len();
	}
	return (x - A[ps]) / (A[ps % tot + 1] - A[ps]) <= 0;
}
```
### 多边形面积
```cpp
ld CalaS() {
	ld res = 0;
	for (int i = 3; i <= top; i++) {
		res += (a[i - 1]  - a[1]) / (a[i] - a[1]);
	}
	return res / 2;
}
```
### 判断圆和线段有几个交点
```cpp
inline int check(Point x) { // 1 out
	ld len = (x - a[0]).len();
	if (same(len, K)) return 0;
	if (len > K) return 1;
	if (len < K) return -1;
	return 0;
}
inline int js(Point x, Point y) { //a[0] 是圆的坐标， K是半径
	ld dis = (a[0] - x) / (a[0] - y);
	dis = fabs(dis);
	dis /= (x - y).len();
	ld t1 = pd(x, y, a[0]);
	ld t2 = pd(y, x, a[0]);
	if (same(dis, K)) {
		if (t1 < 0 || t2 < 0) {
			return 0;
		}
		return 1;
	}
	if (dis > K) return 0;
	if (check(x) == -1 && check(y) == -1) return 0;
	if (check(x) >= 0 && check(y) >= 0) {
		if (t1 < 0 || t2 < 0) return 0;
		int ans = 2;
		if (same((x - a[0]).len(), K) == 1) ans--;
		if (same((y - a[0]).len(), K) == 1) ans--;
		return ans;
	}
	if (check(x) == 0 || check(y) == 0) return 0;
	return 1;
}
```
### 半平面交
```cpp
Point add1(Point a1, Point a2, Point b1, Point b2) {
	Point t1 = a2 - a1;
	Point t2 = b2 - b1;
	Point t3 = b1 - a1;
	ld t = (t2 / t3) / (t2 / t1);
	t = max(t, - t);
	t1.x *= t;
	t1.y *= t;
	return a1 + t1;
}
void cut(Point x, Point y) {
	a[top + 1] = a[1];
	tot = 0;
	for (int i = 1; i <= top; i++) {
		ld v1 = (a[i] - x) / (a[i] - y);
		ld v2 = (a[i + 1] - x) / (a[i + 1] - y);
		if (v1 >= 0) {
			c[++tot] = a[i];
		}
		if (v1 * v2 < 0) {
			c[++tot] = add1(a[i], a[i + 1], x, y);
		}
	}
	for (int i = 1; i <= tot; i++) {
		a[i] = c[i];
	}
	top = tot;
}
```

### 旋转卡壳
```cpp
double js(int x, int y, int z) {
	return (a[y] - a[x]) / (a[z] - a[x]);
}
double dj(int x, int y, int z) {
	return (a[y] - a[x]) * (a[z] - a[x]);
}
signed() {
	int j = 3, l = 2, r = 2;
	double t1 = 0, t2 = 0, t3 = 0, ans = 1e18;
	point b[4];
	for (int i = 1; i < top; i++) {
		while (js(st[i], st[i + 1], st[j]) <= js (st[i], st[i + 1], st[j % top + 1])) {
			j = j % top + 1;
		}
		while (dj(st[i], st[i + 1], st[r]) <= dj(st[i], st[i + 1], st[r % top + 1])) {
			r = r % top + 1;
		}
		if (i == 1) {
			l = r;
		}
		while (dj(st[i], st[i + 1], st[l]) >= dj(st[i], st[i + 1], st[l % top + 1])) {
			l = l % top + 1;
		}
		t1 = js(st[i], st[i + 1], st[j]);
		t2 = abs((a[st[r]] - a[st[i]]) * (a[st[i + 1]] - a[st[i]])) + 
			 abs((a[st[l]] - a[st[i + 1]]) * (a[st[i]] - a[st[i + 1]])) -
			 abs((a[st[i + 1]] - a[st[i]]) * (a[st[i]] - a[st[i + 1]]));
		t3 = abs((a[st[i + 1]] - a[st[i]]) * (a[st[i]] - a[st[i + 1]]));
		// cout << t1 << ' ';
		// cout << t2 << ' ';
		// cout << t3 << endl;
		if (ans > t1 * t2 / t3) {
			ans = min(ans, t1 * t2 / t3);
			point mm = a[st[i + 1]] - a[st[i]];
			point m1 = mm;
			double h = t1 / mm.len();
			double ch = ans / h;
			m1.x *= dj(st[i], st[i + 1], st[r]) / (a[st[i + 1]] - a[st[i]]).len() / (a[st[i + 1]] - a[st[i]]).len();
			m1.y *= dj(st[i], st[i + 1], st[r]) / (a[st[i + 1]] - a[st[i]]).len() / (a[st[i + 1]] - a[st[i]]).len();
			b[1] = a[st[i]] + m1;

			mm = mm.xz();
			m1 = mm;
			m1.x *= h / mm.len();
			m1.y *= h / mm.len();
			b[2] = b[1] + m1;

			mm = mm.xz();
			m1 = mm;
			m1.x *= ch / mm.len();
			m1.y *= ch / mm.len();
			b[3] = b[2] + m1;

			mm = mm.xz();
			m1 = mm;
			m1.x *= h / mm.len();
			m1.y *= h / mm.len();
			b[0] = b[3] + m1;

			ans = min(ans, t1 * t2 / t3);
		}
	}
	int id = 0, maxn1 = 1e18;
	printf("%.5lf\n", ans);
	for (int i = 0; i < 4; i++) {
		b[i].x += eps;
		b[i].y += eps;
		if (b[i].y < maxn1) {
			id = i;
			maxn1 = b[i].y;
		}
	}
	int nowsum = 0;
	for (int i = id; i < 4; i = (i + 1) % 4) {
		nowsum++;
		if (nowsum == 5) break;
		printf("%.5lf %.5lf\n", b[i].x, b[i].y);
	}
}
```

### 闵可夫斯基和
```cpp
vector<Point> Minkowski(vector<Point> t1, vector<Point> t2) {
	vector<Point> A;
	if (t1.size() == 0 || t2.size() == 0) return A;
	for (int i = 1; i < (int)t1.size(); i++) s1[i] = t1[i] - t1[i - 1];
	for (int i = 1; i < (int)t2.size(); i++) s2[i] = t2[i] - t2[i - 1];
	A.push_back(t1[0] + t2[0]);
	int p1 = 1, p2 = 1, tot = 0;
	while(p1 < (int) t1.size() && p2 < (int) t2.size()) {
		A.push_back((Point){0, 0});
		tot++;
		A[tot] = A[tot - 1] + (s1[p1] / s2[p2] >= 0? s1[p1++] : s2[p2++]);
	}
	while (p1 < (int) t1.size()) {
		A.push_back((Point){0, 0});
		tot++;
		A[tot] = A[tot - 1] + s1[p1++];
	}
	while (p2 < (int)t2.size()) {
		A.push_back((Point){0, 0});
		tot++;
		A[tot] = A[tot - 1] + s2[p2++];
	}
	return A;
}
```
```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using vi = vector<int>;
using pii = pair<int, int>;

#define endl '\n'
#define all(x) (x).begin(), (x).end()
#define UNIQUE(x) (x).erase(unique(all(x)), (x).end())

#define rep(it, ff, ee) for (int it = (ff); it <= (ee); ++it)
#define per(it, ff, ee) for (int it = (ff); it >= (ee); --it)

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int T;
    cin >> T;
    while (T--) {
        ll x, m;
        cin >> x >> m;

        ll k = 1;
        while (k <= x) k <<= 1;

        ll ans = 0;
        if (m <= k) {
            rep (y, 1, m) {
                ll p = x ^ y;
                if (p != 0 && (x % p == 0 || y % p == 0)) ++ans;
            }
            cout << ans << endl;
            continue;
        }

        ll y_ = k;
        while (--y_) {
            ll p = x ^ y_;
            if (p != 0 && (x % p == 0 || y_ % p == 0)) ++ans;
        }

        cout << ans << endl;
    }

    return 0;
}