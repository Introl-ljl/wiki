
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://wiki.introl.top/OI/%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF/%E6%80%BB%E8%B5%84%E6%96%99/">
      
      
        <link rel="prev" href="../%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF_README/">
      
      
        <link rel="next" href="../../%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0_README/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.8">
    
    
      
        <title>总资料 - Introl's Knowledge Base</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.8608ea7d.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Introl&#39;s Knowledge Base" class="md-header__button md-logo" aria-label="Introl's Knowledge Base" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Introl's Knowledge Base
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              总资料
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  简介

      </a>
    </li>
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../../OI_README/" class="md-tabs__link">
          
  
  OI

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/whk_README/" class="md-tabs__link">
          
  
  文化课

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Introl&#39;s Knowledge Base" class="md-nav__button md-logo" aria-label="Introl's Knowledge Base" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Introl's Knowledge Base
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    简介
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="">
            
  
  <span class="md-ellipsis">
    OI
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            OI
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../OI_README/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    OI部分简介
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    个人模板
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2_2">
            <span class="md-nav__icon md-icon"></span>
            个人模板
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%B8%AA%E4%BA%BA%E6%A8%A1%E6%9D%BF_README/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    README
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    总资料
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    总资料
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#o2" class="md-nav__link">
    <span class="md-ellipsis">
      $O2$ 优化
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      高精度
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      哈希
    </span>
  </a>
  
    <nav class="md-nav" aria-label="哈希">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      单哈希
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mod" class="md-nav__link">
    <span class="md-ellipsis">
      Mod网赛
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      普通莫队
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      样例 #1
    </span>
  </a>
  
    <nav class="md-nav" aria-label="样例 #1">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    <span class="md-ellipsis">
      样例输入 #1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_2" class="md-nav__link">
    <span class="md-ellipsis">
      样例输出 #1
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      树上莫队
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      整体二分
    </span>
  </a>
  
    <nav class="md-nav" aria-label="整体二分">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      [国家集训队]矩阵乘法
    </span>
  </a>
  
    <nav class="md-nav" aria-label="[国家集训队]矩阵乘法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      题目描述
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      输入格式
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      输出格式
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_3" class="md-nav__link">
    <span class="md-ellipsis">
      样例 #1
    </span>
  </a>
  
    <nav class="md-nav" aria-label="样例 #1">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_4" class="md-nav__link">
    <span class="md-ellipsis">
      样例输入 #1
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_5" class="md-nav__link">
    <span class="md-ellipsis">
      样例输出 #1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      数据规模与约定
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cdq" class="md-nav__link">
    <span class="md-ellipsis">
      cdq分治
    </span>
  </a>
  
    <nav class="md-nav" aria-label="cdq分治">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      【模板】三维偏序（陌上花开）
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#kd-tree" class="md-nav__link">
    <span class="md-ellipsis">
      KD-Tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      带权并查集
    </span>
  </a>
  
    <nav class="md-nav" aria-label="带权并查集">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      题解
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      离散化
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    <span class="md-ellipsis">
      手打队列
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    <span class="md-ellipsis">
      点分治
    </span>
  </a>
  
    <nav class="md-nav" aria-label="点分治">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_6" class="md-nav__link">
    <span class="md-ellipsis">
      【模板】点分治1
    </span>
  </a>
  
    <nav class="md-nav" aria-label="【模板】点分治1">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    <span class="md-ellipsis">
      题目描述
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    <span class="md-ellipsis">
      输入格式
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    <span class="md-ellipsis">
      输出格式
    </span>
  </a>
  
    <nav class="md-nav" aria-label="输出格式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    <span class="md-ellipsis">
      数据规模与约定。
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    <span class="md-ellipsis">
      树上启发式合并
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3" >
        
          
          <label class="md-nav__link" for="__nav_2_3" id="__nav_2_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    算法文章
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_3">
            <span class="md-nav__icon md-icon"></span>
            算法文章
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0_README/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    简介
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3_2" >
        
          
          <label class="md-nav__link" for="__nav_2_3_2" id="__nav_2_3_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    个人笔记
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_3_2">
            <span class="md-nav__icon md-icon"></span>
            个人笔记
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E9%80%92%E5%BD%92%E5%8F%8A%E9%80%92%E6%8E%A8/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    学习笔记-1-递归及递推
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-DFS-BFS%E7%AE%97%E6%B3%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    学习笔记-2-DFS-BFS算法
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../算法文章/学习笔记-3-二分" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    学习笔记-3-二分
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    学习笔记-4-前缀和-差分
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E7%AE%97%E6%B3%95%E6%96%87%E7%AB%A0/%E8%AF%BE%E4%BB%B6/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    课件
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88_README/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    题解集合
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E8%B5%84%E6%BA%90%E9%93%BE%E6%8E%A5/%E8%B5%84%E6%BA%90%E9%93%BE%E6%8E%A5_README/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    资源链接
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    文化课
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            文化课
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/whk_README/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    文化课部分简介
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/%E8%AF%AD%E6%96%87/%E8%AF%AD%E6%96%87_README/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    语文
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/%E6%95%B0%E5%AD%A6/%E6%95%B0%E5%AD%A6_README/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数学
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/%E8%8B%B1%E8%AF%AD/%E8%8B%B1%E8%AF%AD_README/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    英语
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/%E7%89%A9%E7%90%86/%E7%89%A9%E7%90%86_README/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    物理
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/%E5%8C%96%E5%AD%A6/%E5%8C%96%E5%AD%A6_README/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    化学
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/%E7%94%9F%E7%89%A9/%E7%94%9F%E7%89%A9_README/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    生物
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/%E6%94%BF%E6%B2%BB/%E6%94%BF%E6%B2%BB_README/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    政治
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/%E5%9C%B0%E7%90%86/%E5%9C%B0%E7%90%86_README/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    地理
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E9%AB%98%E4%B8%AD%E6%96%87%E5%8C%96%E8%AF%BE/%E5%8E%86%E5%8F%B2/%E5%8E%86%E5%8F%B2_README/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    历史
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#o2" class="md-nav__link">
    <span class="md-ellipsis">
      $O2$ 优化
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      高精度
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      哈希
    </span>
  </a>
  
    <nav class="md-nav" aria-label="哈希">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      单哈希
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mod" class="md-nav__link">
    <span class="md-ellipsis">
      Mod网赛
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      普通莫队
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      样例 #1
    </span>
  </a>
  
    <nav class="md-nav" aria-label="样例 #1">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    <span class="md-ellipsis">
      样例输入 #1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_2" class="md-nav__link">
    <span class="md-ellipsis">
      样例输出 #1
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      树上莫队
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      整体二分
    </span>
  </a>
  
    <nav class="md-nav" aria-label="整体二分">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      [国家集训队]矩阵乘法
    </span>
  </a>
  
    <nav class="md-nav" aria-label="[国家集训队]矩阵乘法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      题目描述
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      输入格式
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      输出格式
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_3" class="md-nav__link">
    <span class="md-ellipsis">
      样例 #1
    </span>
  </a>
  
    <nav class="md-nav" aria-label="样例 #1">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_4" class="md-nav__link">
    <span class="md-ellipsis">
      样例输入 #1
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_5" class="md-nav__link">
    <span class="md-ellipsis">
      样例输出 #1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      数据规模与约定
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cdq" class="md-nav__link">
    <span class="md-ellipsis">
      cdq分治
    </span>
  </a>
  
    <nav class="md-nav" aria-label="cdq分治">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      【模板】三维偏序（陌上花开）
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#kd-tree" class="md-nav__link">
    <span class="md-ellipsis">
      KD-Tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      带权并查集
    </span>
  </a>
  
    <nav class="md-nav" aria-label="带权并查集">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      题解
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      离散化
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    <span class="md-ellipsis">
      手打队列
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    <span class="md-ellipsis">
      点分治
    </span>
  </a>
  
    <nav class="md-nav" aria-label="点分治">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_6" class="md-nav__link">
    <span class="md-ellipsis">
      【模板】点分治1
    </span>
  </a>
  
    <nav class="md-nav" aria-label="【模板】点分治1">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    <span class="md-ellipsis">
      题目描述
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    <span class="md-ellipsis">
      输入格式
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    <span class="md-ellipsis">
      输出格式
    </span>
  </a>
  
    <nav class="md-nav" aria-label="输出格式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    <span class="md-ellipsis">
      数据规模与约定。
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    <span class="md-ellipsis">
      树上启发式合并
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<!-- TOC -->

<ul>
<li><a href="#杂项">杂项</a><ul>
<li><a href="#o2-优化">$O2$ 优化</a></li>
<li><a href="#高精度">高精度</a></li>
<li><a href="#哈希">哈希</a><ul>
<li><a href="#单哈希">单哈希</a></li>
</ul>
</li>
<li><a href="#mod网赛">Mod网赛</a></li>
<li><a href="#普通莫队">普通莫队</a></li>
<li><a href="#样例-1">样例 #1</a><ul>
<li><a href="#样例输入-1">样例输入 #1</a></li>
<li><a href="#样例输出-1">样例输出 #1</a></li>
</ul>
</li>
<li><a href="#树上莫队">树上莫队</a></li>
<li><a href="#整体二分">整体二分</a><ul>
<li><a href="#国家集训队矩阵乘法">[国家集训队]矩阵乘法</a><ul>
<li><a href="#题目描述">题目描述</a></li>
<li><a href="#输入格式">输入格式</a></li>
<li><a href="#输出格式">输出格式</a></li>
<li><a href="#样例-1-1">样例 #1</a>
        - <a href="#样例输入-1-1">样例输入 #1</a></li>
<li><a href="#样例输出-1-1">样例输出 #1</a></li>
<li><a href="#数据规模与约定">数据规模与约定</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#cdq分治">cdq分治</a><ul>
<li><a href="#模板三维偏序陌上花开">【模板】三维偏序（陌上花开）</a></li>
</ul>
</li>
<li><a href="#kd-tree">KD-Tree</a></li>
<li><a href="#并查集">并查集</a></li>
<li><a href="#带权并查集">带权并查集</a><ul>
<li><a href="#题解">题解</a></li>
</ul>
</li>
<li><a href="#离散化">离散化</a></li>
<li><a href="#手打队列">手打队列</a></li>
<li><a href="#点分治">点分治</a><ul>
<li><a href="#模板点分治1">【模板】点分治1</a><ul>
<li><a href="#题目描述-1">题目描述</a></li>
<li><a href="#输入格式-1">输入格式</a></li>
<li><a href="#输出格式-1">输出格式</a><ul>
<li><a href="#数据规模与约定-1">数据规模与约定。</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#树上启发式合并">树上启发式合并</a></li>
</ul>
</li>
<li><a href="#数据结构">数据结构</a><ul>
<li><a href="#st-表">ST 表</a></li>
<li><a href="#fhq-treap">FHQ-treap</a><ul>
<li><a href="#平衡树维护hash">平衡树维护Hash</a></li>
<li><a href="#普通平衡树">普通平衡树</a><ul>
<li><a href="#添点">添点</a></li>
<li><a href="#合并">合并</a></li>
<li><a href="#分裂">分裂</a><ul>
<li><a href="#普通">普通</a></li>
<li><a href="#区间分裂">区间分裂</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#mathcalo1建树">$\mathcal{O}(1)$建树</a></li>
<li><a href="#fhq-treap给编号寻位置">FHQ-Treap给编号寻位置</a></li>
</ul>
</li>
<li><a href="#模板文艺平衡树splay">【模板】文艺平衡树（Splay）</a><ul>
<li><a href="#题目描述-2">题目描述</a><ul>
<li><a href="#输入格式-2">输入格式</a></li>
<li><a href="#输出格式-2">输出格式</a></li>
<li><a href="#思路">思路</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#树状数组">树状数组</a></li>
<li><a href="#线段树">线段树</a><ul>
<li><a href="#introl">Introl</a></li>
</ul>
</li>
<li><a href="#权值线段树">权值线段树</a></li>
<li><a href="#树链剖分">树链剖分</a><ul>
<li><a href="#introl-1">Introl</a></li>
</ul>
</li>
<li><a href="#模板可持久化线段树-1可持久化数组">【模板】可持久化线段树 1（可持久化数组）</a><ul>
<li><a href="#题目描述-3">题目描述</a></li>
</ul>
</li>
<li><a href="#模板可持久化线段树-2主席树">【模板】可持久化线段树 2(主席树)</a></li>
<li><a href="#可持久化并查集">可持久化并查集</a></li>
<li><a href="#odt">ODT</a></li>
<li><a href="#模板左偏树可并堆">【模板】左偏树（可并堆）</a><ul>
<li><a href="#题目描述-4">题目描述</a><ul>
<li><a href="#输入格式-3">输入格式</a></li>
<li><a href="#输出格式-3">输出格式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#模板可持久化平衡树">【模板】可持久化平衡树</a>
        - <a href="#题目背景">题目背景</a>
        - <a href="#题目描述-5">题目描述</a>
        - <a href="#输入格式-4">输入格式</a>
        - <a href="#输出格式-4">输出格式</a></li>
<li><a href="#模板可持久化文艺平衡树">【模板】可持久化文艺平衡树</a>
        - <a href="#题目描述-6">题目描述</a>
        - <a href="#输入格式-5">输入格式</a>
        - <a href="#输出格式-5">输出格式</a>
        - <a href="#提示">提示</a></li>
<li><a href="#lca">LCA</a></li>
<li><a href="#vani有约会雨天的尾巴-模板线段树合并">[Vani有约会]雨天的尾巴 /【模板】线段树合并</a><ul>
<li><a href="#题目描述-7">题目描述</a><ul>
<li><a href="#输入格式-6">输入格式</a></li>
<li><a href="#输出格式-6">输出格式</a></li>
<li><a href="#样例-1-2">样例 #1</a><ul>
<li><a href="#样例输入-1-2">样例输入 #1</a></li>
<li><a href="#样例输出-1-2">样例输出 #1</a></li>
</ul>
</li>
<li><a href="#提示-1">提示</a><ul>
<li><a href="#思路-1">思路</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#模板线段树分裂">【模板】线段树分裂</a><ul>
<li><a href="#题目描述-8">题目描述</a><ul>
<li><a href="#输入格式-7">输入格式</a></li>
<li><a href="#输出格式-7">输出格式</a></li>
<li><a href="#样例-1-3">样例 #1</a><ul>
<li><a href="#样例输入-1-3">样例输入 #1</a></li>
<li><a href="#样例输出-1-3">样例输出 #1</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#树套树">树套树</a><ul>
<li><a href="#1线段树套fhq-treap">1.线段树套FHQ-treap</a><ul>
<li><a href="#模板二逼平衡树树套树">【模板】二逼平衡树（树套树）</a></li>
<li><a href="#题目描述-9">题目描述</a></li>
<li><a href="#输入格式-8">输入格式</a></li>
<li><a href="#输出格式-8">输出格式</a></li>
</ul>
</li>
<li><a href="#2树状数组套主席树">2.树状数组套主席树</a><ul>
<li><a href="#题目描述-10">题目描述</a></li>
</ul>
</li>
<li><a href="#权值线段树套权值线段树二维单点修改矩形查询">权值线段树套权值线段树(二维单点修改，矩形查询)</a></li>
</ul>
</li>
<li><a href="#模板动态树link-cut-tree">【模板】动态树（Link Cut Tree）</a><ul>
<li><a href="#题目描述-11">题目描述</a></li>
<li><a href="#输入格式-9">输入格式</a></li>
<li><a href="#输出格式-9">输出格式</a></li>
<li><a href="#样例-1-4">样例 #1</a><ul>
<li><a href="#样例输入-1-4">样例输入 #1</a></li>
<li><a href="#样例输出-1-4">样例输出 #1</a></li>
</ul>
</li>
<li><a href="#样例-2">样例 #2</a><ul>
<li><a href="#样例输入-2">样例输入 #2</a></li>
<li><a href="#样例输出-2">样例输出 #2</a></li>
</ul>
</li>
<li><a href="#维护子树大小">维护子树大小</a></li>
<li><a href="#无makeroot">无makeroot</a></li>
<li><a href="#乘法加法混合">乘法加法混合</a></li>
</ul>
</li>
<li><a href="#k-d-tree">K-D Tree</a><ul>
<li><a href="#简单题">简单题</a><ul>
<li><a href="#题目描述-12">题目描述</a></li>
<li><a href="#输入格式-10">输入格式</a></li>
<li><a href="#输出格式-10">输出格式</a></li>
<li><a href="#样例-1-5">样例 #1</a><ul>
<li><a href="#样例输入-1-5">样例输入 #1</a></li>
<li><a href="#样例输出-1-5">样例输出 #1</a></li>
</ul>
</li>
<li><a href="#提示-2">提示</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#数论">数论</a><ul>
<li><a href="#sqrt求根号">sqrt求根号</a></li>
<li><a href="#质数筛">质数筛</a></li>
<li><a href="#exgcd求逆元">exgcd求逆元</a></li>
<li><a href="#组合数">组合数</a></li>
<li><a href="#模板扩展中国剩余定理excrt">【模板】扩展中国剩余定理（EXCRT）</a>
        - <a href="#题目描述-13">题目描述</a>
        - <a href="#输入格式-11">输入格式</a>
        - <a href="#输出格式-11">输出格式</a>
        - <a href="#样例-1-6">样例 #1</a>
            - <a href="#样例输入-1-6">样例输入 #1</a>
            - <a href="#样例输出-1-6">样例输出 #1</a>
        - <a href="#提示-3">提示</a>
        - <a href="#题解-1">题解：</a></li>
<li><a href="#模板pollard-rho算法">【模板】Pollard-Rho算法</a></li>
</ul>
</li>
<li><a href="#字符串">字符串</a><ul>
<li><a href="#trie">Trie</a></li>
<li><a href="#kmp">kmp</a></li>
<li><a href="#manacher">Manacher</a></li>
<li><a href="#模板扩展-kmpz-函数">【模板】扩展 KMP（Z 函数）</a><ul>
<li><a href="#题目描述-14">题目描述</a></li>
<li><a href="#输入格式-12">输入格式</a></li>
</ul>
</li>
<li><a href="#后缀数组">后缀数组</a></li>
<li><a href="#模板后缀自动机sam">【模板】后缀自动机（SAM）</a>
        - <a href="#题目描述-15">题目描述</a>
        - <a href="#输入格式-13">输入格式</a>
        - <a href="#输出格式-12">输出格式</a>
        - <a href="#样例-1-7">样例 #1</a>
            - <a href="#样例输入-1-7">样例输入 #1</a>
            - <a href="#样例输出-1-7">样例输出 #1</a><ul>
<li><a href="#后缀自动机sam">后缀自动机(SAM)</a></li>
<li><a href="#exsam">EXSAM</a></li>
<li><a href="#最长公共子串">最长公共子串</a></li>
</ul>
</li>
<li><a href="#回文自动机回文树">回文自动机（回文树）</a></li>
<li><a href="#ac自动机acm">AC自动机(ACM)</a></li>
</ul>
</li>
<li><a href="#图论">图论</a><ul>
<li><a href="#tarjan">tarjan</a></li>
<li><a href="#模板单源最短路径标准版">模板】单源最短路径（标准版）</a></li>
<li><a href="#ek费用流处理负环">EK费用流处理负环</a></li>
<li><a href="#最大流dinic">最大流（dinic）</a></li>
<li><a href="#费用流">费用流</a></li>
<li><a href="#2-sat">2-SAT</a></li>
</ul>
</li>
<li><a href="#dp">dp</a><ul>
<li><a href="#斜率优化">斜率优化</a></li>
</ul>
</li>
<li><a href="#计算几何">计算几何</a>
        - <a href="#二维凸包">二维凸包</a>
        - <a href="#两直线交点">两直线交点</a>
        - <a href="#判断在凸包内">判断在凸包内</a>
        - <a href="#多边形面积">多边形面积</a>
        - <a href="#判断圆和线段有几个交点">判断圆和线段有几个交点</a>
        - <a href="#半平面交">半平面交</a>
        - <a href="#旋转卡壳">旋转卡壳</a>
        - <a href="#闵可夫斯基和">闵可夫斯基和</a></li>
</ul>
<!-- /TOC -->
<h1 id="_1">杂项</h1>
<h2 id="o2">$O2$ 优化</h2>
<pre><code class="language-cpp">#pragma GCC optimize(1, 2, 3, &quot;Ofast&quot;, &quot;inline&quot;)

if ((ed - st) / CLOCKS_PER_SEC &gt;= 0.9) break;

ios::sync_with_stdio(0);
cin.tie(0);

windos: -std=c++17 -Wl,--stack=1024000000     
linux: ulimit -s unlimited  

ll qread_tmp;
#define read() qread(qread_tmp)
template&lt;class T&gt;
inline T qread(T &amp;sum) {
    sum=0;int boo=1;
    char x=getchar();
    while(x&lt;'0'||x&gt;'9'){if(x=='-')boo=-1;x=getchar();}
    while(x&gt;='0'&amp;&amp;x&lt;='9'){sum=(sum&lt;&lt;1)+(sum&lt;&lt;3)+x-'0';x=getchar();}
    sum*=boo;
    return sum;
}
template&lt;class T&gt;
void qput(T x) {
    if(x&lt;0) {x=-x;putchar('-');}
    if(x&gt;9) qput(x/10);
    putchar(x%10+48);
}



namespace IN {
    const int MAXN_INPUT = 1000000;
    #define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + inbuf -&gt; sgetn(buf, MAXN_INPUT), p1 == p2) ? EOF : *p1++)
    char buf[MAXN_INPUT], *p1, *p2;
    template &lt;typename T&gt; inline bool qread(T &amp;x) {
        static std::streambuf *inbuf = cin.rdbuf();
        x = 0;
        register int f = 0, flag = false;
        register char ch = getc();
        while (!std::isdigit(ch)) {
            if (ch == '-') f = 1;
        ch = getc();
        }
        if (std::isdigit(ch)) x = x * 10 + ch - '0', ch = getc(),flag = true;
        while (std::isdigit(ch)) {
            x = x * 10 + ch - 48;
            ch = getc();
        }
        x = f ? -x : x ;
        return flag;
    }
    template &lt;typename T,typename ...Args&gt; inline bool qread(T&amp; a,Args&amp; ...args) {
       return qread(a) &amp;&amp; qread(args...);
    }
    #undef getc
}

namespace OUT {
    template &lt;typename T&gt; inline void qput(T x) {
        static std::streambuf *outbuf = cout.rdbuf();
        static char stack[255];
        static int top = 0;
        if (x &lt; 0) {
            outbuf -&gt; sputc('-');
            x=-x;
        }
        if (!x) {
            outbuf -&gt; sputc('0');
            outbuf -&gt; sputc('\n');
            return;
        }
        while (x) {
            stack[++top] = x % 10 + '0';
            x /= 10;
        }
        while (top) {
            outbuf -&gt; sputc(stack[top]);
            -- top;
        }
    }
    inline void putc (const char ch) {
        static std::streambuf *outbuf = cout.rdbuf();
        outbuf -&gt; sputc(ch);
    }
    template &lt;typename T&gt; inline void qput(const char ch,T x)
    {
        static std::streambuf *outbuf = cout.rdbuf();
        static char stack[255];
        static int top = 0;
        if (x &lt; 0) {
            outbuf -&gt; sputc('-');
            x=-x;
        }
        if (!x) {
            outbuf -&gt; sputc('0');
            outbuf -&gt; sputc(ch);
            return;
        }
        while (x) {
            stack[++top] = x % 10 + '0';
            x /= 10;
        }
        while (top) {
            outbuf -&gt; sputc(stack[top]);
            --top;
        }
        outbuf -&gt; sputc(ch);
    }
    template&lt;typename T,typename ...Args&gt; inline void qput(T a,Args ...args) {
        qput(a); qput(args...);
    }
    template&lt;typename T,typename ...Args&gt; inline void qput(const char ch,T a,Args ...args) {
        qput(ch, a); qput(ch, args...);
    }
}
using IN::qread;
using OUT::qput;
using OUT::putc;
</code></pre>
<h2 id="_2">高精度</h2>
<pre><code class="language-cpp">struct BigInteger {
    static const int BASE = 100000000;
    static const int WIDTH = 8;
    vector&lt;int&gt; s;
    bool negative;

    BigInteger(long long num = 0) { *this = num; }
    BigInteger(const string&amp; str) { *this = str; }

    BigInteger operator=(long long num) {
        s.clear();
        negative = num &lt; 0;
        num = std::abs(num);
        do {
            s.push_back(num % BASE);
            num /= BASE;
        } while (num &gt; 0);
        return *this;
    }

    BigInteger operator=(const string&amp; str) {
        s.clear();
        negative = str[0] == '-';
        int x, len = (str.length() - 1 - negative) / WIDTH + 1;
        for (int i = 0; i &lt; len; i++) {
            int end = str.length() - i * WIDTH;
            int start = max(negative ? 1ll : 0ll, end - WIDTH);
            sscanf(str.substr(start, end - start).c_str(), &quot;%lld&quot;, &amp;x);
            s.push_back(x);
        }
        return *this;
    }

    bool operator&lt;(const BigInteger&amp; b) const {
        if (negative != b.negative) return negative;
        if (s.size() != b.s.size()) return negative ? s.size() &gt; b.s.size() : s.size() &lt; b.s.size();
        for (int i = s.size() - 1; i &gt;= 0; i--)
            if (s[i] != b.s[i]) return negative ? s[i] &gt; b.s[i] : s[i] &lt; b.s[i];
        return false;
    }
    bool operator&gt;(const BigInteger&amp; b) const { return b &lt; *this; }
    bool operator&lt;=(const BigInteger&amp; b) const { return !(b &lt; *this); }
    bool operator&gt;=(const BigInteger&amp; b) const { return !(*this &lt; b); }
    bool operator!=(const BigInteger&amp; b) const { return b &lt; *this || *this &lt; b; }
    bool operator==(const BigInteger&amp; b) const { return !(b &lt; *this) &amp;&amp; !(*this &lt; b); }

    BigInteger operator+(const BigInteger&amp; b) const {
        if (negative == b.negative) {
            BigInteger c;
            c.negative = negative;
            c.s.clear();
            for (int i = 0, g = 0;; i++) {
                if (g == 0 &amp;&amp; i &gt;= s.size() &amp;&amp; i &gt;= b.s.size()) break;
                int x = g;
                if (i &lt; s.size()) x += s[i];
                if (i &lt; b.s.size()) x += b.s[i];
                c.s.push_back(x % BASE);
                g = x / BASE;
            }
            return c;
        }
        return *this - (-b);
    }

    BigInteger operator-(const BigInteger&amp; b) const {
        if (negative == b.negative) {
            if (abs() &gt;= b.abs()) {
                BigInteger c;
                c.negative = negative;
                c.s.clear();
                for (int i = 0, g = 0;; i++) {
                    if (g == 0 &amp;&amp; i &gt;= s.size() &amp;&amp; i &gt;= b.s.size()) break;
                    int x = g;
                    if (i &lt; s.size()) x += s[i];
                    if (i &lt; b.s.size()) x -= b.s[i];
                    if (x &lt; 0) {
                        c.s.push_back(x + BASE);
                        g = -1;
                    } else {
                        c.s.push_back(x);
                        g = 0;
                    }
                }
                c.killzero();
                return c;
            }
            return -(b - *this);
        }
        return *this + (-b);
    }

    BigInteger operator*(const BigInteger&amp; b) const {
        BigInteger c;
        c.s.resize(s.size() + b.s.size(), 0);
        c.negative = negative != b.negative;
        for (int i = 0; i &lt; s.size(); i++) {
            long long carry = 0;
            for (int j = 0; j &lt; b.s.size(); j++) {
                long long sum = (long long)s[i] * b.s[j] + c.s[i + j] + carry;
                c.s[i + j] = sum % BASE;
                carry = sum / BASE;
            }
            if (carry) c.s[i + b.s.size()] += carry;
        }
        c.killzero();
        return c;
    }

    BigInteger operator/(const BigInteger&amp; b) const {
        BigInteger c, cur;
        c.s.resize(s.size());
        cur.negative = negative;
        c.negative = negative != b.negative;
        BigInteger abs_b = b.abs();
        for (int i = s.size() - 1; i &gt;= 0; i--) {
            cur = cur * BASE + s[i];
            int x = 0, l = 0, r = BASE;
            BigInteger cur_b = cur.abs();
            while (l &lt;= r) {
                int mid = (l + r) / 2;
                if (abs_b * mid &lt;= cur_b) {
                    x = mid;
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
            c.s[i] = x;
            cur = cur - abs_b * x;
        }
        c.killzero();
        return c;
    }

    BigInteger operator/(const int&amp; b) const {
        BigInteger c;
        c.s.clear();
        long long r = 0;
        c.negative = negative != (b &lt; 0);
        int abs_b = std::abs(b);
        for (int i = s.size() - 1; i &gt;= 0; --i) {
            r = r * BASE + s[i];
            c.s.push_back(r / abs_b);
            r %= abs_b;
        }
        reverse(c.s.begin(), c.s.end());
        c.killzero();
        return c;
    }

    BigInteger operator%(const BigInteger&amp; b) const {
        return *this - (*this / b) * b;
    }

    BigInteger operator%(const int&amp; b) const {
        return *this - (*this / b) * b;
    }

    BigInteger operator+=(const BigInteger&amp; b) {
        *this = *this + b;
        return *this;
    }
    BigInteger operator++(signed) {
        *this = *this + 1;
        return *this;
    }
    BigInteger operator++() {
        *this = *this + 1;
        return *this;
    }
    BigInteger operator-=(const BigInteger&amp; b) {
        *this = *this - b;
        return *this;
    }
    BigInteger operator--(signed) {
        *this = *this - 1;
        return *this;
    }
    BigInteger operator--() {
        *this = *this - 1;
        return *this;
    }
    BigInteger operator*=(const BigInteger&amp; b) {
        *this = *this * b;
        return *this;
    }
    BigInteger operator/=(const BigInteger&amp; b) {
        *this = *this / b;
        return *this;
    }
    BigInteger operator%=(const BigInteger&amp; b) {
        *this = *this % b;
        return *this;
    }

    BigInteger operator-() const {
        BigInteger c = *this;
        c.negative = !negative;
        return c;
    }

    BigInteger abs() const {
        BigInteger c = *this;
        c.negative = false;
        return c;
    }

    void killzero() {
        while (s.back() == 0 &amp;&amp; s.size() &gt; 1)
            s.pop_back();
    }

    friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const BigInteger&amp; x) {
        if (x.negative) out &lt;&lt; '-';
        out &lt;&lt; x.s.back();
        for (int i = x.s.size() - 2; i &gt;= 0; i--) {
            char buf[20];
            sprintf(buf, &quot;%08d&quot;, x.s[i]);
            out &lt;&lt; buf;
        }
        return out;
    }

    friend istream&amp; operator&gt;&gt;(istream&amp; in, BigInteger&amp; x) {
        string s;
        if (!(in &gt;&gt; s)) return in;
        x = s;
        return in;
    }
};
</code></pre>
<h2 id="_3">哈希</h2>
<pre><code class="language-cpp">const int P1 = 1e9 + 7;
const int P2 = 1e9 + 9;
const int b1 = 33331;
const int b2 = 32141;
struct Hash {
    ll x, y;
    Hash(): x(0), y(0) {}
    Hash(ll x): x(x), y(x) {}
    Hash(ll t1, ll t2): x(t1), y(t2) {}
    inline bool operator==(const Hash &amp;aa) const {
        if (x == aa.x &amp;&amp; y == aa.y) return 1;
        return 0;
    }
    inline bool operator!=(const Hash &amp;aa) const {
        return !(*this == aa);
    }
    inline void js(){
        x = (x % P1 + P1) % P1;
        y = (y % P2 + P2) % P2;
    }
    inline bool operator&lt;(const Hash &amp;aa) const {
        if (x != aa.x) return x &lt; aa.x;
        return y &lt; aa.y;
    }
    inline Hash operator+(const Hash &amp;aa) const {
        return (Hash){ x + aa.x, y + aa.y };
    }
    inline Hash operator-(const Hash &amp;aa) const {
        return (Hash){ x - aa.x, y - aa.y };
    }
    inline Hash operator*(const Hash &amp;aa) const {
        return (Hash){ x * aa.x, y * aa.y };
    }
    inline Hash operator*(const ll &amp;aa) const {
        return (Hash){ x * aa, y * aa };
    }
    inline Hash operator%(const Hash &amp;aa) const {
        return (Hash){ (x % aa.x + aa.x) % aa.x, (y % aa.y + aa.y) % aa.y };
    }
    inline void print() {
        cout &lt;&lt; x &lt;&lt; ' ';
        cout &lt;&lt; y &lt;&lt; endl;
    }
};
struct my_hash {
  static uint64_t splitmix64(uint64_t x) {
    x += 0x9e3779b97f4a7c15;
    x = (x ^ (x &gt;&gt; 30)) * 0xbf58476d1ce4e5b9;
    x = (x ^ (x &gt;&gt; 27)) * 0x94d049bb133111eb;
    return x ^ (x &gt;&gt; 31);
  }

  size_t operator()(uint64_t x) const {
    static const uint64_t FIXED_RANDOM =
        chrono::steady_clock::now().time_since_epoch().count();
    return splitmix64(x + FIXED_RANDOM);
  }

  // 针对 std::pair&lt;int, int&gt; 作为主键类型的哈希函数
  size_t operator()(Hash x) const {
    static const uint64_t FIXED_RANDOM =
        chrono::steady_clock::now().time_since_epoch().count();
    return splitmix64(x.x + FIXED_RANDOM) ^
           (splitmix64(x.y + FIXED_RANDOM) &gt;&gt; 1);
  }
};
const Hash P = {P1, P2};
const Hash B = {b1, b2};
unordered_map&lt;Hash, int, my_hash&gt; mp;
struct TT {
    Hash sum[MaxN], power[MaxN];
    void pre(string s1, int N) {
        power[0] = Hash(1);
        for (int i = 1; i &lt;= N; i++) {
            sum[i] = (sum[i - 1] * B + Hash(s1[i])) % P;
            power[i] = power[i - 1] * B % P;
        }
    }
    Hash query(int l, int r) {
        Hash ans = sum[r] - sum[l - 1] * power[r - l + 1] % P;
        ans.js();
        return ans;
    }
} TT[2];
</code></pre>
<h3 id="_4">单哈希</h3>
<pre><code class="language-cpp">const int P1 = 1e9 + 7;
const int P2 = 1e9 + 9;
const int b1 = 33331;
const int b2 = 32141;
struct Hash {
    ll x;
    Hash(): x(0) {}
    Hash(ll x): x(x) {}
    Hash(ll t1, ll t2): x(t1) {}
    inline bool operator==(const Hash &amp;aa) const {
        if (x == aa.x) return 1;
        return 0;
    }
    inline bool operator!=(const Hash &amp;aa) const {
        return !(*this == aa);
    }
    inline void js(){
        x = (x % P1 + P1) % P1;
    }
    inline bool operator&lt;(const Hash &amp;aa) const {
        return x &lt; aa.x;
    }
    inline Hash operator+(const Hash &amp;aa) const {
        return (Hash){ x + aa.x };
    }
    inline Hash operator-(const Hash &amp;aa) const {
        return (Hash){ x - aa.x };
    }
    inline Hash operator*(const Hash &amp;aa) const {
        return (Hash){ x * aa.x };
    }
    inline Hash operator*(const ll &amp;aa) const {
        return (Hash){ x * aa };
    }
    inline Hash operator%(const Hash &amp;aa) const {
        return (Hash){ (x % aa.x + aa.x) % aa.x };
    }
    inline void print() {
        cout &lt;&lt; x &lt;&lt; ' ';
    }
};
struct my_hash {
  static uint64_t splitmix64(uint64_t x) {
    x += 0x9e3779b97f4a7c15;
    x = (x ^ (x &gt;&gt; 30)) * 0xbf58476d1ce4e5b9;
    x = (x ^ (x &gt;&gt; 27)) * 0x94d049bb133111eb;
    return x ^ (x &gt;&gt; 31);
  }

  size_t operator()(uint64_t x) const {
    static const uint64_t FIXED_RANDOM =
        chrono::steady_clock::now().time_since_epoch().count();
    return splitmix64(x + FIXED_RANDOM);
  }

};
const Hash P = {P1};
const Hash B = {b1};
unordered_map&lt;Hash, int, my_hash&gt; mp;
struct TT {
    vector&lt;Hash&gt; sum, power;
    void pre(string s1, int N) {
        sum.assign(N + 1, 0);
        power.assign(N + 1, 0);
        power[0] = Hash(1);
        for (int i = 1; i &lt;= N; i++) {
            sum[i] = (sum[i - 1] * B + Hash(s1[i])) % P;
            power[i] = power[i - 1] * B % P;
        }
    }
    Hash query(int l, int r) {
        Hash ans = sum[r] - sum[l - 1] * power[r - l + 1] % P;
        ans.js();
        return ans;
    }
} TT, Ta[MaxN];
</code></pre>
<h2 id="mod">Mod网赛</h2>
<pre><code class="language-cpp">template&lt;class T&gt;
constexpr T ksm(T x, ll y) {
    T res = 1;
    while (y) {
        if (y &amp; 1) res = res * x;
        x = x * x;
        y &gt;&gt;= 1;
    }
    return res;
}

constexpr ll mul(ll a, ll b, ll p) { //快速乘 
    ll x = (long double)a / p * b;
    return ((ull)a * b - (ull)x * p + p) % p;
}

template&lt;ll P&gt;
struct MLong {
    ll x;
    constexpr MLong() : x{} {}
    constexpr MLong(ll x) : x{norm(x % getMod())} {}

    static ll Mod;
    constexpr static ll getMod() {
        if (P &gt; 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(ll Mod_) {
        Mod = Mod_;
    }
    constexpr ll norm(ll x) const {
        if (x &lt; 0) {
            x += getMod();
        }
        if (x &gt;= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr ll val() const {
        return x;
    }
    explicit constexpr operator ll() const {
        return x;
    }
    constexpr MLong operator-() const {
        MLong res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MLong inv() const {
        assert(x != 0);
        return ksm(*this, getMod() - 2);
    }
    constexpr MLong &amp;operator*=(MLong rhs) &amp; {
        x = mul(x, rhs.x, getMod());
        return *this;
    }
    constexpr MLong &amp;operator+=(MLong rhs) &amp; {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MLong &amp;operator-=(MLong rhs) &amp; {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MLong &amp;operator/=(MLong rhs) &amp; {
        return *this *= rhs.inv();
    }
    friend constexpr MLong operator*(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MLong operator+(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MLong operator-(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MLong operator/(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &amp;operator&gt;&gt;(std::istream &amp;is, MLong &amp;a) {
        ll v;
        is &gt;&gt; v;
        a = MLong(v);
        return is;
    }
    friend constexpr std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const MLong &amp;a) {
        return os &lt;&lt; a.val();
    }
    friend constexpr bool operator==(MLong lhs, MLong rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MLong lhs, MLong rhs) {
        return lhs.val() != rhs.val();
    }
};

template&lt;&gt;
ll MLong&lt;0LL&gt;::Mod = (ll)(1E18) + 9;

template&lt;int P&gt;
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(ll x) : x{norm(x % getMod())} {}

    static int Mod;
    static int getMod() {
        if (P &gt; 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if (x &lt; 0) {
            x += getMod();
        }
        if (x &gt;= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return ksm(*this, getMod() - 2);
    }
    constexpr MInt &amp;operator*=(MInt rhs) &amp; {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr MInt &amp;operator+=(MInt rhs) &amp; {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &amp;operator-=(MInt rhs) &amp; {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &amp;operator/=(MInt rhs) &amp; {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &amp;operator&gt;&gt;(std::istream &amp;is, MInt &amp;a) {
        ll v;
        is &gt;&gt; v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const MInt &amp;a) {
        return os &lt;&lt; a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};

template&lt;&gt;
int MInt&lt;0&gt;::Mod = 998244353;

template&lt;int V, int P&gt;
constexpr MInt&lt;P&gt; CInv = MInt&lt;P&gt;(V).inv();

constexpr int P = 1e9 + 7;
using Z = MInt&lt;P&gt;;
</code></pre>
<h2 id="_5">普通莫队</h2>
<p>给出一个长度为n 的数列，$a_{1}$​ ,$a_{2}$​ ,...,$a_{n}$ ，有q 个询问，每个询问给出数对$(i,j)$，需要你给出$a_{i}$​ ，$a_{i+1}$​ ，...，$a_{j}$​ 这一段中有多少不同的数字</p>
<h2 id="1">样例 #1</h2>
<h3 id="1_1">样例输入 #1</h3>
<pre><code>5
1 1 2 1 3
3
1 5
2 4
3 5
</code></pre>
<h3 id="1_2">样例输出 #1</h3>
<pre><code>3
2
3
</code></pre>
<pre><code class="language-cpp">    #include&lt;bits/stdc++.h&gt;
    using namespace std;
    #define ll long long 
    #define int ll
    #define zuo p&lt;&lt;1
    #define you p&lt;&lt;1|1
    #define lowbit(x) ((x)&amp;(-x))
    const int MaxN=1e6+100;
    int N,M,K,b[MaxN],ans[MaxN],sum;
    int vis[MaxN];
    struct point
    {
        int l, r, t, id;
        inline bool operator&lt;(const Point &amp;aa) const {
            if (t != aa.t) return t &lt; aa.t;
            if (t &amp; 1) return r &lt; aa.r;
            return r &gt; aa.r;
        }
    }a[MaxN];
    inline void move(int x,int v)
    {
        vis[b[x]]+=v;
        if(v==1&amp;&amp;vis[b[x]]==1) sum++;
        if(v==-1&amp;&amp;vis[b[x]]==0) sum--;
    }
    inline void md()
    {
        sort(a+1,a+1+M);
        int l=0,r=0;
        for(int i=1;i&lt;=M;i++)
        {
            while(l&gt;a[i].l) move(--l,1);
            while(r&lt;a[i].r) move(++r,1);
            while(l&lt;a[i].l) move(l++,-1);
            while(r&gt;a[i].r) move(r--,-1);
            ans[a[i].id]=sum;
        }
    }
    signed main()
    {
        qread(N);
        for(int i=1;i&lt;=N;i++) qread(b[i]);
        K=sqrt(N);qread(M); //K = 1000可能会比较快
        for(int i=1;i&lt;=M;i++)
        {
            qread(a[i].l);qread(a[i].r);
            a[i].t=a[i].l/K;
            a[i].id=i;
        }
        md();
        for(int i=1;i&lt;=M;i++)
        qput(ans[i]),putchar('\n');
    }
</code></pre>
<h2 id="_6">树上莫队</h2>
<p>$ 题意：给你一棵树，树上第 i 个点颜色为 c_i，每次询问一条路径 u_i,v_i, 求这条路径上的 $ <br />
$\sum_{c} {val_c \sum_{i=1}^{cnt_c} w_i }$<br />
$ 其中：val 表示该颜色的价值，cnt 表示颜色出现的次数，w 表示该颜色出现 i 次后的价值 $</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
#define int ll
const int MaxN = 1e6 + 100;
const int INF = 1e9;
int T, N, M, K;
int a[MaxN], b[MaxN], vis[MaxN], c[MaxN], s[MaxN];
int dep[MaxN], fa[MaxN][31];
int d[MaxN], top, fr[MaxN], la[MaxN], num1, num2, ans;
int jg[MaxN];
vector&lt;int&gt; G1[MaxN];
struct point
{
    int l, r, time, id;
    inline bool operator&lt;(const point &amp;aa)const
    {
        if (l / T == aa.l / T &amp;&amp; r / T == aa.r / T)
        {
            return time &lt; aa.time;
        }
        if (l / T == aa.l / T)
        {
            return r / T &gt; aa.r / T;
        }
        return l / T &lt; aa.l / T;
    }
}q1[MaxN], q2[MaxN];
void dfs1(int x, int f)
{
    d[++top] = x;
    fr[x] = top;
    dep[x] = dep[f] + 1;
    fa[x][0] = f;
    for (int i = 1; i &lt;= 20; i++)
    {
        fa[x][i] = fa[fa[x][i - 1]][i - 1];
    }
    for (int i = 0; i &lt; (int)G1[x].size(); i++)
    {
        int y = G1[x][i];
        if (y == f)
        {
            continue;
        }
        dfs1(y, x);
    }
    d[++top] = x;
    la[x] = top;
}
int lca(int x, int y)
{
    if (dep[x] &lt; dep[y])
        swap(x, y);
    for (int i = 20; i &gt;= 0; i--)
    {
        if (dep[fa[x][i]] &gt;= dep[y])
        {
            x = fa[x][i];
        }
        if (x == y)
            return x;
    }
    for (int i = 20; i &gt;= 0; i--)
    {
        if (fa[x][i] != fa[y][i])
        {
            x = fa[x][i];
            y = fa[y][i];
        }
    }
    return fa[x][0];
}
inline void add1(int x)
{
    int t = d[x];
    vis[t] ^= 1;
    if (vis[t] == 1)
    {
        s[c[t]]++;
        ans += a[c[t]] * b[s[c[t]]];
    }
    else
    {
        ans -= a[c[t]] * b[s[c[t]]];
        s[c[t]]--;
    }
}
void upt(int x, int t)
{
    if (vis[q2[t].l])
    {
        add1(fr[q2[t].l]);
        swap(c[q2[t].l], q2[t].r);
        add1(fr[q2[t].l]);
        return;
    }
    swap(c[q2[t].l], q2[t].r);
}
void md()
{
    sort(q1 + 1, q1 + num1 + 1);
    int l = 1, r = 1, t = 0;
    s[c[1]]++;
    ans = a[c[1]] * b[1];
    vis[1] = 1;
    for (int i = 1; i &lt;= num1; i++)
    {
        int li = q1[i].l, ri = q1[i].r;
        while (li &lt; l) add1(--l);
        while (ri &gt; r) add1(++r);
        while (li &gt; l) add1(l++);
        while (ri &lt; r) add1(r--);
        while (t &lt; q1[i].time) upt(i, ++t);
        while (t &gt; q1[i].time) upt(i, t--);
        int k = lca(d[li], d[ri]);
        if (k != d[li] &amp;&amp; k != d[ri])
        {
            jg[q1[i].id] = ans + a[c[k]] * b[s[c[k]] + 1];
        }
        else
        jg[q1[i].id] = ans;
    }
}
inline void Solve()
{
    qread(N); qread(M); qread(K);
//  K = 4;
    T = pow(2 * N, 0.6666);
    for (int i = 1; i &lt;= M; i++)
    {
        qread(a[i]);
    }
    for (int i = 1; i &lt;= N; i++)
    {
        qread(b[i]);
    }
    for (int i = 1; i &lt; N; i++)
    {
        int x, y;
        qread(x); qread(y);
        G1[x].push_back(y);
        G1[y].push_back(x);
    }
    dfs1(1, 0);
    for (int i = 1; i &lt;= N; i++)
    {
        qread(c[i]);
    }
    for (int i = 1; i &lt;= K; i++)
    {
        int opt, x, y;
        qread(opt);qread(x);qread(y);
        if (opt == 0)
        {
            ++num2;
            q2[num2].l = x;
            q2[num2].id = num2;
            q2[num2].r = y;
        }
        if (opt == 1)
        {
            ++num1;
            if (fr[x] &gt; fr[y])
                swap(x, y);
            q1[num1].id = num1;
            if (lca(x, y) == x)
                q1[num1].l = fr[x];
            else
                q1[num1].l = la[x];
            q1[num1].r = fr[y];
            q1[num1].time = num2; 
        }
    }
    md();
    for (int i = 1; i &lt;= num1; i++)
    {
        qput(jg[i]);putchar('\n');
    }
}
signed main()
{
    Solve();
}
</code></pre>
<h2 id="_7">整体二分</h2>
<h3 id="_8">[国家集训队]矩阵乘法</h3>
<h4 id="_9">题目描述</h4>
<p>给你一个 $n \times n$ 的矩阵，不用算矩阵乘法，但是每次询问一个子矩形的第 $k$ 小数。</p>
<h4 id="_10">输入格式</h4>
<p>第一行有两个整数，分别表示矩阵大小 $n$ 和询问组数 $q$。</p>
<p>第 $2$ 到第 $(n + 1)$ 行，每行 $n$ 个整数，表示这个矩阵。第 $(i + 1)$ 行的第 $j$ 个数表示矩阵第 $i$ 行第 $j$ 列的数 $a_{i, j}$。</p>
<p>接下来 $q$ 行，每行五个整数 $x_1, y_1, x_2, y_2, k$，表示一组询问，要求找到以 $(x_1, y_1)$ 为左上角，$(x_2, y_2)$ 为右下角的子矩形中的第 $k$ 小数。</p>
<h4 id="_11">输出格式</h4>
<p>对于每组询问，输出一行一个整数表示答案。</p>
<h4 id="1_3">样例 #1</h4>
<h6 id="1_4">样例输入 #1</h6>
<pre><code>2 2
2 1
3 4
1 2 1 2 1
1 1 2 2 3
</code></pre>
<h4 id="1_5">样例输出 #1</h4>
<pre><code>1
3
</code></pre>
<h4 id="_12">数据规模与约定</h4>
<ul>
<li>对于 $100\%$ 的数据，保证 $1 \leq n \leq 500$，$1 \leq q \leq 6 \times 10^4$，$0 \leq a_{i, j} \leq 10^9$。</li>
</ul>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
#define int ll
#define ls p &lt;&lt; 1
#define rs p &lt;&lt; 1 | 1
#define lowbit(x) ((x) &amp; (-x))
const int MaxN = 501;
const int MaxM = 1e6 + 100;
const int INF = 1e9;
int T, N, M, K;
int a[MaxN][MaxN], c[MaxM], tot;
int ans[MaxM];
int tree[MaxN][MaxN];
vector&lt;pair&lt;int, int&gt; &gt; G1[MaxM];
struct point
{
    int x1, x2;
    int y1, y2;
    int k, id;
}b[MaxM], q1[MaxM], q2[MaxM];
int ef(int x)
{
    int l = 1, r = tot;
    while (l &lt;= r)
    {
        int mid = (l + r) &gt;&gt; 1;
        if (c[mid] &gt;= x) r = mid - 1;
        else l = mid + 1;
    }
    return l;
}
void add1(int x, int y, int v)
{
    for (int i = x; i &lt;= N; i += lowbit(i))
    {
        for (int j = y; j &lt;= N; j += lowbit(j))
        {
            tree[i][j] += v;
        }
    }
}
int query(int x, int y)
{
    int ans = 0;
    for (int i = x; i; i -= lowbit(i))
    {
        for (int j = y; j; j -= lowbit(j))
        {
            ans += tree[i][j];
        }
    }
    return ans;
}
int query1(int x1, int y1, int x2, int y2)
{
    return query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);
}
void solve(int l, int r, int x, int y)
{
    if (l == r)
    {
        for (int i = x; i &lt;= y; i++)
        {
            ans[b[i].id] = l;
        }
        return;
    }
    int mid = (l + r) &gt;&gt; 1;
    int sum1 = x - 1;
    int sum2 = y + 1;
    for (int i = l; i &lt;= mid; i++)
    {
        for (int j = 0; j &lt; (int)G1[i].size(); j++)
        {
            int x = G1[i][j].first;
            int y = G1[i][j].second;
            add1(x, y, 1);
        }
    }
    for (int i = x; i &lt;= y; i++)
    {
        int k = query1(b[i].x1, b[i].y1, b[i].x2, b[i].y2);
        if (k &gt;= b[i].k) q1[++sum1] = b[i];
        else q2[--sum2] = b[i];
    }
    for (int i = x; i &lt;= sum1; i++)
    {
        b[i] = q1[i];
    }
    for (int i = sum2; i &lt;= y; i++)
    {
        b[i] = q2[i];
    }
    solve(mid + 1, r, sum2, y);
    for (int i = l; i &lt;= mid; i++)
    {
        for (int j = 0; j &lt; (int)G1[i].size(); j++)
        {
            int x = G1[i][j].first;
            int y = G1[i][j].second;
            add1(x, y, -1);
        }
    }
    solve(l, mid, x, sum1);
}
inline void Solve()
{
    cin &gt;&gt; N &gt;&gt; M;
    for (int i = 1; i &lt;= N; i++)
    {
        for (int j = 1; j &lt;= N; j++)
        {
            cin &gt;&gt; a[i][j];
            c[++tot] = a[i][j];
        }
    }
    sort(c + 1, c + tot + 1);
    tot = unique(c + 1, c + tot + 1) - (c + 1);
    for (int i = 1; i &lt;= N; i++)
    {
        for (int j = 1; j &lt;= N; j++)
        {
            a[i][j] = ef(a[i][j]);
            G1[a[i][j]].push_back(make_pair(i, j));
        }
    }
    for (int i = 1; i &lt;= M; i++)
    {
        b[i].id = i;
        cin &gt;&gt; b[i].x1;
        cin &gt;&gt; b[i].y1;
        cin &gt;&gt; b[i].x2;
        cin &gt;&gt; b[i].y2;
        cin &gt;&gt; b[i].k;
    }
    solve(1, tot, 1, M);
    for (int i = 1; i &lt;= M; i++)
    {
        cout &lt;&lt; c[ans[i]] &lt;&lt; endl;
    }
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    T = 1;
    while (T--)
        Solve();
}
</code></pre>
<h2 id="cdq">cdq分治</h2>
<h3 id="_13">【模板】三维偏序（陌上花开）</h3>
<p>$ 1 \leq n \leq 10^5$，$1 \leq a_i, b_i, c_i \le k \leq 2 \times 10^5 $。
三维比较，先按 $a$ 排序, 在分治中按 $b$ 排序, 将 $c$ 放入树状数组求解。</p>
<pre><code class="language-cpp">// map&lt;pair&lt;int, int&gt;, int&gt; ans;
int ans[MaxN];
struct CDQ {
    int tree[MaxN];
    // 求 a_i &lt;= a_j, b_i &lt;= b_j, c_i &lt;= c_j 的数量
    // c范围要求为 1 到 MAXN
    int MAXN = 2e5, p;
    struct Point {
        int a, b, c;
        int cnt, ans; // 这个点的数量,答案
        int id;
        inline bool operator!=(const Point &amp;aa) const {
            if (a != aa.a) return 1;
            if (b != aa.b) return 1;
            if (c != aa.c) return 1;
            return 0;
        }
        inline bool operator&lt;(const Point &amp;aa) const {
            if (a != aa.a) return a &lt; aa.a;
            if (b != aa.b) return b &lt; aa.b;
            return c &lt; aa.c;
        }
    } a[MaxN], b[MaxN];
    void add1(int x, int v) {
        x++;
        for (; x &lt;= MAXN; x += lowbit(x)) {
            tree[x] += v;
        }
    }
    int query(int x) {
        x++;
        int ans = 0;
        for (; x; x -= lowbit(x)) {
            ans += tree[x];
        }
        return ans;
    }
    inline bool cmp1(Point &amp;x, Point &amp;y) {
        if (x.a != y.a) return x.a &lt; y.a;
        if (x.b != y.b) return x.b &lt; y.b;
        return x.c &lt; y.c;
    }
    void cdq(int l, int r) {
        if (l == r) return;
        int mid = (l + r) &gt;&gt; 1;
        cdq(l, mid);
        cdq(mid + 1, r);
        sort(b + l, b + mid + 1, [&amp;](Point x, Point y) {
            if (x.b != y.b) return x.b &lt; y.b;
            return x.c &lt; y.c;
        });
        sort(b + mid + 1, b + r + 1, [&amp;](Point x, Point y) {
            if (x.b != y.b) return x.b &lt; y.b;
            return x.c &lt; y.c;
        });
        int i = l;
        int j = mid + 1;
        while (j &lt;= r) {
            while (i &lt;= mid &amp;&amp; b[i].b &lt;= b[j].b) {
                add1(b[i].c, b[i].cnt);
                i++;
            }
            b[j].ans += query(b[j].c);
            j++;
        }
        for (int k = l; k &lt; i; k++) {
            add1(b[k].c, -b[k].cnt);
        }
    }
    void clear() {
        ans.clear();
        p = 0;
    }
    void insert(int x, int y, int z, int cnt, int ans, int id) {
        a[++p] = { x, y, z, cnt, ans, id };
    }
    void solve() {
        int l = 1, r = p;
        sort(a + l, a + 1 + r);
        int tot = 0, sum = 0;
        for (int i = l; i &lt;= r; i++) {
            sum += a[i].cnt;
            if (i == r || a[i] != a[i + 1]) {
                b[++tot] = a[i];
                b[tot].cnt = sum;
                sum = 0;
            }
        }
        cdq(1, tot);
        for (int i = 1; i &lt;= tot; i++) {
            // if (b[i].c == 1) ans[make_pair(b[i].a, b[i].b)] = b[i].ans;

            ans[b[i].ans + b[i].cnt - 1] += b[i].cnt;
        }
    }
} TT;
</code></pre>
<h2 id="kd-tree">KD-Tree</h2>
<pre><code class="language-cpp">struct KDT {
    struct Point {
        int x[2];
        int v, sum;
        int l, r;
        int L[2], R[2];
        int d;
    } t[MaxN], l, h;
    int rt[LogN];
    int b[MaxN], cnt, tot;
    void clear() {
        for (int i = 0; i &lt; LogN; i++) {
            rt[i] = 0;
        }
        tot = 0;
    }
    void upd(int p) {
        t[p].sum = t[t[p].l].sum + t[t[p].r].sum + t[p].v;
        for (int k : {0, 1}) {
            t[p].L[k] = t[p].R[k] = t[p].x[k];
            if (t[p].l) {
                t[p].L[k] = min(t[p].L[k], t[t[p].l].L[k]);
                t[p].R[k] = max(t[p].R[k], t[t[p].l].R[k]);
            }
            if (t[p].r) {
                t[p].L[k] = min(t[p].L[k], t[t[p].r].L[k]);
                t[p].R[k] = max(t[p].R[k], t[t[p].r].R[k]);
            }
        }
    }
    inline bool cmp1(int x, int y) { return t[x].x[0] &lt; t[y].x[0]; }
    inline bool cmp2(int x, int y) { return t[x].x[1] &lt; t[y].x[1]; }
    int build(int l, int r) {
        int mid = (l + r) &gt;&gt; 1;
        ld ave1 = 0, ave2 = 0, fc1 = 0, fc2 = 0;
        for (int i = l; i &lt;= r; i++) {
            ave1 += t[b[i]].x[0];
            ave2 += t[b[i]].x[1];
        }
        ave1 /= (r - l + 1);
        ave2 /= (r - l + 1);
        for (int i = l; i &lt;= r; i++) {
            fc1 += (t[b[i]].x[0] - ave1) * (t[b[i]].x[1] - ave1);
            fc2 += (t[b[i]].x[1] - ave2) * (t[b[i]].x[1] - ave2);
        }
        if (fc1 &gt; fc2) {
            nth_element(b + l, b + mid, b + r + 1, [this](int x, int y) { return t[x].x[0] &lt; t[y].x[0]; });
            t[b[mid]].d = 1;
        } else {
            nth_element(b + l, b + mid, b + r + 1, [this](int x, int y) { return t[x].x[1] &lt; t[y].x[1]; });
            t[b[mid]].d = 2;
        }

        int x{b[mid]};
        if (l &lt; mid) t[x].l = build(l, mid - 1);
        if (mid &lt; r) t[x].r = build(mid + 1, r);
        upd(x);
        return x;
    }
    void append(int &amp;p) {
        if (!p) return;
        b[++cnt] = p;
        append(t[p].l);
        append(t[p].r);
        p = 0;
    }
    int query(int p) {
        if (!p || t[p].L[0] &gt; h.x[0] || t[p].R[0] &lt; l.x[0] || t[p].L[1] &gt; h.x[1] || t[p].R[1] &lt; l.x[1]) return 0;
        if (t[p].L[0] &gt;= l.x[0] &amp;&amp; t[p].R[0] &lt;= l.x[0] &amp;&amp; t[p].R[1] &lt;= h.x[1] &amp;&amp; t[p].L[1] &gt;= l.x[1]) return t[p].sum;
        int res = 0;
        if (t[p].x[0] &gt;= l.x[0] &amp;&amp; t[p].x[0] &lt;= h.x[0] &amp;&amp; t[p].x[1] &gt;= l.x[1] &amp;&amp; t[p].x[1] &lt;= h.x[1]) {
            res += t[p].v;
        }
        return query(t[p].l) + query(t[p].r) + res;
    }
    void insert(int x, int y, int z) {
        t[++tot] = {x, y, z};
        b[cnt = 1] = tot;
        for (int i = 0; ; i++) {
            if (!rt[i]) {
                rt[i] = build(1, cnt);
                break;
            } else {
                append(rt[i]);
            }
        }
    }
    int query(int x1, int y1, int x2, int y2) {
        l = {x1, y1};
        h = {x2, y2};
        int ans = 0;
        for (int i = 0; i &lt; LogN; i++) {
            ans += query(rt[i]);
        }
        return ans;
    }
} TT;
</code></pre>
<p>## 并查集</p>
<pre><code class="language-cpp">struct DSU{
    vector&lt;int&gt; fn;
    DSU(int n){
        for(int i=0;i&lt;=n;i++){
            fn.push_back(i);
        }
    }
    int find(int x){
        if(fn[x]==x){
            return x;
        }
        return fn[x]=find(fn[x]);
    }
    void join(int x,int y){
        int fx=find(x),fy=find(y);
        if(fx!=fy){
            fn[fx]=fy;
        }
    }
};
</code></pre>
<h2 id="_14">带权并查集</h2>
<p>一行，一个整数，表示假话的总数。</p>
<h3 id="_15">题解</h3>
<p>$g[x]$表示$x$到根节点的权值和</p>
<pre><code class="language-cpp">struct DSU {
    vector&lt;int&gt; fa, siz, sum, g;
    vector&lt;pair&lt;int, int&gt;&gt; tmp;
    DSU(int n) {
        fa.assign(n + 1, 0);
        siz.assign(n + 1, 1);
        sum.assign(n + 1, 0);
        g.assign(n + 1, 0);
        for (int i = 1; i &lt;= n; i++) {
            fa[i] = i;
            sum[i] = i;
        }
    }
    // int find(int x) {
    //  if (fa[x] == x) return x;
    //  auto f = find(fa[x]);
    //  g[x] += g[fa[x]];
    //  return fa[x] = f;
    // }
    int find(int x) {
        if (fa[x] == x) return x;
        return find(fa[x]);
    }
    void hebin(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            tmp.emplace_back(-1, -1);
            return;
        }
        if (siz[x] &lt; siz[y]) swap(x, y);
        tmp.emplace_back(x, y);
        fa[y] = x;
        siz[x] += siz[y];
        sum[x] += sum[y];
    }
    void undone() { //撤销
        auto [x, y] = tmp.back();
        tmp.pop_back();
        if (x == -1) return;
        fa[y] = y;
        siz[x] -= siz[y];
        sum[x] -= sum[y];
    }
    void move(int x, int y) { // x -&gt; y
        auto fx = find(x), fy = find(y);
        if (fx == fy) return;
        fa[x] = fy;
        --siz[fx], ++siz[fy];
        sum[fx] -= x, sum[fy] += x;
    }
};
</code></pre>
<h2 id="_16">离散化</h2>
<pre><code class="language-cpp">template&lt;typename T&gt; 
struct Map{
    vector&lt;T&gt; nums;

    Map() {}

    void add(T x){
        nums.push_back(x);
    }

    void build(){
        sort(nums.begin(), nums.end());
        nums.erase(unique(nums.begin(), nums.end()), nums.end());
    }

    int get(T x){
        return int(lower_bound(nums.begin(), nums.end(), x) - nums.begin()) + 1;
    }

    T val(int x){
        return nums[x - 1];
    }

    int size(){
        return (int)nums.size();
    }
};
</code></pre>
<h2 id="_17">手打队列</h2>
<pre><code class="language-cpp">    struct node
    {
        int l,r,v;
    }p[MaxN&lt;&lt;1];
    inline int newnode(int l,int r,int v)
    {
        p[++tot]=node{l,r,v};
        return tot;
    }
    struct que
    {
        int star,end,len;
        inline void push_back(int x)
        {
            if(!len) star=end=newnode(0,0,x);
            else p[end].r=newnode(end,0,x),end=p[end].r;
            len++;
        }
        inline int size()
        {
            return len;
        }
        inline int front()
        {
            return p[star].v;
        }
        inline int back()
        {
            return p[end].v;
        }
        inline void pop_front()
        {
            star=p[star].r;len--;
        }
        inline void pop_back()
        {
            end=p[end].l;
            len--;
        }
        inline void push(int x)
        {
            while(!size()&amp;&amp;a[back()]&gt;a[x]) pop_back();
            push_back(x);
        }
    }dui[MaxN&lt;&lt;1],dui1[MaxN&lt;&lt;1],*q=dui+MaxN,*q1=dui1+MaxN;
</code></pre>
<h2 id="_18">点分治</h2>
<h3 id="1_6">【模板】点分治1</h3>
<h4 id="_19">题目描述</h4>
<p>给定一棵有 $n$ 个点的树，询问树上距离为 $k$ 的点对是否存在。</p>
<h4 id="_20">输入格式</h4>
<p>第一行两个数 $n,m$。</p>
<p>第 $2$ 到第 $n$ 行，每行三个整数 $u, v, w$，代表树上存在一条连接 $u$ 和 $v$ 边权为 $w$ 的路径。</p>
<p>接下来 $m$ 行，每行一个整数 $k$，代表一次询问。</p>
<h4 id="_21">输出格式</h4>
<p>对于每次询问输出一行一个字符串代表答案，存在输出 <code>AYE</code>，否则输出 <code>NAY</code>。</p>
<h5 id="_22">数据规模与约定。</h5>
<ul>
<li>对于 $100\%$ 的数据，保证 $1 \leq n\leq 10^4$，$1 \leq m\leq 100$，$1 \leq k \leq 10^7$，$1 \leq u, v \leq n$，$1 \leq w \leq 10^4$。</li>
</ul>
<pre><code class="language-cpp">struct dfz {
    int siz[MaxN], maxp[MaxN], vis[MaxN], dis[MaxN];
    bool judge[100000001];
    int a[MaxN], ans[MaxN];
    int tot, rt;
    inline void getzx(int x, int f) {
        siz[x] = 1;
        maxp[x] = 0;
        for (auto &amp;[y, z] : G1[x]) {
            if (y == f || vis[y]) continue;
            getzx(y, x);
            siz[x] += siz[y];
            maxp[x] = max(maxp[x], siz[y]);
        }
        maxp[x] = max(maxp[x], tot - siz[x]);
        if (maxp[x] &lt; maxp[rt]) rt = x;
    }
    void getdis(int x, int f, queue&lt;int&gt; &amp;q) {
        q.push(dis[x]);
        for (auto &amp;[y, z] : G1[x]) {
            if (vis[y] || y == f) continue;
            dis[y] = dis[x] + z;
            getdis(y, x, q);
        }
    }
    inline void clac(int x) {
        queue&lt;int&gt; q1;
        for (auto &amp;[y, z]: G1[x]) {
            if (vis[y]) continue;
            queue&lt;int&gt; q;
            dis[y] = z;
            getdis(y, x, q);
            queue&lt;int&gt; q2 = q;
            while (!q.empty()) {
                auto now = q.front(); q.pop();
                for (int j = 1; j &lt;= M; j++)
                    if (a[j] &gt;= now) {
                        ans[j] |= judge[a[j] - now];
                    }

            }
            while (!q2.empty()) {
                auto now = q2.front(); q2.pop();
                judge[now] = 1;
                q1.push(now);
            }

        }
        while (!q1.empty()) {
            int x = q1.front();
            q1.pop();
            judge[x] = 0;
        }
    }
    void solve(int x) {
        vis[x] = 1;
        judge[0] = 1;
        clac(x);
        judge[0] = 0;
        for (auto &amp;[y, z]: G1[x]) {
            if (vis[y]) continue;
            tot = siz[y];
            maxp[rt = 0] = INF;
            getzx(y, 0);
            solve(rt);
        }
    }
    void Solve() {
        tot = N;
        maxp[rt = 0] = INF;
        getzx(1, 0);
        solve(rt);
    }
} TT;
</code></pre>
<h2 id="_23">树上启发式合并</h2>
<pre><code class="language-cpp">struct Point {
    int maxn = 0;
    int sum = 0;
    map&lt;int, int&gt; mp;
    vector&lt;int&gt; li;
    void add1(int x) {
        mp[a[x]]++;
        if (mp[a[x]] &gt; maxn) {
            maxn = mp[a[x]];
            sum = a[x];
        } else if (mp[a[x]] == maxn) {
            sum += a[x];
        }
        li.push_back(x);
    }
    int size() {
        return li.size();
    }
} sub[MaxN];
void dfs1(int x, int f) {
    int son = 0, maxn = 0;
    for (auto&amp; y : G1[x]) {
        if (y == f) continue;
        dfs1(y, x);
        if (sub[fa[y]].size() &gt; maxn) {
            maxn = sub[fa[y]].size();
            son = y;
        }
    }
    if (son) fa[x] = fa[son];
    for (auto&amp; y : G1[x]) {
        if (y == son) continue;
        if (y == f) continue;
        for (auto&amp; z : sub[fa[y]].li) {
            sub[fa[x]].add1(z);
        }
    }
    sub[fa[x]].add1(x);
    ans[x] = sub[fa[x]].sum;
}
</code></pre>
<h1 id="_24">数据结构</h1>
<h2 id="st">ST 表</h2>
<pre><code class="language-cpp">struct ST {
    int LogN, N;
    vector&lt;vector&lt;int&gt;&gt; F1, F2;
    vector&lt;int&gt; logn;
    ST() {
        init(0);
    }
    ST(int n) {
        init(n);
    }
    inline void init(int n) {
        N = n;
        logn.assign(N + 1, 0);
        logn[0] = -1;
        for (int i = 1; i &lt;= N; i++) {
            logn[i] = logn[i &gt;&gt; 1] + 1;
        }
        LogN = logn[N] + 1;
        F1.assign(N + 1, vector&lt;int&gt;(LogN + 1));
        F2.assign(N + 1, vector&lt;int&gt;(LogN + 1));
    }
    inline void pre() {
        for (int j = 1; j &lt;= LogN; j++) {
            for (int i = 1; i + (1 &lt;&lt; (j - 1)) &lt;= N; i++) {
                F1[i][j] = max(F1[i][j - 1], F1[i + (1 &lt;&lt; (j - 1))][j - 1]);
            }
        }
        for (int j = 1; j &lt;= LogN; j++) {
            for (int i = 1; i + (1 &lt;&lt; (j - 1)) &lt;= N; i++) {
                F2[i][j] = min(F2[i][j - 1], F2[i + (1 &lt;&lt; (j - 1))][j - 1]);
            }
        }
    }
    inline int querymax(int l, int r) {
        int s = logn[r - l + 1];
        return max(F1[l][s], F1[r - (1 &lt;&lt; s) + 1][s]);
    }
    inline int querymin(int l, int r) {
        int s = logn[r - l + 1];
        return min(F2[l][s], F2[r - (1 &lt;&lt; s) + 1][s]);
    }
};
</code></pre>
<h2 id="fhq-treap">FHQ-treap</h2>
<h3 id="hash">平衡树维护Hash</h3>
<pre><code class="language-cpp">struct FHQ_TREAP {
    struct Point {
        int l, r, p, s;
        Hash v, sum;
    } tree[MaxN];
    int tot = 0;
    inline void pushdown(int p) {

    }
    inline void pushup(int p) {
        tree[p].s = tree[tree[p].l].s + tree[tree[p].r].s + 1;
        tree[p].sum = tree[tree[p].l].sum * power[tree[tree[p].r].s + 1] +
                        tree[tree[p].r].sum + tree[p].v * power[tree[tree[p].r].s];
        tree[p].sum = tree[p].sum % P;
    }
    inline Point pushup(Point now, Point l, Point r) {
        now.s = l.s + r.s + 1;
        now.sum = (l.sum * power[r.s + 1] % P + r.sum + now.v * power[r.s] % P) % P;
        return now;
    }
    inline int newnode(Hash v) {
        int x = ++tot;
        tree[x].v = tree[x].sum = v;
        tree[x].l = tree[x].r = 0;
        tree[x].p = rand() * rand();
        tree[x].s = 1;
        return x;
    }
    int hebin(int x, int y) {
        if (!x || !y) return x + y;
        if (tree[x].p &lt; tree[y].p) {
            pushdown(x);
            tree[x].r = hebin(tree[x].r, y);
            pushup(x);
            // tree[x] = pushup(tree[x], tree[tree[x].l], tree[tree[x].r]);
            return x;
        } else {
            pushdown(y);
            tree[y].l = hebin(x, tree[y].l);
            pushup(y);
            // tree[y] = pushup(tree[y], tree[tree[y].l], tree[tree[y].r]);
            return y;
        }
    }
    void split(int x, int k, int &amp;l, int &amp;r) {
        if (!x) {
            l = r = 0;
            return;
        }
        pushdown(x);
        if (tree[tree[x].l].s + 1 &lt;= k) {
            l = x;
            split(tree[x].r, k - (tree[tree[x].l].s + 1), tree[x].r, r);
        } else {
            r = x;
            split(tree[x].l, k, l, tree[x].l);
        }
        pushup(x);
        // tree[x] = pushup(tree[x], tree[tree[x].l], tree[tree[x].r]);
    }

    string a;
    int Build(int l, int r) {
        if (l == r) return newnode(a[l]);
        int mid = (l + r) &gt;&gt; 1;
        return hebin(Build(l, mid), Build(mid + 1, r));
    }
    Hash query(int l, int r) {
        int t1 = 0, t2 = 0, t3 = 0;
        split(rt, l - 1, t1, t2);
        split(t2, r - l + 1, t2, t3);
        Hash ans = tree[t2].sum;
        // dfs1(t2);
        // cerr &lt;&lt; endl;
        rt = hebin(hebin(t1, t2), t3);
        return ans;
    }
    void change(int k, Hash v) {
        int t1 = 0, t2 = 0, t3 = 0;
        split(rt, k - 1, t1, t2);
        split(t2, 1, t2, t3);
        tree[t2].v = tree[t2].sum = v;
        rt = hebin(hebin(t1, t2), t3);
    }
    void add1(int k, Hash v) {
        int t1 = 0, t2 = 0, t3 = 0;
        split(rt, k, t1, t3);
        t2 = newnode(v);
        rt = hebin(hebin(t1, t2), t3);
    }
    void dfs1(int x) {
        if (!x) return;
        dfs1(tree[x].l);
        cerr &lt;&lt; x &lt;&lt; ' ';
        dfs1(tree[x].r);
    }
} TT;
</code></pre>
<h3 id="_25">普通平衡树</h3>
<pre><code class="language-cpp">struct FHQ_TREAP {
    struct Point {
        int l, r, p, s;
        int v, sum;
    } tree[MaxN];
    int tot = 0;
    inline void pushdown(int p) {

    }
    inline void pushup(int p) {
        tree[p].s = tree[tree[p].l].s + tree[tree[p].r].s + 1;

    }
    inline Point pushup(Point now, Point l, Point r) {
        now.s = l.s + r.s + 1;
        return now;
    }
    inline int newnode(int v) {
        int x = ++tot;
        tree[x].v = tree[x].sum = v;
        tree[x].l = tree[x].r = 0;
        tree[x].p = rand() * rand();
        tree[x].s = 1;
        return x;
    }
    int hebin(int x, int y) {
        if (!x || !y) return x + y;
        if (tree[x].p &lt; tree[y].p) {
            pushdown(x);
            tree[x].r = hebin(tree[x].r, y);
            pushup(x);
            // tree[x] = pushup(tree[x], tree[tree[x].l], tree[tree[x].r]);
            return x;
        } else {
            pushdown(y);
            tree[y].l = hebin(x, tree[y].l);
            pushup(y);
            // tree[y] = pushup(tree[y], tree[tree[y].l], tree[tree[y].r]);
            return y;
        }
    }
    void split_v(int x, int k, int &amp;l, int &amp;r) {
        if (!x) {
            l = r = 0;
            return;
        }
        pushdown(x);
        if (tree[x].v &lt;= k) {
            l = x;
            split_v(tree[x].r, k, tree[x].r, r);
        } else {
            r = x;
            split_v(tree[x].l, k, l, tree[x].l);
        }
        pushup(x);
    }
    void split(int x, int k, int &amp;l, int &amp;r) {
        if (!x) {
            l = r = 0;
            return;
        }
        pushdown(x);
        if (tree[tree[x].l].s + 1 &lt;= k) {
            l = x;
            split(tree[x].r, k - (tree[tree[x].l].s + 1), tree[x].r, r);
        } else {
            r = x;
            split(tree[x].l, k, l, tree[x].l);
        }
        pushup(x);
        // tree[x] = pushup(tree[x], tree[tree[x].l], tree[tree[x].r]);
    }

    int Build(int l, int r) {
        if (l == r) return newnode(a[l]);
        int mid = (l + r) &gt;&gt; 1;
        return hebin(Build(l, mid), Build(mid + 1, r));
    }
    int query(int l, int r) {
        int t1 = 0, t2 = 0, t3 = 0;
        split(rt, l - 1, t1, t2);
        split(t2, r - l + 1, t2, t3);
        int ans = tree[t2].sum;
        // dfs1(t2);
        // cerr &lt;&lt; endl;
        rt = hebin(hebin(t1, t2), t3);
        return ans;
    }
    void change(int k, int v) {
        int t1 = 0, t2 = 0, t3 = 0;
        split(rt, k - 1, t1, t2);
        split(t2, 1, t2, t3);
        tree[t2].v = tree[t2].sum = v;
        rt = hebin(hebin(t1, t2), t3);
    }
    void add1(int v) { //插入一个数 $x$
        int t1 = 0, t2 = 0, t3 = 0;
        split_v(rt, v, t1, t3);
        t2 = newnode(v);
        rt = hebin(hebin(t1, t2), t3);
    }
    void delet(int v) { //删除一个数 $x$（若有多个相同的数，应只删除一个）
        int t1 = 0, t2 = 0, t3 = 0;
        split_v(rt, v - 1, t1, t2);
        split_v(t2, v, t2, t3);
        t2 = hebin(tree[t2].l, tree[t2].r);
        rt = hebin(hebin(t1, t2), t3);
    }
    int rank(int v) { //定义排名为比当前数小的数的个数 +1。查询x的排名。
        int t1 = 0, t2 = 0, t3 = 0;
        split_v(rt, v - 1, t1, t3);
        int ans = tree[t1].s + 1;
        rt = hebin(hebin(t1, t2), t3);
        return ans;
    }
    int find_min(int  x) {
        while (tree[x].l) {
            x = tree[x].l;
        }
        return tree[x].v;
    }
    int find_max(int x) {
        while (tree[x].r) {
            x = tree[x].r;
        }
        return tree[x].v;
    }
    int ith(int k) { //查询数据结构中排名为x的数
        int t1 = 0, t2 = 0, t3 = 0;
        split(rt, k, t1, t3);
        int ans = find_max(t1);
        rt = hebin(hebin(t1, t2), t3);
        return ans;
    }
    int get_pre(int v) { //求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）。
        int t1 = 0, t2 = 0, t3 = 0;
        split_v(rt, v - 1, t1, t3);
        int ans = find_max(t1);
        rt = hebin(hebin(t1, t2), t3);
        return ans;
    }
    int get_next(int v) { //求 $x$ 的后继（后继定义为大于 $x$，且最小的数）
        int t1 = 0, t2 = 0, t3 = 0;
        split_v(rt, v, t1, t3);
        int ans = find_min(t3);
        rt = hebin(hebin(t1, t2), t3);
        return ans;
    }
    void dfs1(int x) {
        if (!x) return;
        dfs1(tree[x].l);
        cerr &lt;&lt; tree[x].v &lt;&lt; ' ';
        dfs1(tree[x].r);
    }
} TT;
</code></pre>
<h4 id="_26">添点</h4>
<pre><code class="language-cpp">inline void add1(int x, int v) {
    tree[x].v = v;
    tree[x].l = tree[x].r = 0;
    tree[x].p = rand();
    tree[x].s = 1;
}
</code></pre>
<h4 id="_27">合并</h4>
<pre><code class="language-cpp">int hebin(int x, int y) {
    if (!x || !y) return x + y;
    if (tree[x].p &lt; tree[y].p) {
        pushdown(x);
        tree[x].r = hebin(tree[x].r, y);
        pushup(x);
        return x;
    } else {
        pushdown(y);
        tree[y].l = hebin(x, tree[y].l);
        pushup(y);
        return y;
    }
}
void split(int x, int k, int &amp;l, int &amp;r) {
    if (!x) {
        l = r = 0;
        return;
    }
    pushdown(x);
    if (tree[x].v &lt;= k) {
        l = x;
        split(tree[x].r, k, tree[x].r, r);
    } else {
        r = x;
        split(tree[x].l, k, l, tree[x].l);
    }
    pushup(x);
}
</code></pre>
<h4 id="_28">分裂</h4>
<h5 id="_29">普通</h5>
<pre><code class="language-cpp">void split(int x, int key, int &amp;l, int &amp;r) {
    if (!x) {
        l = r = 0;
        return;
    }
    pushdown(x);
    if (tree[tree[x].l].s + 1 &lt;= key) {
        l = x;
        split(tree[x].r, key - (tree[tree[x].l].s + 1), tree[x].r, r);
    } else {
        r = x;
        split(tree[x].l, key, l, tree[x].l);
    }
    updata(x);
}
</code></pre>
<h5 id="_30">区间分裂</h5>
<pre><code class="language-cpp">void split_new(int x,int k)
{
    if(k&gt;=tree[x].y-tree[x].x+1) return;
    int t=tree[x].x+k-1;
    int nn=newnode(t+1,tree[x].y);
    tree[x].y=t;
    tree[x].r=hebin(nn,tree[x].r);
    updata(x);
}
void split(int x,int k,int &amp;l,int &amp;r)
{
    if(!x)
    {
        l=r=0;
        return;
    }
    if(tree[tree[x].l].s&gt;=k)
    {
        r=x;
        split(tree[x].l,k,l,tree[x].l);
    }
    else
    {
        l=x;
        split_new(x,k-tree[tree[x].l].s);
        split(tree[x].r,k-(tree[tree[x].l].s
        +tree[x].y-tree[x].x+1),tree[x].r,r);
    }
    updata(x);
}
</code></pre>
<h3 id="mathcalo1">$\mathcal{O}(1)$建树</h3>
<pre><code class="language-cpp">inline int Build(int l,int r)
{
    if(l==r) return add1(a[l]);
    int mid=l+r;mid&gt;&gt;=1;
    return hebin(Build(l,mid),Build(mid+1,r));
}
</code></pre>
<h3 id="fhq-treap_1">FHQ-Treap给编号寻位置</h3>
<pre><code class="language-cpp">int ith(int x)
{
    int ans=tree[x].s-tree[tree[x].r].s;
    while(x!=rt)
    {
        if(tree[tree[x].fa].r==x) 
        ans+=tree[tree[x].fa].s-tree[x].s;
        x=tree[x].fa;
    }
    return ans;
}

int t=(--mp.lower_bound(x+1))-&gt;second;
</code></pre>
<h2 id="splay">【模板】文艺平衡树（Splay）</h2>
<h3 id="_31">题目描述</h3>
<p>您需要写一种数据结构（可参考题目标题），来维护一个有序数列。  </p>
<p>其中需要提供以下操作：翻转一个区间，例如原有序序列是 $5\ 4\ 3\ 2\ 1$，翻转区间是 $[2,4]$ 的话，结果是 $5\ 2\ 3\ 4\ 1$。</p>
<h4 id="_32">输入格式</h4>
<p>第一行两个正整数 $n,m$，表示序列长度与操作个数。序列中第 $i$ 项初始为 $i$。<br />
接下来 $m$ 行，每行两个正整数 $l,r$，表示翻转的区间。</p>
<h4 id="_33">输出格式</h4>
<p>输出一行 $n$ 个正整数，表示原始序列经过 $m$ 次变换后的结果。</p>
<h4 id="_34">思路</h4>
<p>Splay区间操作思想，如果修改区间$[l,r]$，则将$[l,r]$区间放到一颗子树上。<br />
将$(l-1)$移到根部，$(r+1)$移动到根部的右子树上，那么要修改的所有区间都在他的左子树上，放个懒标记修改就好。 
由于涉及到$l-1和r+1$所以将$0和N+1$加入到子树中<br />
<strong><em>$l=ith(l),r=ith(r+2)$</em></strong><br />
$l-1$的排名在第$l$位置   ,$r+1$的排名在第$r+2$位置   </p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long 
#define int ll
#define zuo p&lt;&lt;1
#define you p&lt;&lt;1|1
#define lowbit(x) ((x)&amp;(-x))
const int MaxN=1e6+100;
int N,M,rt,tot;
struct point
{
    int s,fa,ch[2],v,lan;
}tree[MaxN];
inline void push_up(int x)
{
    tree[x].s=tree[tree[x].ch[0]].s+tree[tree[x].ch[1]].s+1;
    // tree[tree[x].ch[0]].fa=x;
    // tree[tree[x].ch[1]].fa=x;
}
inline void overturn(int x)
{
    swap(tree[x].ch[0],tree[x].ch[1]);
    tree[x].lan^=1;
}
inline void push_down(int x)
{
    if(tree[x].lan)
    {
        if(tree[x].ch[0])
        overturn(tree[x].ch[0]);
        if(tree[x].ch[1])
        overturn(tree[x].ch[1]);
        tree[x].lan=0;
    }
}
inline bool get(int x)
{
    return x==tree[tree[x].fa].ch[1];
}
inline void rotate(int x)
{
    int y=tree[x].fa,z=tree[y].fa,chk=get(x);
    tree[y].ch[chk]=tree[x].ch[chk^1];
    if(tree[x].ch[chk^1]) tree[tree[x].ch[chk^1]].fa=y;
    tree[x].ch[chk^1]=y;
    tree[y].fa=x;
    tree[x].fa=z;
    if(z) tree[z].ch[y==tree[z].ch[1]]=x;
    push_up(y);
    push_up(x);
}
inline void splay(int x,int k)
{
    for(int f=tree[x].fa;f=tree[x].fa,f!=k;rotate(x))
        if(tree[f].fa!=k) rotate(get(x)==get(f)?f:x);
    if(k==0)
    rt=x;
}
inline int add1(int v)
{
    int x=++tot;
    tree[x].s=1;
    tree[x].ch[0]=0;
    tree[x].ch[1]=0;
    tree[x].v=v;
    return x;
}
void ins(int v)
{
    if(!rt)
    {
        rt=add1(v);
        push_up(rt);
        return ;
    }
    int x=rt,f=0;
    while(1)
    {
        push_down(x);
        f=x;
        if(v&lt;=tree[x].v)
            x=tree[x].ch[0];
        else
            x=tree[x].ch[1];
        if(!x)
        {
            x=add1(v);
            tree[x].fa=f;
            tree[f].ch[v&gt;tree[f].v]=x;
            push_up(x);
            push_up(f);
            splay(x,0);
            break;
        }
    }
}
inline int ith(int k)
{
    int x=rt;
    while(x)
    {
        push_down(x);
        if(tree[tree[x].ch[0]].s+1==k)
            return x;
        else if(tree[tree[x].ch[0]].s+1&gt;k)
            x=tree[x].ch[0];
        else if(tree[tree[x].ch[0]].s+1&lt;k)
        {
            k-=(tree[tree[x].ch[0]].s+1);
            x=tree[x].ch[1];
        }
    }
    return 0;
}
inline void change(int x,int y)
{
    int l=ith(x),r=ith(y+2);
    splay(l,0);
    splay(r,l);
    int pos=tree[rt].ch[1];
    overturn(tree[pos].ch[0]);
}
inline void dfs1(int x)
{
    push_down(x);
    if(tree[x].ch[0]) dfs1(tree[x].ch[0]);
    if(tree[x].v&amp;&amp;tree[x].v!=N+1)
    qput(tree[x].v),putchar(' ');
    if(tree[x].ch[1]) dfs1(tree[x].ch[1]);
}
signed main()
{
    qread(N);qread(M);
    for(int i=0;i&lt;=N+1;i++) ins(i);
//  dfs1(rt);putchar('\n');
    for(int i=1;i&lt;=M;i++)
    {
        int x,y;qread(x);qread(y);
        change(x,y);
//      dfs1(rt);putchar('\n');
    }
    dfs1(rt);
}
</code></pre>
<h2 id="_35">树状数组</h2>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct Fenwick {
    int n;
    std::vector&lt;T&gt; a;

    Fenwick(int n_ = 0) {
        init(n_);
    }

    void init(int n_) {
        n = n_;
        a.assign(n + 1, T{});
    }

    void add(int x, const T &amp;v) {
        for (int i = x; i &lt;= n; i += i &amp; -i) {
            a[i] = a[i] + v;
        }
    }

    T sum(int x) {
        T ans{};
        for (int i = x; i; i -= i &amp; -i) {
            ans = ans + a[i];
        }
        return ans;
    }

    T sum(int l, int r) {
        return sum(r) - sum(l - 1);
    }

    int select(const T &amp;k) {
        int x = 0;
        T cur{};
        for (int i = 1 &lt;&lt; std::__lg(n); i; i /= 2) {
            if (x + i &lt;= n &amp;&amp; cur + a[x + i] &lt;= k) {
                x += i;
                cur = cur + a[x];
            }
        }
        return x;
    }
};
</code></pre>
<h2 id="_36">线段树</h2>
<pre><code class="language-cpp">struct Segment {
    struct Point {
        int sum, lsum, rsum, lans, rans, ans, segans;
        Point (): sum(0), lsum(INF), rsum(0), lans(-INF), rans(-INF), segans(-INF) {};
        void print() {
            cerr &lt;&lt; sum &lt;&lt; ' ';
            cerr &lt;&lt; lsum &lt;&lt; ' ';
            cerr &lt;&lt; rsum &lt;&lt; ' ';
            cerr &lt;&lt; lans &lt;&lt; ' ';
            cerr &lt;&lt; rans &lt;&lt; ' ';
            cerr &lt;&lt; ans &lt;&lt; ' ';
        }
    } tree[MaxN &lt;&lt; 2], ts;
    inline Point pushup(Point L, Point R) {
        Point now = Point();
        now.sum = L.sum + R.sum;
        now.lsum = min(L.lsum, L.sum + R.lsum);
        now.rsum = max(R.rsum, L.rsum + R.sum);

        now.lans = L.sum - R.lsum;
        now.lans = max(now.lans, L.lans);
        now.lans = max(now.lans, L.sum + R.lans);
        now.lans = max(now.lans, L.segans - R.lsum);

        now.rans = L.rsum - R.sum;
        now.rans = max(now.rans, R.rans);
        now.rans = max(now.rans, L.rsum + R.segans);
        now.rans = max(now.rans, L.rans - R.sum);

        now.segans = max({L.segans - R.sum, L.sum + R.segans, L.sum - R.sum});

        now.ans = L.rsum - R.lsum;
        now.ans = max(now.ans, L.rsum + R.lans);
        now.ans = max(now.ans, L.ans);
        now.ans = max(now.ans, R.ans);
        now.ans = max(now.ans, L.rans - R.lsum);
        return now;
    }
    void build(int p, int l, int r) {
        if (l == r) {
            tree[p].sum = a[l];
            tree[p].lsum = a[l];
            tree[p].rsum = a[l];
            tree[p].lans = -INF;
            tree[p].rans = -INF;
            tree[p].ans = -INF;
            tree[p].segans = -INF;
            return;
        }
        int mid = (l + r) &gt;&gt; 1;
        build(ls, l, mid);
        build(rs, mid + 1, r);
        tree[p] = pushup(tree[ls], tree[rs]);
    }
    void change(int p, int l, int r, int k, int v) {
        if (l == r) {
            tree[p].sum = v;
            tree[p].lsum = v;
            tree[p].rsum = v;
            tree[p].lans = -INF;
            tree[p].rans = -INF;
            tree[p].ans = -INF;
            tree[p].segans = -INF;
            return;
        }
        int mid = (l + r) &gt;&gt; 1;
        if (mid &gt;= k) change(ls, l, mid, k, v);
        else change(rs, mid + 1, r, k, v);
        tree[p] = pushup(tree[ls], tree[rs]);
    }
    Point query(int p, int l, int r, int x, int y) {
        if (l &gt;= x &amp;&amp; r &lt;= y) {
            return tree[p];
        }
        int mid = (l + r) &gt;&gt; 1;
        if (mid &gt;= x &amp;&amp; mid &lt; y) {
            return pushup(query(ls, l, mid, x, y), query(rs, mid + 1, r, x, y));
        }
        if (mid &gt;= x) return query(ls, l, mid, x, y);
        if (mid &lt; y) return query(rs, mid + 1, r, x, y);
        return Point();
    }
} TT;
</code></pre>
<pre><code class="language-cpp">struct LazySegment {
    struct Point {
        int sum, lan, minn, v;
    } tree[MaxN &lt;&lt; 2], ts;
    inline void js(int p, int l, int r, int v) {
        tree[p].sum += v * (r - l + 1);
        tree[p].minn += v;
        tree[p].lan += v;
    }
    inline void pushdown(int p, int l, int r) {
        int mid{(l + r) &gt;&gt; 1};
        js(ls, l, mid, tree[p].lan);
        js(rs, mid + 1, r, tree[p].lan);
        tree[p].lan = 0;
    }
    inline Point pushup(Point L, Point R) {
        Point now = {};
        now.sum = L.sum + R.sum;
        now.minn = min(L.minn, R.minn);
        return now;
    }
    void build(int p, int l, int r) {
        if (l == r) {
            tree[p] = {};
            return;
        }
        int mid = (l + r) &gt;&gt; 1;
        pushdown(p, l, r);
        build(ls, l, mid);
        build(rs, mid + 1, r);
        tree[p] = pushup(tree[ls], tree[rs]);
    }
    void change(int p, int l, int r, int x, int y, int v) {
        if (l &gt;= x &amp;&amp; r &lt;= y) {
            js(p, l, r, v);
            return;
        }
        int mid = (l + r) &gt;&gt; 1;
        pushdown(p, l, r);
        if (mid &gt;= x) change(ls, l, mid, x, y, v);
        if (mid &lt; y) change(rs, mid + 1, r, x, y, v);
        tree[p] = pushup(tree[ls], tree[rs]);
    }
    Point query(int p, int l, int r, int x, int y) {
        if (l &gt;= x &amp;&amp; r &lt;= y) {
            return tree[p];
        }
        int mid = (l + r) &gt;&gt; 1;
        pushdown(p, l, r);
        if (mid &gt;= x &amp;&amp; mid &lt; y) {
            return pushup(query(ls, l, mid, x, y), query(rs, mid + 1, r, x, y));
        }
        if (mid &gt;= x) return query(ls, l, mid, x, y);
        if (mid &lt; y) return query(rs, mid + 1, r, x, y);
        return Point();
    }
} TT;
</code></pre>
<h3 id="introl">Introl</h3>
<pre><code class="language-cpp">struct segment{
    struct Tree{
        int l, r;
        int tag, sum, mex;
    }t[MaxN&lt;&lt;2];
    #define ls p&lt;&lt;1
    #define rs p&lt;&lt;1|1
    int midd(int p){
        return (t[p].l + t[p].r) &gt;&gt; 1;
    }
    void push_up(int p){
        t[p].sum = t[ls].sum + t[rs].sum;
        t[p].mex = max(t[ls].mex,t[rs].mex);
    }
    void pls(int p, int k){
        t[p].tag += k;
        t[p].sum += (t[p].r - t[p].l + 1) * k;
        t[p].mex += k;
    }
    void push_down(int p){
        if(t[p].tag){
            pls(ls, t[p].tag);
            pls(rs, t[p].tag);
            t[p].tag = 0;
        }
    }
    void build(int p, int l, int r){
        t[p].l = l, t[p].r = r;
        if(l == r){
            t[p].sum = a[l];
            t[p].mex = a[l];
            return ;
        }
        build(ls, l, midd(p));
        build(rs, midd(p) + 1, r);
        push_up(p);
    }
    void dfs(int p,int l,int r){
        if(l==r){
            a[l]=t[p].mex;
        }
        int mid=midd(p);
        push_down(p);
        dfs(ls,l,mid);
        dfs(rs,mid+1,r);
        push_up(p);
    }
    void change(int p, int nl, int nr, int k){
        int l = t[p].l, r = t[p].r;
        if(nl &lt;= l &amp;&amp;r &lt;= nr){
            pls(p, k);
            return ;
        }
        int mid = midd(p);
        push_down(p);
        if(nl &lt;= mid){
            change(ls, nl, nr, k);
        }
        if(mid &lt; nr){
            change(rs, nl, nr, k);
        }
        push_up(p);
    }
    int query_sum(int p, int nl, int nr){
        int l = t[p].l, r = t[p].r;
        if(nl &lt;= l &amp;&amp; r &lt;= nr){
            return t[p].sum;
        }
        int mid = midd(p), ans = 0;
        push_down(p);
        if(nl &lt;= mid){
            ans += query_sum(ls, nl, nr);
        }
        if(mid &lt; nr){
            ans += query_sum(rs, nl, nr);
        }
        return ans;
    }
    int query_max(int p, int nl, int nr){
        int l = t[p].l, r = t[p].r;
        if(nl &lt;= l&amp;&amp; r &lt;= nr){
            return t[p].mex;
        }
        int mid = midd(p), maxn = -INF;
        push_down(p);
        if(nl &lt;= mid){
            maxn = max(maxn, query_max(ls, nl, nr));
        }
        if(mid &lt; nr){
            maxn=max(maxn, query_max(rs, nl, nr));
        }
        return maxn;
    }
};
</code></pre>
<pre><code class="language-cpp">struct segment{
    struct Tree{
        int l, r;
        int add, sum, mex, mul = 1;
    }t[MaxN&lt;&lt;2];
    #define ls p&lt;&lt;1
    #define rs p&lt;&lt;1|1
    int midd(int p){
        return (t[p].l + t[p].r) &gt;&gt; 1;
    }
    void push_up(int p){
        t[p].sum = (t[ls].sum + t[rs].sum)%mod;
        t[p].mex = max(t[ls].mex,t[rs].mex);
    }
    void push_down(int p){
        t[ls].sum = (t[ls].sum * t[p].mul + t[p].add * (t[ls].r - t[ls].l + 1)) % mod;
        t[rs].sum = (t[rs].sum * t[p].mul + t[p].add * (t[rs].r - t[rs].l + 1)) % mod;

        t[ls].mex = (t[ls].mex * t[p].mul + t[p].add) % mod;
        t[rs].mex = (t[rs].mex * t[p].mul + t[p].add) % mod;

        t[ls].mul = (t[ls].mul * t[p].mul) % mod;
        t[rs].mul = (t[rs].mul * t[p].mul) % mod;

        t[ls].add = (t[ls].add * t[p].mul + t[p].add) % mod;
        t[rs].add = (t[rs].add * t[p].mul + t[p].add) % mod;

        t[p].add=0;
        t[p].mul=1;
    }
    void build(int p, int l, int r){
        t[p].l = l, t[p].r = r;
        if(l == r){
            t[p].sum = a[l];
            t[p].mex = a[l];
            return ;
        }
        build(ls, l, midd(p));
        build(rs, midd(p) + 1, r);
        push_up(p);
    }
    void dfs(int p,int l,int r){
        if(l==r){
            a[l]=t[p].mex;
        }
        int mid=midd(p);
        push_down(p);
        dfs(ls,l,mid);
        dfs(rs,mid+1,r);
        push_up(p);
    }
    void changeMul(int p, int nl, int nr, int k){
        int l = t[p].l, r = t[p].r;
        if(nl &lt;= l &amp;&amp; r &lt;= nr){
            t[p].add = (t[p].add * k) % mod;
            t[p].mul = (t[p].mul * k) % mod;
            t[p].sum = (t[p].sum * k) % mod;
            t[p].mex = (t[p].sum * k) % mod;
            return ;
        }
        int mid = midd(p);
        push_down(p);
        if(nl &lt;= mid){
            changeMul(ls, nl, nr, k);
        }
        if(mid &lt; nr){
            changeMul(rs, nl, nr, k);
        }
        push_up(p);
    }
    void changeAdd(int p, int nl, int nr, int k){
        int l = t[p].l, r = t[p].r;
        if(nl &lt;= l &amp;&amp; r &lt;= nr){
            t[p].add = (t[p].add + k) % mod;
            t[p].sum = (t[p].sum + (t[p].r - t[p].l + 1) * k) % mod;
            t[p].mex = (t[p].mex + k) % mod;
            return ;
        }
        int mid = midd(p);
        push_down(p);
        if(nl &lt;= mid){
            changeAdd(ls, nl, nr, k);
        }
        if(mid &lt; nr){
            changeAdd(rs, nl, nr, k);
        }
        push_up(p);
    }
    int query_sum(int p, int nl, int nr){
        int l = t[p].l, r = t[p].r;
        if(nl &lt;= l &amp;&amp; r &lt;= nr){
            return t[p].sum;
        }
        int mid = midd(p), ans = 0;
        push_down(p);
        if(nl &lt;= mid){
            ans += query_sum(ls, nl, nr);
        }
        if(mid &lt; nr){
            ans += query_sum(rs, nl, nr);
        }
        return ans;
    }
    int query_max(int p, int nl, int nr){
        int l = t[p].l, r = t[p].r;
        if(nl &lt;= l&amp;&amp; r &lt;= nr){
            return t[p].mex;
        }
        int mid = midd(p), maxn = -INF;
        push_down(p);
        if(nl &lt;= mid){
            maxn = max(maxn, query_max(ls, nl, nr));
        }
        if(mid &lt; nr){
            maxn=max(maxn, query_max(rs, nl, nr));
        }
        return maxn;
    }
}Tree;
</code></pre>
<h2 id="_37">权值线段树</h2>
<pre><code class="language-cpp">struct Segment {
    struct Point {
        int l, r, sum;
    };
    int tot;
    vector&lt;Point&gt; tree;
    Segment() {
        init();
    }
    Segment(int _n) {
        init(_n);
    }
    void init() {
        tree.clear();
        tot = 0;
    }
    void init(int _n) {
        tree.clear();
        tot = 0;
        tree.assign(_n, {});
    }

    inline Point pushup(Point L, Point R) {
        Point now = Point();
        now.sum = L.sum + R.sum;
        return now;
    }

    inline void pushup(int p) {
        tree[p].sum = tree[tree[p].l].sum + tree[tree[p].r].sum;
    }

    int change(int p, int l, int r, int k, int v) {
        while (tree.size() &lt;= tot + 10) tree.push_back({});
        if (!p) {
            p = ++tot;
        }
        if (l == r) {
            tree[p].sum += v;
            return p;
        }
        int mid = (l + r) &gt;&gt; 1;
        if (mid &gt;= k) tree[p].l = change(tree[p].l, l, mid, k, v);
        else tree[p].r = change(tree[p].r, mid + 1, r, k, v);
        pushup(p);
        return p;
    }

    int query(int p, int l, int r, int k) {
        if (l == r) return l;
        int now = tree[tree[p].l].sum;
        int mid = (l + r) &gt;&gt; 1;
        if (now &gt;= k) return query(tree[p].l, l, mid, k);
        else return query(tree[p].r, mid + 1, r, k - now);
    }
} TT(MaxN);
</code></pre>
<h2 id="_38">树链剖分</h2>
<pre><code class="language-cpp">struct TT {
    int deep[MaxN], father[MaxN], siz[MaxN], son[MaxN];//deep-&gt;深度 father-&gt;父节点 siz-&gt;子树大小 son-&gt;重儿子
    int seg[MaxN], top[MaxN], rev[MaxN];
    inline void dfs1(int x, int f) {
        deep[x] = deep[f] + 1;
        father[x] = f;
        siz[x] = 1;
        for (auto y : G1[x]) {
            if (y == f) continue;
            dfs1(y, x);
            siz[x] += siz[y];
            if (siz[son[x]] &lt; siz[y])
                son[x] = y;
        }
    }
    inline void dfs2(int x, int f) {
        if (son[x]) {
            seg[son[x]] = ++seg[0];
            top[son[x]] = top[x];
            rev[seg[0]] = son[x];
            dfs2(son[x], x);
        }
        for (auto y : G1[x]) {
            if (y != son[x] &amp;&amp; y != f) {
                top[y] = y;
                seg[y] = ++seg[0];
                rev[seg[0]] = y;
                dfs2(y, x);
            }
        }
    }
    void pre() {
        dfs1(1, 0);
        seg[0] = seg[1] = rev[1] = top[1] = 1;
        dfs2(1, 0);
    }
    void print(int x){

    }
    struct Point {
        int sum, lan, maxn;
    } tree[MaxN &lt;&lt; 2];
    inline void pushup(int p) {
        tree[p].sum = tree[ls].sum + tree[rs].sum;
        tree[p].maxn = max(tree[ls].maxn, tree[rs].maxn);
    }
    void build(int p, int l, int r) {
        if (l == r) {
            tree[p].sum = tree[p].maxn = deep[rev[l]];
            return;
        }
        int mid = (l + r) &gt;&gt; 1;
        build(ls, l, mid);
        build(rs, mid + 1, r);
        pushup(p);
    }
    inline void js(int p, int l, int r, int z) {
        tree[p].sum += (r - l + 1) * z;
        tree[p].lan += z;
        tree[p].maxn += z;
    }
    inline void pushdown(int p, int l, int r) {
        int mid = (l + r) &gt;&gt; 1;
        js(ls, l, mid, tree[p].lan);
        js(rs, mid + 1, r, tree[p].lan);
        tree[p].lan = 0;
    }
    void change(int p, int l, int r, int x, int y, int z) {
        if (l &gt;= x &amp;&amp; r &lt;= y) {
            js(p, l, r, z);
            return;
        }
        pushdown(p, l, r);
        int mid = (l + r) &gt;&gt; 1;
        if (mid &gt;= x) change(ls, l, mid, x, y, z);
        if (mid &lt; y) change(rs, mid + 1, r, x, y, z);
        pushup(p);
    }
    int query(int p, int l, int r, int x, int y) {
        if (l &gt;= x &amp;&amp; r &lt;= y) {
            return tree[p].maxn;
        }
        pushdown(p, l, r);
        int mid = (l + r) &gt;&gt; 1;
        int maxn = 0;
        if (mid &gt;= x) maxn = max(maxn, query(ls, l, mid, x, y));
        if (mid &lt; y) maxn = max(maxn, query(rs, mid + 1, r, x, y));
        return maxn;
    }
    inline void change1(int x, int y, int z) { //x -&gt; y 链上值+z
        int fx = top[x], fy = top[y];
        while (fx != fy) {
            if (deep[fx] &lt; deep[fy]) swap(x, y), swap(fx, fy);
            change(1, 1, seg[0], seg[fx], seg[x], 1);
            x = father[fx];
            fx = top[x];
        }
        if (deep[x] &lt; deep[y]) swap(x, y);
        change(1, 1, seg[0], seg[y], seg[x], z);
    }
    inline void changeroot(int x, int z) {
        int l = seg[x];
        int r = seg[x] + siz[x] - 1;
        change(1, 1, seg[0], l, r, z);
    }
    inline int query1(int x) { // x为根的最大值
        int l = seg[x];
        int r = seg[x] + siz[x] - 1;
        int ans = query(1, 1, seg[0], l, r);
        return ans;
    }
    inline int lca(int x, int y) {
        int fx = top[x], fy = top[y];
        while (fx != fy) {
            if (deep[fx] &lt; deep[fy]) swap(x, y), swap(fx, fy);
            x = father[fx];
            fx = top[x];
        }
        return deep[x] &lt; deep[y] ? x : y;
    }
} TT;
</code></pre>
<h3 id="introl_1">Introl</h3>
<pre><code class="language-cpp">struct TT{
    int dep[MaxN],father[MaxN],siz[MaxN],son[MaxN];
    //dep表示深度，father表示父节点，siz表示子树大小，son表示重儿子
    int dfn[MaxN],top[MaxN],rnk[MaxN];
    //dfn表示DFS序，top表示重链的顶部节点，rnk表示DFS序表示的节点编号，rnk(dfn(x))=x

    void dfs1(int x,int fa){
        dep[x]=dep[fa]+1;
        father[x]=fa;
        siz[x]=1;
        for(auto y:G1[x]){
            if(y==fa)continue;
            dfs1(y,x);
            siz[x]+=siz[y];
            if(siz[son[x]]&lt;siz[y])
                son[x]=y;
        }
    }
    void dfs2(int x,int fa){
        if(son[x]){
            dfn[son[x]]=++dfn[0];
            top[son[x]]=top[x];
            rnk[dfn[0]]=son[x];
            dfs2(son[x],x);
        }
        for(auto y:G1[x]){
            if(y!=son[x]&amp;&amp;y!=fa){
                top[y]=y;
                dfn[y]=++dfn[0];
                rnk[dfn[0]]=y;
                dfs2(y,x);
            }
        }
    }
    void init(){
        dfs1(1,0);
        dfn[0]=dfn[1]=rnk[1]=top[1]=1;
        dfs2(1,0);
    }
    void init(int root){
        dfs1(root,0);
        dfn[0]=dfn[root]=1;
        top[root]=root;
        rnk[1]=root;
        dfs2(root,0);
    }


    void debug(int x){
        cerr&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;dfn[x]&lt;&lt;endl;
    }



    struct Point{
        int l,r;
        int tag;
        int sum,mex;
    }t[MaxN&lt;&lt;2];
    #define ls p&lt;&lt;1
    #define rs p&lt;&lt;1|1
    int midd(int p){
        return (t[p].l+t[p].r)&gt;&gt;1;
    }
    void push_up(int p){
        t[p].mex=max(t[ls].mex,t[rs].mex);
        t[p].sum+=t[rs].sum;
    }
    void build(int p,int l,int r){
        t[p].l=l,t[p].r=r;
        if(l==r){
            t[p].mex=t[p].sum=a[rnk[l]];
            return;
        }
        int mid=midd(p);
        build(ls,l,mid);
        build(rs,mid+1,r);
        push_up(p);
    }
    void pls(int p,int k){
        t[p].sum+=(t[p].r-t[p].l+1)*k);
        t[p].tag+=k;
        t[p].mex+=k;
    }
    void push_down(int p){
        if(t[p].tag){
            pls(ls,t[p].tag);
            pls(rs,t[p].tag);
            t[p].tag=0;
        }
    }
    void change(int p,int nl,int nr,int k){
        int l=t[p].l,r=t[p].r;
        if(nl&lt;=l&amp;&amp;r&lt;=nr){
            pls(p,k);
            return;
        }
        int mid=midd(p);
        push_down(p); 
        if(nl&lt;=mid){
            change(ls,nl,nr,k);
        }
        if(mid&lt;nr){
            change(rs,nl,nr,k);
        }
        push_up(p);
    }
    int query_max(int p,int nl,int nr){
        int l=t[p].l,r=t[p].r;
        if(nl&lt;=l&amp;&amp;r&lt;=nr){
            return t[p].mex;
        }
        int mid=midd(p),maxn=-INF;
        push_down(p);
        if(nl&lt;=mid){
            maxn=max(maxn,query_max(ls,nl,nr));
        }
        if(mid&lt;nr){
            maxn=max(maxn,query_max(rs,nl,nr));
        }
        return maxn;
    }
    int query_sum(int p,int nl,int nr){
        int l=t[p].l,r=t[p].r;
        if(nl&lt;=l&amp;&amp;r&lt;=nr){
            return t[p].sum;
        }
        int mid=midd(p),res=0;
        push_down(p);
        if(nl&lt;=mid){
            res+=query_sum(ls,nl,nr);
        }
        if(mid&lt;nr){
            res+=query_sum(rs,nl,nr);
        }
        return res;
    }


    void treechange(int x,int y,int z){//(x-&gt;y)+z
        int fx=top[x],fy=top[y];
        while(fx!=fy){
            if(dep[fx]&lt;dep[fy]){
                swap(x,y);
                swap(fx,fy);
            }
            change(1,dfn[fx],dfn[x],z);
            x=father[fx];
            fx=top[x];
            // cnt++;
            // cerr&lt;&lt;cnt&lt;&lt;endl;
        }
        if(dep[x]&gt;dep[y])swap(x,y);
        change(1,dfn[x],dfn[y],z);
    }
    int treesum(int x,int y){
        int fx=top[x],fy=top[y];
        int res=0;
        while(fx!=fy){
            if(dep[fx]&lt;dep[fy])swap(x,y),swap(fx,fy);
            res+=query_sum(1,dfn[fx],dfn[x]);
            x=father[fx];
            fx=top[x];
        }   
        if(dep[x]&gt;dep[y])swap(x,y);
        res+=query_sum(1,dfn[x],dfn[y]);
        return res;
    }

    void changeroot(int x,int z){
        int l=dfn[x];
        int r=dfn[x]+siz[x]-1;
        // cerr&lt;&lt;dfn[x]&lt;&lt;&quot; &quot;&lt;&lt;dfn[x]+siz[x]-1&lt;&lt;endl;
        // cerr&lt;&lt;query_sum(1,l,r)&lt;&lt;endl;

        change(1,l,r,z);
    }
    int queryroot(int x){
        int l=dfn[x];
        int r=dfn[x]+siz[x]-1;
        // debug(x);
        int ans=query_sum(1,l,r);
        // cerr&lt;&lt;&quot;debug&quot;&lt;&lt;rnk[dfn[x]]&lt;&lt;endl;
        // cerr&lt;&lt;&quot;ans:&quot;&lt;&lt;query_sum(1,3,3)&lt;&lt;endl;
        return ans;
    }


    int lca(int x,int y){
        int fx=top[x],fy=top[y];
        while(fx!=fy){
            if(dep[fx]&lt;dep[fy])swap(x,y),swap(fx,fy);
            x=father[fx];
            fx=top[x];
        }
        return dep[x]&lt;dep[y]?x:y;
    }

}Tree;
</code></pre>
<h2 id="1_7">【模板】可持久化线段树 1（可持久化数组）</h2>
<h3 id="_39">题目描述</h3>
<p>如题，你需要维护这样的一个长度为 $ N $ 的数组，支持如下几种操作</p>
<ol>
<li>
<p>在某个历史版本上修改某一个位置上的值</p>
</li>
<li>
<p>访问某个历史版本上的某一位置的值</p>
</li>
</ol>
<pre><code class="language-cpp">struct Segment {
    struct Point {
        int l, r, sum;
    };
    int tot;
    vector&lt;Point&gt; tree;
    Segment() {
        init();
    }
    Segment(int _n) {
        init(_n);
    }
    void init() {
        tree.clear();
        tot = 0;
    }
    void init(int _n) {
        tree.clear();
        tot = 0;
        tree.assign(_n, {});
    }

    int change(int p, int l, int r, int k, int v) {
        while (tree.size() &lt;= tot + 10) tree.push_back({});
        tree[++tot] = tree[p];
        p = tot;

        if (l == r) {
            tree[p].sum = v;
            return p;
        }

        int mid = (l + r) &gt;&gt; 1;
        if (mid &gt;= k) tree[p].l = change(tree[p].l, l, mid, k, v);
        else tree[p].r = change(tree[p].r, mid + 1, r, k, v);
        return p;
    }

    int query(int p, int l, int r, int k) {
        if (l == r) return tree[p].sum;
        int mid = (l + r) &gt;&gt; 1;
        if (mid &gt;= k) return query(tree[p].l, l, mid, k);
        else return query(tree[p].r, mid + 1, r, k);
    }
};
</code></pre>
<h2 id="2">【模板】可持久化线段树 2(主席树)</h2>
<pre><code class="language-cpp">struct Segment {
    struct Point {
        int l, r, sum;
    };
    int tot;
    vector&lt;Point&gt; tree;
    Segment() {
        init();
    }
    Segment(int _n) {
        init(_n);
    }
    void init() {
        tree.clear();
        tot = 0;
    }
    void init(int _n) {
        tree.clear();
        tot = 0;
        tree.assign(_n, {});
    }

    int change(int p, int l, int r, int k, int v) {
        while (tree.size() &lt;= tot + 10) tree.push_back({});
        tree[++tot] = tree[p];
        p = tot;

        tree[p].sum += v;
        if (l == r) return p;

        int mid = (l + r) &gt;&gt; 1;
        if (mid &gt;= k) tree[p].l = change(tree[p].l, l, mid, k, v);
        else tree[p].r = change(tree[p].r, mid + 1, r, k, v);
        return p;
    }

    int query(int p1, int p2, int l, int r, int k) { //第k小
        if (l == r) return l;
        int now = tree[tree[p2].l].sum - tree[tree[p1].l].sum;
        int mid = (l + r) &gt;&gt; 1;
        if (now &gt;= k) return query(tree[p1].l, tree[p2].l, l, mid, k);
        else return query(tree[p1].r, tree[p2].r, mid + 1, r, k - now);
    }
};
</code></pre>
<h2 id="_40">可持久化并查集</h2>
<pre><code class="language-cpp">int rt[MaxN];
struct PersistantUnionSet{
    struct Point {
        int l, r, f, dep;
    };
    int tot;
    Point tree[MaxM];
    PersistantUnionSet() {
        init();
    }
    PersistantUnionSet(int _n) {
        init(_n);
    }
    void init() {
        // tree.clear();
        tot = 0;
    }
    void init(int _n) {
        // tree.clear();
        tot = 0;
        // tree.assign(_n, {});
    }

    int change(int p, int l, int r, int k, int f, int siz) {
        // while (tree.size() &lt;= tot + 10) tree.push_back({});
        tree[++tot] = tree[p];
        p = tot;


        if (l == r) {
            tree[p].dep = siz;
            tree[p].f = f;
            return p;
        }

        int mid = (l + r) &gt;&gt; 1;
        if (mid &gt;= k) tree[p].l = change(tree[p].l, l, mid, k, f, siz);
        else tree[p].r = change(tree[p].r, mid + 1, r, k, f, siz);
        return p;
    }

    Point query(int p, int l, int r, int k) { //第k小
        if (l == r) return tree[p];
        int mid = (l + r) &gt;&gt; 1;
        if (mid &gt;= k) return query(tree[p].l, l, mid, k);
        else return query(tree[p].r, mid + 1, r, k);
    }

    pair&lt;int, int&gt; queryFa(int p, int pos) {
          auto [l, r, f, siz] = query(p, 1, N, pos);
          if (f == pos) return { f, siz };
          return queryFa(p, f);
    }
};
</code></pre>
<h2 id="odt">ODT</h2>
<pre><code class="language-cpp">struct ODT {
    struct Point {
        int l, r;
        mutable int v;
        Point (int l, int r, int v) : l(l), r(r), v(v) {}
        inline bool operator&lt;(const Point &amp;aa) const {
            return l &lt; aa.l;
        }
    };
    set&lt;Point&gt; odt;
    auto split(int x) { // [l, x) [x, r],指向后者 
        if (x &gt; N) return odt.end();
        auto it = --odt.upper_bound(Point(x, 0, 0));
        if (it-&gt;l == x) return it;
        auto [l, r, v] = *it;
        odt.erase(it);
        odt.insert(Point(l, x - 1, v));
        return odt.insert(Point(x, r, v)).first;
    }

    void assign(int l, int r, int v) {
        auto itr = split(r + 1), itl = split(l);
        odt.erase(itl, itr);
        odt.insert(Point(l, r, v));
    }

    void insert(int l, int r, int v) {
        odt.insert(Point(l, r, v));
    }

    void performance(int l, int r) {
        auto itr = split(r + 1), itl = split(l);
        for (; itl != itr; ++itl) {
            auto &amp;[l, r, v] = *itl;
            // Perform Operations here
        }
    }
};
</code></pre>
<h2 id="_41">【模板】左偏树（可并堆）</h2>
<h3 id="_42">题目描述</h3>
<p>如题，一开始有 $n$ 个小根堆，每个堆包含且仅包含一个数。接下来需要支持两种操作：</p>
<ol>
<li>
<p><code>1 x y</code>：将第 $x$ 个数和第 $y$ 个数所在的小根堆合并（若第 $x$ 或第 $y$ 个数已经被删除或第 $x$ 和第 $y$ 个数在用一个堆内，则无视此操作）。</p>
</li>
<li>
<p><code>2 x</code>：输出第 $x$ 个数所在的堆最小数，并将这个最小数删除（若有多个最小数，优先删除先输入的；若第 $x$ 个数已经被删除，则输出 $-1$ 并无视删除操作）。</p>
</li>
</ol>
<h4 id="_43">输入格式</h4>
<p>第一行包含两个正整数 $n, m$，分别表示一开始小根堆的个数和接下来操作的个数。</p>
<p>第二行包含 $n$ 个正整数，其中第 $i$ 个正整数表示第 $i$ 个小根堆初始时包含且仅包含的数。</p>
<p>接下来 $m$ 行每行 $2$ 个或 $3$ 个正整数，表示一条操作，格式如下：</p>
<p>操作 $1$：<code>1 x y</code></p>
<p>操作 $2$：<code>2 x</code></p>
<h4 id="_44">输出格式</h4>
<p>输出包含若干行整数，分别依次对应每一个操作 $2$ 所得的结果。</p>
<pre><code class="language-cpp">int rt[MaxN], boo[MaxN];
struct LeftTree {
    struct Point {
        int d, l, r;
        int v;
        int s, sum;
    } tree[MaxN];
    void clear() {
        for (int i = 1; i &lt;= N; i++) {
            rt[i] = i;
            tree[i].s = 1;
        }
        tree[0].d = -1;
    }
    int find1(int x) {
        if (x == rt[x]) return x;
        return rt[x] = find1(rt[x]);
    }
    inline void pushdown(int x) {}
    inline void pushup(int x) {
        tree[x].s = tree[tree[x].l].s + tree[tree[x].r].s + 1;
        tree[x].sum = tree[tree[x].l].sum + tree[tree[x].r].sum + tree[x].v;
    }
    int hebin(int x, int y) {
        if (!x || !y) return x + y;
        if (tree[x].v &lt; tree[y].v) swap(x, y);
        pushdown(x);
        tree[x].r = hebin(tree[x].r, y);
        if (tree[tree[x].l].d &lt; tree[tree[x].r].d) swap(tree[x].l, tree[x].r);
        tree[x].d = tree[tree[x].r].d + 1;
        pushup(x);
        return x;
    }
    int get(int x) {
        x = find1(x);
        return tree[x].v;
    }
    void delet(int x) {
        x = find1(x);
        boo[x] = 1;
        rt[tree[x].l] = rt[tree[x].r] = rt[x] = hebin(tree[x].l, tree[x].r);
        tree[x].l = tree[x].r = tree[x].d = 0;
        tree[x].s = tree[x].sum = 0;
    }
} TT;
</code></pre>
<h2 id="_45">【模板】可持久化平衡树</h2>
<h4 id="_46">题目背景</h4>
<p>本题为题目 <strong>普通平衡树</strong> 的可持久化加强版。</p>
<h4 id="_47">题目描述</h4>
<p>您需要写一种数据结构（可参考题目标题），来维护一个可重整数集合，其中需要提供以下操作（ <strong>对于各个以往的历史版本</strong> ）：</p>
<p>1、 插入 $x$</p>
<p>2、 删除 $x$（若有多个相同的数，应只删除一个，<strong>如果没有请忽略该操作</strong>）</p>
<p>3、 查询 $x$ 的排名（排名定义为比当前数小的数的个数 $+1$）</p>
<p>4、查询排名为 $x$ 的数</p>
<p>5、 求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数，<strong>如不存在输出</strong> $-2^{31}+1$ ）</p>
<p>6、求 $x$ 的后继（后继定义为大于 $x$，且最小的数，<strong>如不存在输出</strong> $2^{31}-1$ ）</p>
<p><strong>和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本。（操作3, 4, 5, 6即保持原版本无变化）</strong></p>
<p>每个版本的编号即为操作的序号（版本0即为初始状态，空树）</p>
<h4 id="_48">输入格式</h4>
<p>第一行包含一个正整数 $n$ ，表示操作的总数。</p>
<p>接下来 $n$ 行，每行包含三个整数，第 $i$ 行记为 $v_i, \text{opt}_i, x_i$。</p>
<p>$v_i$ 表示基于的过去版本号，$\text{opt}_i$ 表示操作的序号， $x_i$ 表示参与操作的数值</p>
<h4 id="_49">输出格式</h4>
<p>每行包含一个整数，依次为各个 $3,4,5,6$ 操作所对应的答案</p>
<p>对于 $100\%$ 的数据， $ 1 \leq n \leq 5 \times  10^5 $ , $|x_i| \leq {10}^9$，$0 \le v_i &lt; i$，$1\le \text{opt} \le 6$。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long 
#define INF 2147483647
const int MaxN=5e5+100;
const int MaxM=5e7+100;
int N,M;
int a[MaxN],rt[MaxN],tot,t1,t2,t3;
struct point
{
    int x,l,r,v,p,s;
}tree[MaxM];
template&lt;class T&gt;
inline void qread(T &amp;sum)
{
    sum=0;int boo=1;
    char x=getchar();
    while(x&lt;'0'||x&gt;'9'){if(x=='-')boo=-1;x=getchar();}
    while(x&gt;='0'&amp;&amp;x&lt;='9'){sum=(sum&lt;&lt;1)+(sum&lt;&lt;3)+x-'0';x=getchar();}
    sum*=boo;
}
template&lt;class T&gt;
void qput(T x)
{
    if(x&lt;0) {x=-x;putchar('-');}
    if(x&gt;9){qput(x/10);}
    putchar(x%10+48);
}
inline int newnode(int v)
{
    int x=++tot;
    tree[x].l=tree[x].r=0;
    tree[x].p=rand();
    tree[x].v=v;
    tree[x].s=1;
    return x;
}
inline void updata(int x)
{
    tree[x].s=tree[tree[x].l].s+tree[tree[x].r].s+1;
}
inline int hebin(int x,int y)
{
    if(!x||!y) return x+y;
    if(tree[x].p&lt;tree[y].p)
    {
        int p=newnode(0);
        tree[p]=tree[x];
        tree[p].r=hebin(tree[p].r,y);
        updata(p);
        return p;
    }
    else
    {
        int p=newnode(0);
        tree[p]=tree[y];
        tree[p].l=hebin(x,tree[p].l);
        updata(p);
        return p;
    }
}
void split(int x,int k,int &amp;l,int &amp;r)
{
    if(!x)
    {
        l=r=0;
        return;
    }
    int p=newnode(0);
    tree[p]=tree[x];
    if(tree[p].v&lt;=k)
    {
        l=p;
        split(tree[p].r,k,tree[p].r,r);
    }
    else
    {
        r=p;
        split(tree[p].l,k,l,tree[p].l);
    }
    updata(p);
}
int ith(int x,int k)
{
    while(x)
    {
        if(k&lt;=tree[tree[x].l].s)
        {
            x=tree[x].l;
        }
        else if(k==tree[tree[x].l].s+1)
        {
            return tree[x].v;
        }
        else
        {
            k-=(tree[tree[x].l].s+1);
            x=tree[x].r;
        }
    }
    return 0;
}
inline int query1(int x)
{
    int ans=-INF;
    while(x)
    {
        ans=max(ans,tree[x].v);
        x=tree[x].r;
    }
    return ans;
}
inline int query2(int x)
{
    int ans=INF;
    while(x)
    {
        ans=min(ans,tree[x].v);
        x=tree[x].l;
    }
    return ans;
}
signed main()
{
    qread(N);
    for(int i=1;i&lt;=N;i++)
    {
        int v,opt,x;
        qread(v);qread(opt);qread(x);
        if(opt==1)
        {
            split(rt[v],x-1,t1,t2);
            int p=newnode(x);
            rt[i]=hebin(hebin(t1,p),t2);
        }
        if(opt==2)
        {
            split(rt[v],x,t1,t3);
            split(t1,x-1,t1,t2);
            t2=hebin(tree[t2].l,tree[t2].r);
            rt[i]=hebin(hebin(t1,t2),t3);
        }
        if(opt==3)
        {
            rt[i]=rt[v];
            split(rt[v],x-1,t1,t3);
            int ans=tree[t1].s+1;
            qput(ans);putchar('\n');
        }
        if(opt==4)
        {
            rt[i]=rt[v];
            int ans=ith(rt[i],x);
            qput(ans);putchar('\n');
        }
        if(opt==5)
        {
            rt[i]=rt[v];
            split(rt[i],x-1,t1,t2);
            int ans=query1(t1);
            qput(ans);putchar('\n');
        }
        if(opt==6)
        {
            rt[i]=rt[v];
            split(rt[i],x,t1,t2);
            int ans=query2(t2);
            qput(ans);putchar('\n');
        }
    }
}
</code></pre>
<h2 id="_50">【模板】可持久化文艺平衡树</h2>
<h4 id="_51">题目描述</h4>
<p>您需要写一种数据结构，来维护一个序列，其中需要提供以下操作（<strong>对于各个以往的历史版本</strong>）：</p>
<ol>
<li>在第 $p$ 个数后插入数 $x$ 。</li>
<li>删除第 $p$ 个数。</li>
<li>翻转区间 $[l,r]$，例如原序列是 ${5,4,3,2,1}$，翻转区间 $[2,4]$ 后，结果是 ${5,2,3,4,1}$。</li>
<li>查询区间 $[l,r]$ 中所有数的和。</li>
</ol>
<p><strong>和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本（操作 $4$ 即保持原版本无变化），新版本即编号为此次操作的序号。</strong></p>
<p><strong>本题强制在线。</strong></p>
<h4 id="_52">输入格式</h4>
<p>第一行包含一个整数 $n$，表示操作的总数。</p>
<p>接下来 $n$ 行，每行前两个整数 $v_i, \mathrm{opt}_i$，$v_i$ 表示基于的过去版本号（$0 \le v_i &lt; i$），$\mathrm{opt}_i$ 表示操作的序号（$1 \le \mathrm{opt}_i \le 4$）。</p>
<p>若 $\mathrm{opt}_i=1$，则接下来两个整数 $p_i, x_i$，表示操作为在第 $p_i$ 个数后插入数 $x$ 。<br />
若 $\mathrm{opt}_i=2$，则接下来一个整数 $p_i$，表示操作为删除第 $p_i$ 个数。<br />
若 $\mathrm{opt}_i=3$，则接下来两个整数 $l_i, r_i$，表示操作为翻转区间 $[l_i, r_i]$。<br />
若 $\mathrm{opt}_i=4$，则接下来两个整数 $l_i, r_i$，表示操作为查询区间 $[l_i, r_i]$ 的和。</p>
<p><strong>强制在线规则：</strong><br />
<strong>令当前操作之前的最后一次 $4$ 操作的答案为 $lastans$（如果之前没有 $4$ 操作，则 $lastans=0$）。</strong><br />
<strong>则此次操作的 $p_i,x_i$ 或 $l_i,r_i$ 均按位异或上 $lastans$ 即可得到真实的 $p_i,x_i$ 或 $l_i,r_i$。</strong></p>
<h4 id="_53">输出格式</h4>
<p>对于每个序号为 $4$ 的查询操作，输出一行一个数表示区间的和。</p>
<h4 id="_54">提示</h4>
<p><strong>强制在线：以下针对 $p_i, x_i, l_i, r_i$ 的限制均是按位异或 $lastans$ 后的限制。</strong></p>
<p>对于 $100\%$ 的数据，$1 \le n \le 2 \times {10}^5$，$|x_i| &lt; {10}^6$。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long 
#define int ll
#define ls p&lt;&lt;1
#define rs p&lt;&lt;1|1
#define lowbit(x) ((x)&amp;(-x))
const int MaxN=2e7+100;
const int INF=1e9;
int N,M,T,tot,rt[MaxN],ans,t1,t2,t3;
struct point
{
    int s,l,r,sum,lan,p,v;
}tree[MaxN];
template&lt;class T&gt;
inline int newnode(int v)
{
    int x=++tot;
    tree[x].l=tree[x].r=0;
    tree[x].p=rand();
    tree[x].v=v;
    tree[x].sum=v;
    tree[x].s=1;
    return x;
}
inline void updata(int x)
{
    tree[x].s=tree[tree[x].l].s+tree[tree[x].r].s+1;
    tree[x].sum=tree[tree[x].l].sum+tree[tree[x].r].sum+tree[x].v;
}
inline void overturn(int x)
{
    swap(tree[x].l,tree[x].r);
    tree[x].lan^=1;
}
inline void pushdown(int x)
{
    if(!tree[x].lan) return;
    if(tree[x].l)
    {
        int p=++tot;
        tree[p]=tree[tree[x].l];
        tree[x].l=p;
        overturn(p);
    }
    if(tree[x].r)
    {
        int p=++tot;
        tree[p]=tree[tree[x].r];
        tree[x].r=p;
        overturn(p);
    }
    tree[x].lan=0;
}
inline int hebin(int x,int y)
{
    if(!x||!y) return x+y;
    if(tree[x].p&lt;tree[y].p)
    {
        int p=newnode(0);
        tree[p]=tree[x];
        pushdown(p);
        tree[p].r=hebin(tree[p].r,y);
        updata(p);
        return p;
    }
    else
    {
        int p=newnode(0);
        tree[p]=tree[y];
        pushdown(p);
        tree[p].l=hebin(x,tree[p].l);
        updata(p);
        return p;
    }
}
void split(int x,int k,int &amp;l,int &amp;r)
{
    if(!x)
    {
        l=r=0;
        return;
    }
    int p=newnode(0);
    tree[p]=tree[x];
    pushdown(p);
    if(tree[tree[p].l].s+1&lt;=k)
    {
        l=p;
        split(tree[p].r,k-(tree[tree[p].l].s+1),tree[p].r,r);
    }
    else
    {
        r=p;
        split(tree[p].l,k,l,tree[p].l);
    }
    updata(p);
}
void print(int x)
{
    pushdown(x);
    if(tree[x].l) print(tree[x].l);
    qput(tree[x].v);putchar(' ');
    if(tree[x].r) print(tree[x].r);
}
inline void Solve()
{
    qread(N);
    for(int i=1;i&lt;=N;i++)
    {
        int v,opt;qread(v);qread(opt);
        int x,y;
        if(opt==1)
        {
            qread(x);qread(y);
            x^=ans;y^=ans;
            split(rt[v],x,t1,t3);
            t2=newnode(y);
            rt[i]=hebin(hebin(t1,t2),t3);
        }
        if(opt==2)
        {
            qread(x);
            x^=ans;
            split(rt[v],x,t1,t3);
            split(t1,x-1,t1,t2);
            rt[i]=hebin(t1,t3);
        }
        if(opt==3)
        {
            qread(x);qread(y);
            x^=ans;y^=ans;
            split(rt[v],y,t1,t3);
            split(t1,x-1,t1,t2);
            overturn(t2);
            rt[i]=hebin(hebin(t1,t2),t3);
        }
        if(opt==4)
        {
            rt[i]=rt[v];
            qread(x);qread(y);
            x^=ans;y^=ans;
            split(rt[i],y,t1,t3);
            split(t1,x-1,t1,t2);
            ans=tree[t2].sum;
            qput(ans);putchar('\n');
        }
//      print(rt[i]);putchar('\n');
    }
}
signed main()
{
    T=1;
    while(T--) Solve();
}
</code></pre>
<h2 id="lca">LCA</h2>
<pre><code class="language-cpp">struct LCA {
    int dep[MaxN], fa[MaxN][21];
    inline void dfs1(int x, int f) {
        fa[x][0] = f;
        dep[x] = dep[f] + 1;
        for (int j = 1; j &lt;= 20; j++) {
            fa[x][j] = fa[fa[x][j - 1]][j - 1];
        }
        for (int i = 0; i &lt; (int)G1[x].size(); i++) {
            int y = G1[x][i];
            if (y == f) continue;
            dfs1(y, x);
        }
    }
    int lca(int x, int y) {
        if (dep[x] &lt; dep[y]) swap(x, y);
        for (int i = 20; i &gt;= 0; i--) {
            if (dep[fa[x][i]] &gt;= dep[y]) x = fa[x][i];
            if (x == y) return x;
        }
        for (int i = 20; i &gt;= 0; i--) {
            if (fa[x][i] != fa[y][i]) {
                x = fa[x][i];
                y = fa[y][i];
            }
        }
        return fa[x][0];
    }
} LCA;
</code></pre>
<pre><code class="language-cpp">struct LCA {
    vector&lt;int&gt; dep, re, st, logn;
    vector&lt;vector&lt;int&gt;&gt; F;
    static const int LogN = 21;
    int top;
    void dfs1(int x, int f) {
        dep[x] = dep[f] + 1;
        st[++top] = x;
        re[x] = top;
        for (int i = 0; i &lt; (int)G1[x].size(); i++) {
            int y = G1[x][i];
            if (y == f) continue;
            dfs1(y, x);
            st[++top] = x;
        }
    }
    int lca(int x, int y) {
        int l = re[x];
        int r = re[y];
        if (l &gt; r) swap(l, r);
        int k = logn[r - l + 1];
        return dep[F[l][k]] &lt; dep[F[r - (1 &lt;&lt; k) + 1][k]]
                ? F[l][k]
                : F[r - (1 &lt;&lt; k) + 1][k];
    }
    inline void clear(int N) {
        dep.assign(N, 0);
        re.assign(N, 0);
        st.assign(N, 0);
        logn.assign(N, 0);
        top = 0;
        F.assign(N, vector&lt;int&gt;(LogN, 0));
    }
    inline void solve(int rt, int N) {
        clear(2 * N + 1);
        dfs1(rt, 0);
        for (int i = 1; i &lt;= 2 * N; i++) {
            F[i][0] = st[i];
        }
        for (int j = 1; j &lt; LogN; j++) {
            for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= 2 * N; i++) {
                F[i][j] = dep[F[i][j - 1]] &lt; dep[F[i + (1 &lt;&lt; (j - 1))][j - 1]]
                            ? F[i][j - 1]
                            : F[i + (1 &lt;&lt; (j - 1))][j - 1];
            }
        }

        logn[0] = -1;
        for (int i = 1; i &lt;= 2 * N; i++) {
            logn[i] = logn[i / 2] + 1;
        }
    }
} Lca;
</code></pre>
<h2 id="vani">[Vani有约会]雨天的尾巴 /【模板】线段树合并</h2>
<h3 id="_55">题目描述</h3>
<p>首先村落里的一共有 $n$ 座房屋，并形成一个树状结构。然后救济粮分 $m$ 次发放，每次选择两个房屋 $(x,~y)$，然后对于 $x$ 到 $y$ 的路径上(含 $x$ 和 $y$)每座房子里发放一袋 $z$ 类型的救济粮。</p>
<p>然后深绘里想知道，当所有的救济粮发放完毕后，每座房子里存放的最多的是哪种救济粮。</p>
<h4 id="_56">输入格式</h4>
<p>输入的第一行是两个用空格隔开的正整数，分别代表房屋的个数 $n$ 和救济粮发放的次数 $m$。</p>
<p>第 $2$ 到 第 $n$ 行，每行有两个用空格隔开的整数 $a,~b$，代表存在一条连接房屋 $a$ 和 $b$ 的边。</p>
<p>第 $(n + 1)$ 到第 $(n + m)$ 行，每行有三个用空格隔开的整数 $x,~y,~z$，代表一次救济粮的发放是从 $x$ 到 $y$ 路径上的每栋房子发放了一袋 $z$ 类型的救济粮。</p>
<h4 id="_57">输出格式</h4>
<p>输出 $n$ 行，每行一个整数，第 $i$ 行的整数代表 $i$ 号房屋存放最多的救济粮的种类，如果有多种救济粮都是存放最多的，输出种类编号最小的一种。</p>
<p>如果某座房屋没有救济粮，则输出 $0$。</p>
<h4 id="1_8">样例 #1</h4>
<h5 id="1_9">样例输入 #1</h5>
<pre><code>5 3
1 2
3 1
3 4
5 3
2 3 3
1 5 2
3 3 3
</code></pre>
<h5 id="1_10">样例输出 #1</h5>
<pre><code>2
3
3
0
2
</code></pre>
<h4 id="_58">提示</h4>
<ul>
<li>对于 $20\%$ 的数据，保证 $n, m \leq 100$。</li>
<li>对于 $50\%$ 的数据，保证 $n, m \leq 2 \times 10^3$。</li>
<li>对于 $100\%$ 测试数据，保证 $1 \leq n, m \leq 10^5$，$1 \leq a,b,x,y \leq n$，$1 \leq z \leq 10^5$。  </li>
</ul>
<h5 id="_59">思路</h5>
<p>利用树上差分:<br />
想要再$(x,y)$区间内加v；<br />
则$d[x]+=v;d[y]+=y;d[lca(x,y)]-=v;d[fa[lca(x,y)]]-=v;$
然后最后把数据递增到$root$上   </p>
<pre><code class="language-cpp">struct TT {
    struct Point {
        int l, r, v;
    } tree[MaxN * 40];
    int tot = 0;
    int change1(int p, int l, int r, int k, int v) {
        int now = ++tot;
        int mid = (l + r) &gt;&gt; 1;
        tree[now] = tree[p];
        if (l == r) {
            tree[now].v += v;
            return now;
        }
        if (k &lt;= mid)
            tree[now].l = change1(tree[now].l, l, mid, k, v);
        else
            tree[now].r = change1(tree[now].r, mid + 1, r, k, v);
        tree[now].v = max(tree[tree[now].l].v, tree[tree[now].r].v);
        return now;
    }
    int hebin(int x, int y) {
        if (!x || !y) return x + y;
        tree[x].l = hebin(tree[x].l, tree[y].l);
        tree[x].r = hebin(tree[x].r, tree[y].r);
        if (!tree[x].l &amp;&amp; !tree[x].r) {
            tree[x].v += tree[y].v;
            return x;
        }
        tree[x].v = max(tree[tree[x].l].v, tree[tree[x].r].v);
        return x;
    }
    int hebin(int x, int y) {
        if (!x || !y) return x + y;
        int p = ++tot;
        tree[p].l = hebin(tree[x].l, tree[y].l);
        tree[p].r = hebin(tree[x].r, tree[y].r);
        if (!tree[p].l &amp;&amp; !tree[p].r) {
            tree[p].sum = tree[x].sum + tree[y].sum;
            tree[p].id = tree[x].id;
            return p;
        }
        tree[p] = pushup(tree[tree[p].l], tree[tree[p].r], tree[p].l, tree[p].r);
        return p;
    }
    int bina(int x, int l, int r) {
        if (l == r) return l;
        int mid = (l + r) &gt;&gt; 1;
        if (tree[tree[x].l].v &gt;= tree[tree[x].r].v) return bina(tree[x].l, l, mid);
        else return bina(tree[x].r, mid + 1, r);
    }
    void solve(int x, int f) {
        for (auto y : G1[x]) {
            if (y == f) continue;
            solve(y, x);
            rt[x] = hebin(rt[x], rt[y]);
        }
        if (!tree[rt[x]].v) ans[x] = 0;
        else ans[x] = bina(rt[x], 1, INF);
    }
} TT;
</code></pre>
<h2 id="_60">【模板】线段树分裂</h2>
<h3 id="_61">题目描述</h3>
<p>给出一个可重集 $a$（编号为 $1$），它支持以下操作：</p>
<p><code>0 p x y</code>：将可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值移动到一个新的可重集中（新可重集编号为从 $2$ 开始的正整数，是上一次产生的新可重集的编号+1）。</p>
<p><code>1 p t</code>：将可重集 $t$ 中的数放入可重集 $p$，且清空可重集 $t$（数据保证在此后的操作中不会出现可重集 $t$）。</p>
<p><code>2 p x q</code>：在 $p$ 这个可重集中加入 $x$ 个数字 $q$。</p>
<p><code>3 p x y</code>：查询可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值的个数。</p>
<p><code>4 p k</code>：查询在 $p$ 这个可重集中第 $k$ 小的数，不存在时输出 <code>-1</code>。</p>
<h4 id="_62">输入格式</h4>
<p>第一行两个整数 $n,m$，表示可重集中的数在 $1\sim n$ 的范围内，有 $m$ 个操作。</p>
<p>接下来一行 $n$ 个整数，表示 $1 \sim n$ 这些数在 $a$ 中出现的次数 $(a_{i} \leq m)$。</p>
<p>接下来的 $m$ 行每行若干个整数，第一个数为操作的编号 $opt$（$0 \leq opt \leq 4$），以<strong>题目描述</strong>为准。</p>
<h4 id="_63">输出格式</h4>
<p>依次输出每个查询操作的答案。</p>
<h4 id="1_11">样例 #1</h4>
<h5 id="1_12">样例输入 #1</h5>
<pre><code>5 12
0 0 0 0 0
2 1 1 1
2 1 1 2
2 1 1 3
3 1 1 3
4 1 2
2 1 1 4
2 1 1 5
0 1 2 4
2 2 1 4
3 2 2 4
1 1 2
4 1 3
</code></pre>
<h5 id="1_13">样例输出 #1</h5>
<pre><code>3
2
4
3
</code></pre>
<pre><code class="language-cpp">struct TT {
    struct Point {
        int sum, l, r;
    } tree[MaxM];
    int tot = 0;
    void del(int x) {
        tree[x].sum = 0;
        tree[x].l = tree[x].r = 0;
    }
    int newnode() {
        int x = ++tot;
        tree[x].sum = 0;
        tree[x].l = tree[x].r = 0;
        return x;
    }
    void pushup(int x) {
        tree[x].sum = tree[tree[x].l].sum + tree[tree[x].r].sum;
    }
    void split(int x, int &amp;y, int k) {
        if (!x) return;
        y = newnode();
        int v = tree[tree[x].l].sum;
        if (k &gt; v) {
            split(tree[x].r, tree[y].r, k - v);
        } else {
            swap(tree[x].r, tree[y].r);
        }
        if (k &lt; v) {
            split(tree[x].l, tree[y].l, k);
        }
        tree[y].sum = tree[x].sum - k;
        tree[x].sum = k;
    }
    int hebin(int x, int y) {
        if (!x || !y) return x + y;
        tree[x].l = hebin(tree[x].l, tree[y].l);
        tree[x].r = hebin(tree[x].r, tree[y].r);
        if (!tree[x].l &amp;&amp; !tree[x].r) {
            tree[x].sum += tree[y].sum;
            return x;
        }
        tree[x].sum = tree[tree[x].l].sum + tree[tree[x].r].sum;
        del(y);
        return x;
    }
    int query(int p, int l, int r, int k) { //左留k个
        if (l == r) {
            return l;
        }
        int mid = (l + r) &gt;&gt; 1;
        if (tree[tree[p].l].sum &gt;= k)
            return query(tree[p].l, l, mid, k);
        else
            return query(tree[p].r, mid + 1, r, k - tree[tree[p].l].sum);
    }
    int query1(int p, int l, int r, int x, int y) {
        if (l &gt;= x &amp;&amp; r &lt;= y) {
            return tree[p].sum;
        }
        int mid = (l + r) &gt;&gt; 1;
        int ans = 0;
        if (mid &gt;= x) ans += query1(tree[p].l, l, mid, x, y);
        if (mid &lt; y) ans += query1(tree[p].r, mid + 1, r, x, y);
        return ans;
    }
    int change(int p, int l, int r, int k, int v) {
        if (!p) p = newnode();
        if (l == r) {
            tree[p].sum += v;
            return p;
        }
        int mid = (l + r) &gt;&gt; 1;
        if (mid &gt;= k)
            tree[p].l = change(tree[p].l, l, mid, k, v);
        else
            tree[p].r = change(tree[p].r, mid + 1, r, k, v);
        pushup(p);
        return p;
    }
} TT;
inline void Solve() {
    cin &gt;&gt; N &gt;&gt; M;
    int num = 1;
    for (int i = 1; i &lt;= N; i++) {
        cin &gt;&gt; a[i];
        rt[1] = TT.change(rt[1], 1, N, i, a[i]);
    }
    for (int i = 1; i &lt;= M; i++) {
        int opt, x, y, p;
        cin &gt;&gt; opt;
        if (opt == 0) {
            cin &gt;&gt; p &gt;&gt; x &gt;&gt; y;
            int k1 = TT.query1(rt[p], 1, N, 1, y);
            int k2 = TT.query1(rt[p], 1, N, x, y);
            int tt = 0;
            TT.split(rt[p], rt[++num], k1 - k2);
            TT.split(rt[num], tt, k2);
            rt[p] = TT.hebin(rt[p], tt);
        } else if (opt == 1) {
            cin &gt;&gt; p &gt;&gt; x;
            rt[p] = TT.hebin(rt[p], rt[x]);

        } else if (opt == 2) {
            cin &gt;&gt; p &gt;&gt; x &gt;&gt; y;
            rt[p] = TT.change(rt[p], 1, N, y, x);
        } else if (opt == 3) {
            cin &gt;&gt; p &gt;&gt; x &gt;&gt; y;
            int ans = TT.query1(rt[p], 1, N, x, y);
            cout &lt;&lt; ans &lt;&lt; endl;
        } else if (opt == 4) {
            cin &gt;&gt; p &gt;&gt; x;
            int ans = -1;
            if (TT.tree[rt[p]].sum &gt;= x) ans = TT.query(rt[p], 1, N, x);
            cout &lt;&lt; ans &lt;&lt; endl;
        }
    }
}
</code></pre>
<h2 id="_64">树套树</h2>
<h3 id="1fhq-treap">1.线段树套FHQ-treap</h3>
<p>每个线段树维护一个对应区间的平衡树 </p>
<hr />
<h4 id="_65">【模板】二逼平衡树（树套树）</h4>
<h4 id="_66">题目描述</h4>
<p>您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：</p>
<ol>
<li>
<p>查询 $k$ 在区间内的排名</p>
</li>
<li>
<p>查询区间内排名为 $k$ 的值</p>
</li>
<li>
<p>修改某一位值上的数值</p>
</li>
<li>
<p>查询 $k$ 在区间内的前驱（前驱定义为严格小于 $x$，且最大的数，<strong>若不存在输出 <code>-2147483647</code></strong>）</p>
</li>
<li>
<p>查询 $k$ 在区间内的后继（后继定义为严格大于 $x$，且最小的数，<strong>若不存在输出 <code>2147483647</code></strong>）</p>
</li>
</ol>
<h4 id="_67">输入格式</h4>
<p>第一行两个数 $n,m$，表示长度为 $n$ 的有序序列和 $m$ 个操作。</p>
<p>第二行有 $n$ 个数，表示有序序列。</p>
<p>下面有 $m$ 行，$opt$ 表示操作标号。</p>
<p>若 $opt=1$，则为操作 $1$，之后有三个数 $l~r~k$，表示查询 $k$ 在区间 $[l,r]$ 的排名。</p>
<p>若 $opt=2$，则为操作 $2$，之后有三个数 $l~r~k$，表示查询区间 $[l,r]$ 内排名为    $k$ 的数。</p>
<p>若 $opt=3$，则为操作 $3$，之后有两个数 $pos~k$，表示将 $pos$ 位置的数修改为 $k$。</p>
<p>若 $opt=4$，则为操作 $4$，之后有三个数 $l~r~k$，表示查询区间 $[l,r]$ 内 $k$ 的前驱。</p>
<p>若 $opt=5$，则为操作 $5$，之后有三个数 $l~r~k$，表示查询区间 $[l,r]$ 内 $k$ 的后继。</p>
<h4 id="_68">输出格式</h4>
<p>对于操作 $1,2,4,5$，各输出一行，表示查询结果。</p>
<p>此数据为洛谷原创。<strong>（特别提醒：此数据不保证操作 4、5 一定存在，故请务必考虑不存在的情况。）</strong><br />
1. 在对应线段树的范围内找有多少个小于k的数</p>
<ol>
<li>
<p>在区间内二分查找，对结果1进行查找</p>
</li>
<li>
<p>把线段树对应的平衡树，删除一个数，增加一个数</p>
</li>
<li>
<p>对于所有比k小的数取max</p>
</li>
<li>
<p>对于所有比k大的数取min  </p>
</li>
</ol>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long 
#define int ll
#define zuo p&lt;&lt;1
#define you p&lt;&lt;1|1
#define INF 2147483647
const int MaxN=2e6+100;
int N,M,tot,t1,t2,t3;
int a[MaxN];
struct point
{
    int v;
}xds[MaxN];
struct node
{
    int l,r,p,s,v,c;
}tree[MaxN];
inline int newnode(int v)
{
    int x=++tot;
    tree[x].l=tree[x].r=0;
    tree[x].v=v;
    tree[x].s=tree[x].c=1;
    tree[x].p=rand();
    return x;
}
inline void updata(int x)
{
    tree[x].s=tree[tree[x].l].s+tree[tree[x].r].s+tree[x].c;
}
void split(int x,int k,int &amp;l,int &amp;r)
{
    if(!x)
    {
        l=r=0;
        return;
    }
    if(tree[x].v&lt;=k)
    {
        l=x;
        split(tree[x].r,k,tree[x].r,r);
    }
    else
    {
        r=x;
        split(tree[x].l,k,l,tree[x].l);
    }
    updata(x);
}
int hebin(int x,int y)
{
    if(!x||!y) return x+y;
    if(tree[x].p&lt;tree[y].p)
    {
        tree[x].r=hebin(tree[x].r,y);
        updata(x);
        return x;
    }
    else
    {
        tree[y].l=hebin(x,tree[y].l);
        updata(y);
        return y;
    }
}
int rebuild(int l,int r)
{
    int rt=0;
    for(int i=l;i&lt;=r;i++)
    {
        split(rt,a[i],t1,t3);
        split(t1,a[i]-1,t1,t2);
        if(t2)
        {
            tree[t2].c++;tree[t2].s++;
            rt=hebin(hebin(t1,t2),t3);
        }
        else
        rt=hebin(hebin(t1,newnode(a[i])),t3);
    }
    return rt;
}
void build(int p,int l,int r)
{
    xds[p].v=rebuild(l,r);
    if(l==r)
    {
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    build(zuo,l,mid);
    build(you,mid+1,r);
}
int ith(int x,int v)
{
    int ans=0;
    while(x)
    {
        if(tree[x].v==v)
        {
            ans+=tree[tree[x].l].s;
//          qput(ans);putchar('\n');
            return ans;
        }
        if(tree[x].v&lt;v)
        {
            ans+=tree[tree[x].l].s+tree[x].c;
            x=tree[x].r;
        }
        else if(tree[x].v&gt;v)
        {
            x=tree[x].l;
        }
    }
//  qput(ans);putchar('\n');
    return ans;
}
int query(int p,int l,int r,int x,int y,int k)
{
    if(r&lt;=y&amp;&amp;l&gt;=x)
    {
        return ith(xds[p].v,k);
    }
    int mid=(l+r)&gt;&gt;1;
    int ans=0;
    if(mid&gt;=x) ans+=query(zuo,l,mid,x,y,k);
    if(mid&lt;y) ans+=query(you,mid+1,r,x,y,k);
    return ans;
}
int pre(int x,int v)
{
    int ans=-INF;
    while(x)
    {
        if(tree[x].v&lt;v)
        {
            ans=max(ans,tree[x].v);
            x=tree[x].r;
        }
        if(tree[x].v&gt;=v)
        {
            x=tree[x].l;
        }
    }
    return ans;
}
int query1(int p,int l,int r,int x,int y,int k)
{
    if(r&lt;=y&amp;&amp;l&gt;=x)
    {
        return pre(xds[p].v,k);
    }
    int mid=(l+r)&gt;&gt;1;
    int ans=-INF;
    if(mid&gt;=x) ans=max(ans,query1(zuo,l,mid,x,y,k));
    if(mid&lt;y) ans=max(ans,query1(you,mid+1,r,x,y,k));
    return ans;
}
int ne(int x,int v)
{
    int ans=INF;
    while(x)
    {
        if(tree[x].v&gt;v)
        {
            ans=min(ans,tree[x].v);
            x=tree[x].l;
        }
        if(tree[x].v&lt;=v)
        {
            x=tree[x].r;
        }
    }
    return ans;
}
int query2(int p,int l,int r,int x,int y,int k)
{
    if(r&lt;=y&amp;&amp;l&gt;=x)
    {
        return ne(xds[p].v,k);
    }
    int mid=(l+r)&gt;&gt;1;
    int ans=INF;
    if(mid&gt;=x) ans=min(ans,query2(zuo,l,mid,x,y,k));
    if(mid&lt;y) ans=min(ans,query2(you,mid+1,r,x,y,k));
    return ans;
}
void delet(int &amp;x,int k)
{
    split(x,k,t1,t3);
    split(t1,k-1,t1,t2);
    if(tree[t2].s&gt;1)
    {
        tree[t2].s--;tree[t2].c--;
        x=hebin(hebin(t1,t2),t3);
    }
    else
    {
        x=hebin(t1,t3);
    }
}
void add1(int &amp;x,int k)
{
    split(x,k,t1,t3);
    split(t1,k-1,t1,t2);
    if(t2)
    {
        tree[t2].s++;tree[t2].c++;
        x=hebin(hebin(t1,t2),t3);
    }
    else
    {
        x=hebin(hebin(t1,newnode(k)),t3);
    }
}
void change(int p,int l,int r,int pos,int k)
{
    if(r&gt;=pos&amp;&amp;l&lt;=pos)
    {
//      xds[p].v=rebuild(l,r);
        delet(xds[p].v,a[pos]);
        add1(xds[p].v,k);
    }
    if(l==r) return;
    int mid=(l+r)&gt;&gt;1;
    if(mid&gt;=pos) change(zuo,l,mid,pos,k);
    if(mid&lt;pos) change(you,mid+1,r,pos,k);
}
inline int js(int x,int y,int k)
{
    int l=0,r=1e8;
    while(l&lt;=r)
    {
        int mid=(l+r)&gt;&gt;1;
        if(query(1,1,N,x,y,mid)+1&gt;k) r=mid-1;
        else l=mid+1;
    }
    return r;
}
signed main()
{
    qread(N);qread(M);
    for(int i=1;i&lt;=N;i++) qread(a[i]);
    build(1,1,N);
    for(int i=1;i&lt;=M;i++)
    {
        int opt;qread(opt);
        int l,r,k,pos;
        if(opt==1)
        {
            qread(l);qread(r);qread(k);
            int ans=query(1,1,N,l,r,k);
            qput(ans+1);putchar('\n');
        }
        if(opt==2)
        {
            qread(l);qread(r);qread(k);
            int ans=js(l,r,k);
            qput(ans);putchar('\n');
        }
        if(opt==3)
        {
            qread(pos);qread(k);
//          a[pos]=k;
            change(1,1,N,pos,k);
            a[pos]=k;
        }
        if(opt==4)
        {
            qread(l);qread(r);qread(k);
            int ans=query1(1,1,N,l,r,k);
            qput(ans);putchar('\n');
        }
        if(opt==5)
        {
            qread(l);qread(r);qread(k);
            int ans=query2(1,1,N,l,r,k);
            qput(ans);putchar('\n');
        }
        // for(int i=1;i&lt;=N;i++)
        // qput(a[i]),putchar(' ');putchar('\n');
    }
}
</code></pre>
<h3 id="2_1">2.树状数组套主席树</h3>
<h4 id="_69">题目描述</h4>
<ul>
<li><code>Q l r k</code> 表示查询下标在区间 $[l,r]$ 中的第 $k$ 小的数  </li>
<li><code>C x y</code> 表示将 $a_x$ 改为 $y$</li>
</ul>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
#define ls p &lt;&lt; 1
#define rs p &lt;&lt; 1 | 1
#define lowbit(x) ((x) &amp; (-x))
const int MaxN = 1e5 + 100;
const int MAXN = 1e5 + 100;
const int MaxM = 3e7 + 3e6;
const int INF = 1e9;
int T, N, M, K, tot, n;
int a[MaxN], b[MaxN &lt;&lt; 1], top;
int tree1[MaxN], rt[MaxN];
int temp1[MaxN], temp2[MaxN];
int t1[MaxN], t2[MaxN], t3[MaxN];
char pd[MaxN];
int cnt1, cnt2;
struct point
{
    int l, r, sum;
}tree[MaxM];
int ef(int x)
{
    int l = 1, r = n;
    while(l &lt;= r)
    {
        int mid = (l + r) &gt;&gt; 1;
        if (b[mid] &gt;= x) r = mid - 1;
        else l = mid + 1;
    }
    return l;
}
int add1(int p, int l, int r, int v, int k)
{
    int x = ++tot;
    tree[x] = tree[p];
    tree[x].sum += v;
    if (l == r)
    {
        return x;
    }
    int mid = (l + r)&gt;&gt;1;
    if (mid &gt;= k) tree[x].l = add1(tree[x].l, l, mid, v, k);
    else tree[x].r = add1(tree[x].r, mid + 1, r, v, k);
    return x;
}
inline void add(int x, int v)
{
    int t = ef(a[x]);
    for (; x &lt;= N; x += lowbit(x))
    {
        rt[x] = add1(rt[x], 1, n, v, t);
    }
}
int query1(int l, int r, int k)
{
    if (l == r) return l;
    int sum = 0;
    int mid = (l + r) &gt;&gt; 1;
    for (int i = 1; i &lt;= cnt1; i++)
    {
        sum -= tree[tree[temp1[i]].l].sum;
    }
    for (int i = 1; i &lt;= cnt2; i++)
    {
        sum += tree[tree[temp2[i]].l].sum;
    }
    if (sum &gt;= k)
    {
        for (int i = 1; i &lt;= cnt1; i++)
        {
            temp1[i] = tree[temp1[i]].l;
        }
        for (int i = 1; i &lt;= cnt2; i++)
        {
            temp2[i] = tree[temp2[i]].l;
        }
        return query1(l, mid, k);
    }
    else
    {
        for (int i = 1; i &lt;= cnt1; i++)
        {
            temp1[i] = tree[temp1[i]].r;
        }
        for (int i = 1; i &lt;= cnt2; i++)
        {
            temp2[i] = tree[temp2[i]].r;
        }
        return query1(mid + 1, r, k - sum);
    }
}
inline int query(int l, int r, int k)
{
    cnt1 = 0;
    cnt2 = 0;
    for (int i = l - 1; i; i -= lowbit(i))
    {
        temp1[++cnt1] = rt[i];
    }
    for (int i = r; i; i -= lowbit(i))
    {
        temp2[++cnt2] = rt[i];
    }
    return query1(1, n, k);
}
inline void Solve()
{
    cin &gt;&gt; N &gt;&gt; M;
    for (int i = 1; i &lt;= N; i++)
    {
        cin &gt;&gt; a[i];
        b[++top] = a[i];
    }
    for (int i = 1; i &lt;= M; i++)
    {
        char opt;
        int x, y, z;
        cin &gt;&gt; opt;
        pd[i] = opt;
        if (opt == 'C')
        {
            cin &gt;&gt; x &gt;&gt; y;
            t1[i] = x;
            t2[i] = y;
            b[++top] = y;
        }
        else
        {
            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
            t1[i] = x;
            t2[i] = y;
            t3[i] = z;
        }
    }
    sort(b + 1, b + 1 + top);
    n = unique(b + 1, b + 1 + top) - (b + 1);
    for (int i = 1; i &lt;= N; i++)
    {
        add(i, 1);
    }
    for (int i = 1; i &lt;= M; i++)
    {
        char opt;
        int x, y, z;
        opt = pd[i];
        if (opt == 'C')
        {
            x = t1[i];
            y = t2[i];
            add(x, -1);
            a[x] = y;
            add(x, 1);
        }
        else
        {
            x = t1[i];
            y = t2[i];
            z = t3[i];
            int ans = query(x, y, z);
            cout &lt;&lt; b[ans] &lt;&lt; endl;
        }
    }
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    Solve();
}
</code></pre>
<h3 id="_70">权值线段树套权值线段树(二维单点修改，矩形查询)</h3>
<pre><code class="language-cpp">int n1, n2;
struct Segment {
    struct Point {
        int l, r;
        ll sum;
    } tree[MaxM];
    int tot;
    Segment() {
        init();
    }
    Segment(int _n) {
        init(_n);
    }
    void init() {
        // tree.clear();
        // tree.push_back({});
        tot = 0;
    }
    void init(int _n) {
        // tree.clear();
        tot = 0;
        // tree.assign(_n, {});
    }

    inline Point pushup(Point L, Point R) {
        Point now = Point();
        now.sum = L.sum + R.sum;
        return now;
    }

    inline void pushup(int p) {
        tree[p].sum = tree[tree[p].l].sum + tree[tree[p].r].sum;
    }

    int change(int p, int l, ll r, int k, int v) {
        // while (tree.size() &lt;= tot + 1) tree.push_back({});
        if (!p) {
            p = ++tot;
        }
        if (l == r) {
            tree[p].sum += v;
            return p;
        }
        int mid = (l + r) &gt;&gt; 1;
        if (mid &gt;= k) tree[p].l = change(tree[p].l, l, mid, k, v);
        else tree[p].r = change(tree[p].r, mid + 1, r, k, v);
        pushup(p);
        return p;
    }

    ll query(int p, int l, ll r, int x, int y) {
        if (p &gt; tot) return 0;
        if (l &gt;= x &amp;&amp; r &lt;= y) {
            return tree[p].sum;
        }
        int mid = (l + r) &gt;&gt; 1;
        ll ans = 0;
        if (mid &gt;= x) ans += query(tree[p].l, l, mid, x, y);
        if (mid &lt; y) ans += query(tree[p].r, mid + 1, r, x, y);
        return ans;
    }
};
struct Segment2 {
    Segment segment;
    struct Point {
        int l, r, rt;
    } tree[MaxN * 10];
    int tot;
    Segment2() {
        init();
    }
    Segment2(int _n) {
        init(_n);
    }
    void init() {
        // tree.clear();
        // tree.push_back({});
        tot = 0;
        segment.init(MaxN * 400);
    }
    void init(int _n) {
        // tree.clear();
        tot = 0;
        // tree.assign(_n, {});
    }


    int change(int p, int l, ll r, int k, int k2, int v) {
        // while (tree.size() &lt;= tot + 10) tree.push_back({});
        if (!p) {
            p = ++tot;
        }
        tree[p].rt = segment.change(tree[p].rt, 1, n2, k2, v);
        if (l == r) {
            return p;
        }
        int mid = (l + r) &gt;&gt; 1;
        if (mid &gt;= k) tree[p].l = change(tree[p].l, l, mid, k, k2, v);
        else tree[p].r = change(tree[p].r, mid + 1, r, k, k2, v);
        return p;
    }

    ll query(int p, int l, ll r, int x, int y, int x2, int y2) {
        if (p &gt; tot) return 0;
        if (l &gt;= x &amp;&amp; r &lt;= y) {
            return segment.query(tree[p].rt, 1, n2, x2, y2);
        }
        int mid = (l + r) &gt;&gt; 1;
        ll ans = 0;
        if (mid &gt;= x) ans += query(tree[p].l, l, mid, x, y, x2, y2);
        if (mid &lt; y) ans += query(tree[p].r, mid + 1, r, x, y, x2, y2);
        return ans;
    }
};
</code></pre>
<h2 id="link-cut-tree">【模板】动态树（Link Cut Tree）</h2>
<h3 id="_71">题目描述</h3>
<p>给定 $n$ 个点以及每个点的权值，要你处理接下来的 $m$ 个操作。<br />
操作有四种，操作从 $0$ 到 $3$ 编号。点从 $1$ 到 $n$ 编号。</p>
<ul>
<li><code>0 x y</code> 代表询问从 $x$ 到 $y$ 的路径上的点的权值的 $\text{xor}$ 和。保证 $x$ 到 $y$ 是联通的。</li>
<li><code>1 x y</code> 代表连接 $x$ 到 $y$，若 $x$ 到 $y$ 已经联通则无需连接。</li>
<li><code>2 x y</code> 代表删除边 $(x,y)$，不保证边 $(x,y)$ 存在。</li>
<li><code>3 x y</code> 代表将点 $x$ 上的权值变成 $y$。</li>
</ul>
<h3 id="_72">输入格式</h3>
<p>第一行两个整数，分别为 $n$ 和 $m$，代表点数和操作数。</p>
<p>接下来 $n$ 行，每行一个整数，第 $(i + 1)$ 行的整数 $a_i$ 表示节点 $i$ 的权值。</p>
<p>接下来 $m$ 行，每行三个整数，分别代表操作类型和操作所需的量。</p>
<h3 id="_73">输出格式</h3>
<p>对于每一个 $0$ 号操作，你须输出一行一个整数，表示 $x$ 到 $y$ 的路径上点权的 $\text{xor}$ 和。</p>
<h3 id="1_14">样例 #1</h3>
<h4 id="1_15">样例输入 #1</h4>
<pre><code>3 3 
1
2
3
1 1 2
0 1 2 
0 1 1
</code></pre>
<h4 id="1_16">样例输出 #1</h4>
<pre><code>3
1
</code></pre>
<h3 id="2_2">样例 #2</h3>
<h4 id="2_3">样例输入 #2</h4>
<pre><code>5 14
114
514
19
19
810
1 1 2
0 1 2
2 1 2
1 1 2
1 2 3
2 1 3
1 1 3
1 4 5
1 2 5
0 3 5
0 3 4
3 5 233333
0 1 5
0 2 5
</code></pre>
<h4 id="2_4">样例输出 #2</h4>
<pre><code>624
315
296
232709
232823
</code></pre>
<p>动态树lct模板  </p>
<pre><code class="language-cpp">struct LCT {
    struct Point {
        int s, fa, ch[2], v, lan, sum;
    } tree[MaxN];
    inline void pushup(int x) {
        tree[x].s = tree[tree[x].ch[0]].s + tree[tree[x].ch[1]].s + 1;
        tree[x].sum = tree[tree[x].ch[0]].sum ^ tree[tree[x].ch[1]].sum ^ tree[x].v;
    }
    inline bool isroot(int x) {
        return tree[tree[x].fa].ch[0] != x &amp;&amp; tree[tree[x].fa].ch[1] != x;
    }
    inline void overturn(int x) {
        swap(tree[x].ch[0], tree[x].ch[1]);
        tree[x].lan ^= 1;
    }
    inline void pushdown(int x) {
        if (tree[x].lan) {
            overturn(tree[x].ch[0]);
            overturn(tree[x].ch[1]);
            tree[x].lan = 0;
        }
    }
    inline void updata(int x) {
        if (!isroot(x)) updata(tree[x].fa);
        pushdown(x);
    }
    inline bool get(int x) {
        return x == tree[tree[x].fa].ch[1];
    }
    inline void rotate(int x) {
        int y = tree[x].fa, z = tree[y].fa, k = get(x);
        if (!isroot(y)) tree[z].ch[tree[z].ch[1] == y] = x;
        tree[y].ch[k] = tree[x].ch[k ^ 1];
        tree[tree[x].ch[k ^ 1]].fa = y;
        tree[x].ch[k ^ 1] = y;
        tree[y].fa = x;
        tree[x].fa = z;
        pushup(y); pushup(x);
    }
    inline void splay(int x) {
        updata(x);
        for (int f; f = tree[x].fa, !isroot(x); rotate(x)) {
            if (!isroot(f)) rotate(get(f) == get(x)? f : x);
        }
    }
    inline int access(int x) {
        int p;
        for (p = 0; x; p = x, x = tree[x].fa) {
            splay(x); tree[x].ch[1] = p; pushup(x);
        }
        return p;
    }
    inline void makeroot(int p) {
        access(p); splay(p);
        overturn(p);
    }
    inline int find(int x) {
        access(x);
        splay(x);
        while (tree[x].ch[0]) {
            pushdown(x);
            x = tree[x].ch[0];
        }
        splay(x);
        return x;
    }
    inline bool link(int x, int y) {
        makeroot(x);
        if (find(y) == x) return 0;
        tree[x].fa = y; 
        return 1;
    }
    inline void split(int x, int y) {
        makeroot(x);
        access(y);
        splay(y);
    }
    inline void cut(int x, int y) {
        makeroot(x);
        if (find(y) == x &amp;&amp; tree[y].fa == x &amp;&amp; tree[y].ch[0] == 0) {
            tree[y].fa = tree[x].ch[1] = 0;
            pushup(x);
        }
    }
    inline int findf(int x) {
        while (tree[x].ch[1]) {
            pushdown(x);
            x = tree[x].ch[1];
        }
        return x;
    }
    inline void cutTree(int x, int y) { // 以x为根，分离y和fa[y]
        split(x, y);
        x = findf(tree[y].ch[0]);
        cut(x, y);
    }
    inline int lca(int x, int y) {
        access(x);
        return access(y);
    }
    inline bool lt(int x, int y) { // 是否联通
        makeroot(x);
        if (find(y) == x) return 1;
        return 0;
    }
} TT;

inline void Solve() {
    cin &gt;&gt; N &gt;&gt; M;
    for (int i = 1; i &lt;= N; i++) {
        cin &gt;&gt; TT.tree[i].v;
    }
    for (int i = 1; i &lt;= M; i++) {
        int opt, x, y;
        cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;
        if (opt == 0) {
            TT.split(x, y);
            int ans = TT.tree[y].sum;
            cout &lt;&lt; ans &lt;&lt; endl;
        }
        else if (opt == 1) {
            TT.link(x, y);
        }
        else if (opt == 2) {
            TT.cut(x, y);
        }
        else {
            TT.splay(x); TT.tree[x].v = y;
            TT.pushup(x);
        }
    }
}

</code></pre>
<h3 id="_74">维护子树大小</h3>
<pre><code class="language-cpp">    makeroot(1);
    access(now);
    splay(now);
    // ans = 自己虚树值 + 自己的值 + 右子树的值
    return TT.tree[now].t + TT.tree[now].v + TT.tree[TT.tree[now].ch[1]].sum;
    inline void pushup(int x) {
        tree[x].s = tree[tree[x].ch[0]].s + tree[tree[x].ch[1]].s + 1 + tree[x].sum;
        // tree[x].sum = tree[tree[x].ch[0]].sum ^ tree[tree[x].ch[1]].sum ^ tree[x].v;
    }
    inline int access(int x) {
        int p;
        for (p = 0; x; p = x, x = tree[x].fa) {
            splay(x);
            tree[x].sum += tree[tree[x].ch[1]].s;
            tree[x].sum -= tree[p].s;
            tree[x].ch[1] = p;
            pushup(x);
        }
        return p;
    }
    inline bool link(int x, int y) {
        makeroot(x);
        if (find(y) == x) return 0;
        access(y);
        splay(y);
        tree[x].fa = y;
        tree[y].sum += tree[x].s; 
        return 1;
    }
</code></pre>
<h3 id="makeroot">无makeroot</h3>
<pre><code class="language-cpp">    inline void link(int x, int y) {
        access(y);
        splay(y);
        tree[x].fa = y;
        tree[y].t += tree[x].sum; 
        pushup(y);
    }
    inline void cut(int x) {
        access(x);
        splay(x);
        tree[tree[x].ch[0]].fa = 0;
        tree[x].ch[0] = 0;
        pushup(x);
    }
</code></pre>
<h3 id="_75">乘法加法混合</h3>
<pre><code class="language-cpp">struct LCT {
    struct Point {
        int s, fa, ch[2], lan;
        Z v, sum;
        Z add, mul = 1;
    } tree[MaxN];
    inline void pushup(int x) {
        tree[x].s = tree[tree[x].ch[0]].s + tree[tree[x].ch[1]].s + 1;
        tree[x].sum = tree[tree[x].ch[0]].sum + tree[tree[x].ch[1]].sum + tree[x].v;
    }
    inline bool isroot(int x) {
        return tree[tree[x].fa].ch[0] != x &amp;&amp; tree[tree[x].fa].ch[1] != x;
    }
    inline void overturn(int x) {
        swap(tree[x].ch[0], tree[x].ch[1]);
        tree[x].lan ^= 1;
    }
    void changeadd(int x, Z v) {
        tree[x].v += v;
        tree[x].sum += v * tree[x].s;
        tree[x].add += v;
    }
    void changemul(int x, Z v) {
        tree[x].mul *= v;
        tree[x].v *= v;
        tree[x].add *= v;
        tree[x].sum *= v;
    }
    inline void pushdown(int x) {
        if (tree[x].lan) {
            overturn(tree[x].ch[0]);
            overturn(tree[x].ch[1]);
            tree[x].lan = 0;
        }

        if (tree[x].ch[0]) changemul(tree[x].ch[0], tree[x].mul);
        if (tree[x].ch[1]) changemul(tree[x].ch[1], tree[x].mul);

        tree[x].mul = 1;

        if (tree[x].ch[0]) changeadd(tree[x].ch[0], tree[x].add);
        if (tree[x].ch[1]) changeadd(tree[x].ch[1], tree[x].add);
        tree[x].add = 0;

    }
    inline void updata(int x) {
        if (!isroot(x)) updata(tree[x].fa);
        pushdown(x);
    }
    inline bool get(int x) {
        return x == tree[tree[x].fa].ch[1];
    }
    inline void rotate(int x) {
        int y = tree[x].fa, z = tree[y].fa, k = get(x);
        if (!isroot(y)) tree[z].ch[tree[z].ch[1] == y] = x;
        tree[y].ch[k] = tree[x].ch[k ^ 1];
        tree[tree[x].ch[k ^ 1]].fa = y;
        tree[x].ch[k ^ 1] = y;
        tree[y].fa = x;
        tree[x].fa = z;
        pushup(y); pushup(x);
    }
    inline void splay(int x) {
        updata(x);
        for (int f; f = tree[x].fa, !isroot(x); rotate(x)) {
            if (!isroot(f)) rotate(get(f) == get(x)? f : x);
        }
    }
    inline int access(int x) {
        int p;
        for (p = 0; x; p = x, x = tree[x].fa) {
            splay(x); tree[x].ch[1] = p; pushup(x);
        }
        return p;
    }
    inline void makeroot(int p) {
        access(p); splay(p);
        overturn(p);
    }
    inline int find(int x) {
        access(x);
        splay(x);
        while (tree[x].ch[0]) {
            pushdown(x);
            x = tree[x].ch[0];
        }
        splay(x);
        return x;
    }
    inline bool link(int x, int y) {
        makeroot(x);
        if (find(y) == x) return 0;
        tree[x].fa = y; 
        return 1;
    }
    inline void split(int x, int y) {
        makeroot(x);
        access(y);
        splay(y);
    }
    inline void cut(int x, int y) {
        makeroot(x);
        if (find(y) == x &amp;&amp; tree[y].fa == x &amp;&amp; tree[y].ch[0] == 0) {
            tree[y].fa = tree[x].ch[1] = 0;
            pushup(x);
        }
    }
    inline int findf(int x) {
        while (tree[x].ch[1]) {
            pushdown(x);
            x = tree[x].ch[1];
        }
        return x;
    }
    inline void cutTree(int x, int y) { // 以x为根，分离y和fa[y]
        split(x, y);
        x = findf(tree[y].ch[0]);
        cut(x, y);
    }
    inline int lca(int x, int y) {
        access(x);
        return access(y);
    }
} TT;
</code></pre>
<h2 id="k-d-tree">K-D Tree</h2>
<h3 id="_76">简单题</h3>
<h4 id="_77">题目描述</h4>
<p>你有一个$N \times N$的棋盘，每个格子内有一个整数，初始时的时候全部为 $0$，现在需要维护两种操作：</p>
<ul>
<li><code>1 x y A</code>    $1\le x,y\le N$，$A$ 是正整数。将格子<code>x</code>,<code>y</code>里的数字加上 $A$。</li>
<li><code>2 x1 y1 x2 y2</code>    $1 \le x_1 \le x_2 \le N$，$1 \le y_1\le y_2 \le N$。输出 $x_1, y_1, x_2, y_2$ 这个矩形内的数字和</li>
<li><code>3</code>    无 终止程序</li>
</ul>
<h4 id="_78">输入格式</h4>
<p>输入文件第一行一个正整数 $N$。</p>
<p>接下来每行一个操作。每条命令除第一个数字之外，均要异或上一次输出的答案 <code>last_ans</code>，初始时 <code>last_ans</code> $=0$。</p>
<h4 id="_79">输出格式</h4>
<p>对于每个 $2$ 操作，输出一个对应的答案。</p>
<h4 id="1_17">样例 #1</h4>
<h5 id="1_18">样例输入 #1</h5>
<pre><code>4
1 2 3 3
2 1 1 3 3
1 1 1 1
2 1 1 0 7
3
</code></pre>
<h5 id="1_19">样例输出 #1</h5>
<pre><code>3
5
</code></pre>
<h4 id="_80">提示</h4>
<p>$1\leq N\leq 5\times 10^5$，操作数不超过 $2\times 10^5$ 个，内存限制 $20\texttt{MB}$，保证答案在 int 范围内并且解码之后数据仍合法。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
#define ld long double
#define ls p &lt;&lt; 1
#define rs p &lt;&lt; 1 | 1
#define lowbit(x) ((x) &amp; (-x))
const int MaxN = 2e5 + 100;
const int INF = 1e9;
int T, N, M, K, lastans, tot, rt;
int st[MaxN], top;
ld api = 0.7;
int xl, yl, xr, yr;
struct point
{
    int x, y, z;
} a[MaxN];
struct edge
{
    int L, R, U, D;
    int l, r, d;
    int sum, s;
} tree[MaxN];
void maintain(int x)
{
    tree[x].sum = tree[tree[x].l].sum + tree[tree[x].r].sum + a[x].z;
    tree[x].s = tree[tree[x].l].s + tree[tree[x].r].s + 1;
    tree[x].L = tree[x].R = a[x].x;
    tree[x].U = tree[x].D = a[x].y;
    if (tree[x].l)
    {
        tree[x].L = min(tree[x].L, tree[tree[x].l].L);
        tree[x].R = max(tree[x].R, tree[tree[x].l].R);
        tree[x].U = max(tree[x].U, tree[tree[x].l].U);
        tree[x].D = min(tree[x].D, tree[tree[x].l].D);
    }
    if (tree[x].r)
    {
        tree[x].L = min(tree[x].L, tree[tree[x].r].L);
        tree[x].R = max(tree[x].R, tree[tree[x].r].R);
        tree[x].U = max(tree[x].U, tree[tree[x].r].U);
        tree[x].D = min(tree[x].D, tree[tree[x].r].D);
    }
}
inline bool cmp1(int x, int y)
{
    return a[x].x &lt; a[y].x;
}
inline bool cmp2(int x, int y)
{
    return a[x].y &lt; a[y].y;
}
int build(int l, int r)
{
    if (l &gt; r) return 0;
    int mid = (l + r) &gt;&gt; 1;
    ld ave1 = 0, ave2 = 0, fc1 = 0, fc2 = 0;
    for (int i = l; i &lt;= r; i++)
    {
        ave1 += a[st[i]].x;
        ave2 += a[st[i]].y;
    }
    ave1 /= (r - l + 1);
    ave2 /= (r - l + 1);
    for (int i = l; i &lt;= r; i++)
    {
        fc1 += (a[st[i]].x - ave1) * (a[st[i]].x - ave1);
        fc2 += (a[st[i]].y - ave2) * (a[st[i]].y - ave2);
    }
    if (fc1 &gt; fc2)
    {
        nth_element(st + l, st + mid, st + r + 1, cmp1);
        tree[st[mid]].d = 1;
    }
    else
    {
        nth_element(st + l, st + mid, st + r + 1, cmp2);
        tree[st[mid]].d = 2;
    }
    tree[st[mid]].l = build(l, mid - 1);
    tree[st[mid]].r = build(mid + 1, r);
    maintain(st[mid]);
    return st[mid];
}
inline bool bad(int x)
{
    return api * tree[x].s &lt;= max(tree[tree[x].l].s, tree[tree[x].r].s);
}
void print(int x)
{
    if (tree[x].l)
        print(tree[x].l);
    st[++top] = x;
    if (tree[x].r)
        print(tree[x].r);
}
void rebuild(int &amp;x)
{
    top = 0;
    print(x);
    x = build(1, top);
}
void insert(int &amp;x, int k)
{
    if (!x)
    {
        x = k;
        maintain(x);
        return;
    }
    if (tree[x].d == 1)
    {
        if (a[k].x &lt;= a[x].x)
            insert(tree[x].l, k);
        else
            insert(tree[x].r, k);
    }
    else
    {
        if (a[k].y &lt;= a[x].y)
            insert(tree[x].l, k);
        else
            insert(tree[x].r, k);
    }
    maintain(x);
    if (bad(x)) rebuild(x);

}
int query(int x)
{
    if (!x || tree[x].L &gt; xr || tree[x].R &lt; xl || tree[x].U &lt; yl || tree[x].D &gt; yr) 
        return 0;
    if (tree[x].L &gt;= xl &amp;&amp; tree[x].R &lt;= xr &amp;&amp; tree[x].U &lt;= yr &amp;&amp; tree[x].D &gt;= yl) 
        return  tree[x].sum;
    int res = 0;
    if (a[x].x &gt;= xl &amp;&amp; a[x].x &lt;= xr &amp;&amp; a[x].y &gt;= yl &amp;&amp; a[x].y &lt;= yr)
    {
        res += a[x].z;
    }
    return query(tree[x].l) + query(tree[x].r) + res;
}
inline void Solve()
{
    cin &gt;&gt; N;
    int opt;
    while (cin &gt;&gt; opt)
    {
        if (opt == 3)
            break;
        if (opt == 1)
        {
            int x, y, z;
            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
            x ^= lastans;
            y ^= lastans;
            z ^= lastans;
            tot++;
            a[tot].x = x;
            a[tot].y = y;
            a[tot].z = z;
            insert(rt, tot);
        }
        else
        {
            cin &gt;&gt; xl &gt;&gt; yl &gt;&gt; xr &gt;&gt; yr;
            xl ^= lastans;
            xr ^= lastans;
            yl ^= lastans;
            yr ^= lastans;
            lastans = query(rt);
            cout &lt;&lt; lastans &lt;&lt; '\n';
        }
    }
}
signed main()
{
    Solve();
}
</code></pre>
<h1 id="_81">数论</h1>
<h2 id="sqrt">sqrt求根号</h2>
<pre><code class="language-cpp">int safe_sqrt(int x) {
    int ans = sqrtf(x);
    while ((ans + 1) * (ans + 1) &lt;= x) ans++;
    while (ans * ans &gt; x) ans--;
    return ans;
}
</code></pre>
<h2 id="_82">质数筛</h2>
<pre><code class="language-cpp">inline void pre() {
    for (int i = 2; i &lt;= N; i++) {
        if (!vis[i]) {
            vis[i] = i;
            prime[++tot] = i;
        }
        for (int j = 1; j &lt;= tot; j++) {
            if (prime[j] &gt; N / i || prime[j] &gt; vis[i]) break;
            vis[prime[j] * i] = prime[j];
        }
    }
}
</code></pre>
<h2 id="exgcd">exgcd求逆元</h2>
<pre><code class="language-cpp">void exgcd(int a, int b, int &amp;d, int &amp;x, int &amp;y) {
    int t;
    if (b == 0) {
        d = a; x = 1; y = 0;
    } else {
        exgcd(b, a % b, d, x ,y);
        t = x; x = y; y = t - (a / b) * y;
    }
}
int ny(int a, int P) {
    int x, y, d;
    exgcd(a, P, d, x, y);
    return (x % P + P) % P;
}
</code></pre>
<h2 id="_83">组合数</h2>
<pre><code class="language-cpp">struct Math {
    int jc[MaxN], ijc[MaxN], ip[MaxN];
    int ksm(int x, int y) {
        int res = 1;
        while (y) {
            if (y &amp; 1) res = res * x % P;
            x = x * x % P;
            y &gt;&gt;= 1;
        }
        return res;
    }
    inline void pre(int N) {
        jc[0] = ijc[0] = 1;
        for (int i = 1; i &lt;= N; i++) {
            jc[i] = jc[i - 1] * i % P;
        }
        ijc[N] = ksm(jc[N], P - 2);
        for (int i = N; i &gt;= 1; i--) {
            ijc[i - 1] = ijc[i] * i % P;
        }
    }
    inline void pre1(int N) {
        jc[0] = ijc[0] = 1;
        for (int i = 1; i &lt;= N; i++) {
            jc[i] = jc[i - 1] * i % P;
        }
        ip[1] = 1;
        for (int i = 2; i &lt;= N; i++) {
            ip[i] = (P - P / i) * ip[P % i] % P;
        }
        for (int i = 1; i &lt;= N; i++) {
            ijc[i] = ijc[i - 1] * ip[i] % P;
        }
    }
    inline int C(int n, int m) {
        if (m &gt; n) return 0;
        return jc[n] * ijc[m] % P * ijc[n - m] % P;
    }
    int lucas(int n, int m) {
        if(m == 0) return 1;
        return lucas(n / P, m / P) * C(n % P, m % P) % P;
    }
    int js(int n, int m) {// n个相同的小球放入m个不同的箱子中
        return C(n + m - 1, m - 1);
    }
} TT;
</code></pre>
<h2 id="excrt">【模板】扩展中国剩余定理（EXCRT）</h2>
<h4 id="_84">题目描述</h4>
<p>给定  $n$ 组非负整数  $a_i, b_i$ ，求解关于  $x$ 的方程组的最小非负整数解。
$$\begin{cases} x \equiv b_1\ ({\rm mod}\ a_1) \ x\equiv b_2\ ({\rm mod}\ a_2) \ ... \ x \equiv b_n\ ({\rm mod}\ a_n)\end{cases}$$</p>
<h4 id="_85">输入格式</h4>
<p>输入第一行包含整数 $n$。</p>
<p>接下来 $n$ 行，每行两个非负整数 $a_i, b_i$。</p>
<h4 id="_86">输出格式</h4>
<p>输出一行，为满足条件的最小非负整数 $x$。</p>
<h4 id="1_20">样例 #1</h4>
<h5 id="1_21">样例输入 #1</h5>
<pre><code>3
11 6
25 9
33 17
</code></pre>
<h5 id="1_22">样例输出 #1</h5>
<pre><code>809
</code></pre>
<h4 id="_87">提示</h4>
<p>对于 $100 \%$ 的数据，$1 \le n \le {10}^5$，$1 \le b_i,a_i \le {10}^{12}$，保证所有 $a_i$ 的最小公倍数不超过 ${10}^{18}$。</p>
<p><strong>请注意程序运行过程中进行乘法运算时结果可能有溢出的风险。</strong></p>
<p>数据保证有解。   </p>
<h4 id="_88">题解：</h4>
<p>与中国剩余定理的区别在$b$不互质上<br />
可以考虑数学归纳法，已经求出前$k-1$个方程的解$ans$<br />
记$M=lcm(m_1,m_2,...,m_{k-1})$<br />
考虑求第k个方程求出一个$x$使得$ans+x \cdot M\equiv a_k(\bmod m_k)$<br />
该方程等价于$x \cdot M\equiv a_k-ans(\bmod m_k)$ <br />
令$c=a_k-ans$<br />
则求$x \cdot M+m_k \cdot y=c$<br />
利用$exgcd(M,b_i,d,x,y)$可求出x; <br />
$x=x \cdot \frac{c}{d}$ ;<br />
则$ans'=ans+x \cdot M$</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long 
#define int ll
const int MaxN=1e5+100;
int N,M=1;
int a[MaxN],b[MaxN];
template&lt;class T&gt;
inline void qread(T &amp;sum)
{
    sum=0;int boo=1;
    char x=getchar();
    while(x&lt;'0'||x&gt;'9'){if(x=='-')boo=-1;x=getchar();}
    while(x&gt;='0'&amp;&amp;x&lt;='9'){sum=(sum&lt;&lt;1)+(sum&lt;&lt;3)+x-'0';x=getchar();}
    sum*=boo;
}
template&lt;class T&gt;
void qput(T x)
{
    if(x&lt;0) {x=-x;putchar('-');}
    if(x&gt;9){qput(x/10);}
    putchar(x%10+48);
}
void exgcd(int a,int b,int &amp;d,int &amp;x,int &amp;y)
{
    if(!b)
    {
        d=a;x=1;y=0;
        return;
    }
    exgcd(b,a%b,d,x,y);
    int t=x;
    x=y;y=t-a/b*y;
}
int mul(int x,int y,int p)//龟速乘
{
    int res=0;
    while(y)
    {
        if(y&amp;1) res=(res+x)%p;
        x=(x+x)%p;
        y&gt;&gt;=1;
    }
    return res;
}
int excrt()
{
    int ans=a[1],M=b[1];
    for(int i=2;i&lt;=N;i++)
    {
        int d,x,y,ts,c=((a[i]-ans)%b[i]+b[i])%b[i];
        exgcd(M,b[i],d,x,y);
        if(c%d!=0) return -1;
        ts=b[i]/d;
        x=mul(x,c/d,ts);
//      x=x*c/d%ts;
        ans+=x*M;
        M=M*ts;
        ans=(ans%M+M)%M;
    }
    return ans;
}
signed main()
{
    qread(N);
    for(int i=1;i&lt;=N;i++)
    qread(b[i]),qread(a[i]);
    int ans=excrt();
    qput(ans);
}
</code></pre>
<h2 id="pollard-rho">【模板】Pollard-Rho算法</h2>
<p>注意：1和质数的情况，都会使用dfs死循环</p>
<pre><code class="language-cpp">struct PollardRho {
    vector&lt;ll&gt; G1; 
    inline ll mul(ll a, ll b, ll p) { //快速乘 
        ll x = (long double)a / p * b;
        return ((ull)a * b - (ull)x * p + p) % p;
    }
    inline ll ksm(ll x, ll y, ll p) {
        ll res = 1;
        while (y) {
            if (y &amp; 1) res = mul(res, x, p);
            x = mul(x, x, p);
            y &gt;&gt;= 1;
        }
        return res;
    }
    ll gcd(ll x, ll y) {
        if (y == 0) return x;
        return gcd(y, x % y);
    }
    inline bool check(ll x) {
        if (x == 0 || x == 1) return 0;
        if (x == 2) return 1;
        if (x % 2 == 0) return 0;
        ll p = x - 1, q = 0;
        while (p % 2 == 0)
            q++, p /= 2;
        for (int i = 1; i &lt;= 10; i++) {
            int a = rand() % (x - 1) + 1;
            ll v = ksm(a, p, x);
            if (v == 1) continue;
            int j;
            for (j = 1; j &lt;= q; j++) {
                if (v == x - 1) break;
                v = mul(v, v, x);
            }
            if (j &gt; q) return 0;
        }
        return 1;
    }
    inline ll f(ll x, ll c, ll p) { return (mul(x, x, p) + c) % p; }
    inline ll PR(ll n) {
        if (n == 4) return 2;
        ll x = rand() % (n - 1) + 1, y = x, c = rand() % (n - 1) + 1;
        x = f(x, c, n), y = f(f(y, c, n), c, n);
        for (int i = 1; x != y; i = min(i &lt;&lt; 1, 128ll)) {
            ll cnt = 1;
            for (int j = 0; j &lt; i; j++) {
                cnt = mul(cnt, abs(x - y), n)   ;
                if (!cnt) break;
                x = f(x, c, n), y = f(f(y, c, n), c, n);
            }
            ll d = gcd(cnt, n);
            if (d != 1) return d;
        }
        return n;
    }
    void dfs(ll n) {
        ll d = PR(n);
        while (d == n) d = PR(n);
        ll d2 = n / d;
        if (check(d)) G1.push_back(d);
        else dfs(d);
        if (check(d2)) G1.push_back(d2);
        else dfs(d2);
    }
    inline vector&lt;ll&gt; solve(ll x) {
        G1.clear();
        if (check(x)) G1.push_back(x);
        else dfs(x);
        sort(G1.begin(), G1.end());
        return G1;
    }
    inline vector&lt;pair&lt;int, int&gt; &gt; solve1(ll x) { // 每个质数以及出现的数量
        vector&lt;ll&gt; G1 = solve(x);
        vector&lt;pair&lt;int, int&gt; &gt; ans;
        int cnt = 0;
        for (int i = 0; i &lt; (int)G1.size(); i++) {
            cnt++;
            if (i == (int)G1.size() - 1 || G1[i] != G1[i + 1]) {
                ans.push_back(make_pair(G1[i], cnt));
                cnt = 0;
            }
        }
        return ans;
    } 
} PR;
</code></pre>
<h1 id="_89">字符串</h1>
<h2 id="trie">Trie</h2>
<pre><code class="language-cpp">struct trie{
    int nex[MaxN][26],cnt;
    bool exist[MaxN];
    inline void insert(string s){
        int p=0;
        for(int i=0;i&lt;s.size();i++){
            int c=s[i]-'a';
            if(!nex[p][c]){
                nex[p][c]=++cnt;
            }
            p=nex[p][c];
        }
        exist[p]=1;
    }
    inline bool find(string s){
        int p=0;
        for(int i=0;i&lt;s.size();i++){
            int c=s[i]-'a';
            if(!nex[p][c]){
                return 0;
            }
            p=nex[p][c];
        }
        return exist[p];
    }
};
</code></pre>
<h2 id="kmp">kmp</h2>
<pre><code class="language-cpp">struct KMP {
    vector&lt;int&gt; getP(string s1) { //下标1开始
        int n = s1.size() - 1;
        int j = 0;
        vector&lt;int&gt; p(n + 1);
        for (int i = 1; i &lt; n; i++) {
            while (j &gt; 0 &amp;&amp; s1[i + 1] != s1[j + 1]) j = p[j];
            if (s1[i + 1] == s1[j + 1]) j++;
            p[i + 1] = j;
        }
        return p;
    }
    int solve(string s1, string s2) { //下标从0开始
        s1 = &quot; &quot; + s1;
        s2 = &quot; &quot; + s2;
        int n = s1.size() - 1;
        int m = s2.size() - 1;
        vector&lt;int&gt; p = getP(s2);
        int j = 0;
        int res = 0;
        for (int i = 0; i &lt; n; i++) {
            while (j &gt; 0 &amp;&amp; s1[i + 1] != s2[j + 1]) j = p[j];
            if (s1[i + 1] == s2[j + 1]) j++;
            if (j == m) {
                res += 1;
                j = p[j];
            }
        }
        return res;
    }
} kmp;
</code></pre>
<h2 id="manacher">Manacher</h2>
<pre><code class="language-cpp">struct Manacher {
    int d1[MaxN], d2[MaxN], d[MaxN];
    char s1[MaxN];
    void solve(string ss) {
        int N = ss.size() - 1;
        for (int i = 1; i &lt;= 2 * N; i++) {
            d1[i] = d2[i] = 0;
        }
        s1[1] = '#';
        for (int i = 1; i &lt;= N; i++) {
            s1[i &lt;&lt; 1] = ss[i];
            s1[i &lt;&lt; 1 | 1] = '#';
        }
        N = 2 * N + 1;
        for (int i = 1, l = 1, r = 0; i &lt;= N; i++) {
            int k = (i &gt; r) ? 1 : min(d[l + r - i], r - i + 1);
            while (1 &lt;= i - k &amp;&amp; i + k &lt;= N &amp;&amp; s1[i - k] == s1[i + k])
                k++;
            d[i] = k--;
            if (i + k &gt; r) {
                l = i - k;
                r = i + k;
            }
        }
        for (int i = 2; i &lt;= N; i++) {
            if (i % 2 == 0) {
                int t = (d[i] / 2 - 1) * 2 + 1;
                d1[i / 2] = t;
            } else {
                int t = (d[i] - 1);
                d2[i / 2 + 1] = t;
            }
        }
    }
} Manacher;
</code></pre>
<h2 id="kmpz">【模板】扩展 KMP（Z 函数）</h2>
<h3 id="_90">题目描述</h3>
<p>给定两个字符串 $a,b$，你要求出两个数组：</p>
<ul>
<li>$b$ 的 $z$ 函数数组 $z$，即 $b$ 与 $b$ 的每一个后缀的 LCP 长度。</li>
<li>$b$ 与 $a$ 的每一个后缀的 LCP 长度数组 $p$。</li>
</ul>
<p>对于一个长度为 $n$ 的数组 $a$，设其权值为 $\operatorname{xor}_{i=1}^n i \times (a_i + 1)$。</p>
<h3 id="_91">输入格式</h3>
<p>两行两个字符串 $a,b$。<br />
$z[i]$表示从$i$开始和从头开始匹配，一样的部分有多长。 </p>
<pre><code class="language-cpp">inline void getz()
{
    z[1]=len2;
    int l=0,r=0;
    for(int i=2;i&lt;=len2;i++)
    {
        if(i&gt;r)
        {
            while(s2[z[i]+1]==s2[z[i]+i]) z[i]++;
            l=i;r=z[i]+i-1;
        }
        else if(z[i-l+1]&lt;r-i+1)
        {
            z[i]=z[i-l+1];
        }
        else
        {
            z[i]=r-i;
            while(s2[z[i]+1]==s2[z[i]+i]) z[i]++;
            l=i;r=z[i]+i-1;
        }
    }
}
inline void getp()
{
    int l=0,r=0;
    for(int i=1;i&lt;=len1;i++)
    {
        if(i&gt;r)
        {
            while(p[i]+1&lt;=len2&amp;&amp;p[i]+i&lt;=len1&amp;&amp;
            s2[p[i]+1]==s1[p[i]+i]) p[i]++;
            l=i;r=p[i]+i-1;
        }
        else if(z[i-l+1]&lt;r-i+1)
        {
            p[i]=z[i-l+1];
        }
        else
        {
            p[i]=r-i;
            while(p[i]+1&lt;=len2&amp;&amp;
            p[i]+i&lt;=len1&amp;&amp;s2[p[i]+1]==s1[p[i]+i]) p[i]++;
            l=i;r=p[i]+i-1;
        }
    }
}
</code></pre>
<h2 id="_92">后缀数组</h2>
<pre><code class="language-cpp">struct SA {
    int sa[MaxN], rk[MaxN], oldrk[MaxN &lt;&lt; 1], id[MaxN], key1[MaxN], cnt[MaxN], height[MaxN];
    int st[MaxN][25], logn[MaxN];
    int n;
    void init(string s1, int _n) {
        n = _n;
        for (int i = 0; i &lt;= max(n + 1, 127); i++) {
            sa[i] = 0;
            rk[i] = 0;
            oldrk[i] = 0;
            id[i] = 0;
            key1[i] = 0;
            cnt[i] = 0;
            height[i] = 0;
        }
        getsa(s1);
        getheight(s1);
    }
    bool cmp(int x, int y, int w) {
        return oldrk[x] == oldrk[y] &amp;&amp; oldrk[x + w] == oldrk[y + w];
    }
    inline void getsa(string s) {
        int i, m = 127, p, w;
        // sa[i]表示后缀排序第i小的编号
        // rk[i]表示后缀i的排名
        for (i = 1; i &lt;= n; ++i) ++cnt[rk[i] = s[i]];
        for (i = 1; i &lt;= m; ++i) cnt[i] += cnt[i - 1];
        for (i = n; i &gt;= 1; --i) sa[cnt[rk[i]]--] = i;

        for (w = 1;; w &lt;&lt;= 1, m = p) { // m=p 就是优化计数排序值域
            for (p = 0, i = n; i &gt; n - w; --i) id[++p] = i;
            for (i = 1; i &lt;= n; ++i) 
                if (sa[i] &gt; w) id[++p] = sa[i] - w;
            memset(cnt, 0, (m + 1) * sizeof(int));
            for (i = 1; i &lt;= n; ++i) ++cnt[key1[i] = rk[id[i]]];
            // 注意这里px[i] != i，因为rk没有更新，是上一轮的排名数组

            for (i = 1; i &lt;= m; ++i) cnt[i] += cnt[i - 1];
            for (i = n; i &gt;= 1; --i) sa[cnt[key1[i]]--] = id[i];
            memcpy(oldrk + 1, rk + 1, n * sizeof(int));
            for (p = 0, i = 1; i &lt;= n; ++i) rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;
            if (p == n) break;
        }
    }
    inline void getheight(string s){
        // height[i]=lcp(sa[i],sa[i-1])
        int i, k;
        for (i = 1, k = 0; i &lt;= n; ++i) {
            if (rk[i] == 0) continue;
            if (k) --k;
            while (i + k &lt;= n &amp;&amp; sa[rk[i] - 1] + k &lt;= n &amp;&amp; s[i + k] == s[sa[rk[i] - 1] + k]) ++k;
            height[rk[i]] = k;
        }
    }
    inline void pre() {
        logn[0] = -1;
        for (int i = 1; i &lt;= n; i++) logn[i] = logn[i / 2] + 1;
        for (int i = 1; i &lt;= n; i++) st[i][0] = height[i];
        for (int j = 1; j &lt;= 20; j++) {
            int pj = 1 &lt;&lt; (j - 1);
            for (int i = 1; i &lt;= n; i++) {
                if (i + pj &lt;= n)
                    st[i][j] = min(st[i][j - 1], st[i + pj][j - 1]);
                else
                    st[i][j] = st[i][j - 1];
            }
        }
    }
    inline int lcp(int l, int r) {
        if (l == r) return n - l + 1;
        l = rk[l];
        r = rk[r];
        if (l &gt; r) swap(l, r);
        l++;
        int lp = r - l + 1;
        int n = 1 &lt;&lt; logn[lp];
        return min(st[l][logn[lp]], st[r - n + 1][logn[lp]]);
    }
} SA;
</code></pre>
<h2 id="sam">【模板】后缀自动机（SAM）</h2>
<h4 id="_93">题目描述</h4>
<p>给定一个只包含小写字母的字符串 $S$。</p>
<p>请你求出 $S$ 的所有出现次数不为 $1$ 的子串的出现次数乘上该子串长度的最大值。</p>
<h4 id="_94">输入格式</h4>
<p>一行一个仅包含小写字母的字符串 $S$。</p>
<h4 id="_95">输出格式</h4>
<p>一个整数，为所求答案。</p>
<h4 id="1_23">样例 #1</h4>
<h5 id="1_24">样例输入 #1</h5>
<pre><code>abab
</code></pre>
<h5 id="1_25">样例输出 #1</h5>
<pre><code>4
</code></pre>
<h3 id="sam_1">后缀自动机(SAM)</h3>
<pre><code class="language-cpp">struct SAM {
    struct Point { // 2 * MaxN
        int ch[26];
        int len, fa;
        int firstPos;
    } tree[MaxN];
    int tot = 1, last = 1, F[MaxN], id[MaxN];
    inline void clear() {
        for (int i = 0; i &lt;= tot; i++) {
            F[i] = 0;
            tree[i].len = tree[i].fa = tree[i].firstPos = 0;
            memset(tree[i].ch, 0, sizeof(tree[i].ch));
        }
        tot = 1; last = 1;
    }
    void add1(int c) {
        int p = last, np = last = ++tot;
        F[tot] = 1;
        tree[np].len = tree[p].len + 1;
        tree[np].firstPos = tree[np].len - 1;
        for (; p &amp;&amp; !tree[p].ch[c]; p = tree[p].fa) {
            tree[p].ch[c] = np;
        } 
        if (!p) {
            tree[np].fa = 1;
        } else {
            int q = tree[p].ch[c]; 
            if (tree[q].len == tree[p].len + 1) {
                tree[np].fa = q;
            } else {
                int nq = ++tot;
                tree[nq] = tree[q];
                tree[nq].len = tree[p].len + 1;
                tree[q].fa = tree[np].fa = nq;
                for (; p &amp;&amp; tree[p].ch[c] == q; p = tree[p].fa) {
                    tree[p].ch[c] = nq;
                }
            }
        }
    }
    void sort1() {
        vector&lt;int&gt; vis(tot + 1);
        for (int i = 1; i &lt;= tot; i++) vis[tree[i].len]++;
        for (int i = 1; i &lt;= tot; i++) vis[i] += vis[i - 1];
        for (int i = tot; i &gt;= 1; i--) id[vis[tree[i].len]--] = i;
    }
    void insert(string s1) {
        for (auto x : s1) {
            add1(x - 'A');
        }
    }
    int getF() { //出现次数
        int ans = 0;
        sort1();
        for (int i = tot; i &gt;= 1; i--) {
            int t = id[i];
            F[tree[t].fa] += F[t];
            if (F[t] &gt; 1) ans = max(ans, F[t] * tree[t].len);
        }
        return ans;
    }
    pair&lt;int, int&gt; getMinOne() { //出现一次最短的字符串长度和位置
        getF();
        int len = INF, p = 0;
        for (int i = tot; i &gt;= 1; i--) {
            int x = id[i], f = tree[x].fa;
            if (F[x] != 1) continue;
            if (tree[f].len + 1 &lt; len) {
                len = tree[f].len + 1;
                p = tree[x].firstPos;
            } else if (tree[f].len + 1 == len) {
                p = min(p, tree[x].firstPos);
            }
        }
        return make_pair(len, p);
    }
} SAM;
</code></pre>
<h3 id="exsam">EXSAM</h3>
<pre><code class="language-cpp">struct EXSAM {
    struct Point { // 2 * MaxN
        int ch[26];
        int len, fa;
    } tree[MaxN];
    int tot = 1, F[MaxN], id[MaxN];
    int vis[MaxN][10];
    inline void clear() {
        for (int i = 0; i &lt;= tot; i++) {
            F[i] = 0;
            tree[i].len = tree[i].fa = 0;
            memset(tree[i].ch, 0, sizeof(tree[i].ch));
        }
        tot = 1;
        T = 0;
    }
    int add1(int last, int c) {
        int p = tree[last].fa, np = tree[last].ch[c];
        if (tree[np].len) return np;
        tree[np].len = tree[last].len + 1;
        for (; p &amp;&amp; !tree[p].ch[c]; p = tree[p].fa) {
            tree[p].ch[c] = np;
        } 
        if (!p) {
            tree[np].fa = 1;
        } else {
            int q = tree[p].ch[c]; 
            if (tree[q].len == tree[p].len + 1) {
                tree[np].fa = q;
            } else {
                int nq = ++tot;
                tree[nq] = tree[q];
                for (int i = 0; i &lt; 26; ++i)
                    tree[nq].ch[i] = tree[tree[q].ch[i]].len? tree[q].ch[i] : 0;
                tree[nq].len = tree[p].len + 1;
                tree[q].fa = tree[np].fa = nq;
                for (; p &amp;&amp; tree[p].ch[c] == q; p = tree[p].fa) {
                    tree[p].ch[c] = nq;
                }
            }
        }
        return np;
    }
    int insertTire(int x, int c) {
        if (!tree[x].ch[c]) tree[x].ch[c] = ++tot;
        vis[tree[x].ch[c]][T] = 1;
        return tree[x].ch[c];
    }
    void insert(string s1) {
        int root = 1;
        for (auto x : s1) {
            root = insertTire(root, x - 'a');
        }
        T++;
    }
    void build() {
        queue&lt;pair&lt;int, int&gt;&gt; q;
        for (int i = 0; i &lt; 26; i++) {
            if (tree[1].ch[i]) q.push(make_pair(i, 1));
        }
        while (!q.empty()) {
            auto now = q.front(); q.pop();
            auto last = add1(now.second, now.first);
            for (int i = 0; i &lt; 26; i++) {
                if (tree[last].ch[i]) q.push(make_pair(i, last));
            }
        }
    }
    void sort1() {
        vector&lt;int&gt; vis(tot + 1);
        for (int i = 1; i &lt;= tot; i++) vis[tree[i].len]++;
        for (int i = 1; i &lt;= tot; i++) vis[i] += vis[i - 1];
        for (int i = tot; i &gt;= 1; i--) id[vis[tree[i].len]--] = i;
    }
    int solve() {
        int ans = 0;
        sort1();
        for (int t = tot; t &gt;= 1; t--) {
            int i = id[t], now = tree[i].len - tree[tree[i].fa].len;
            for (int j = 0; j &lt; T; j++) {
                vis[tree[i].fa][j] += vis[i][j];
                now *= vis[i][j];
            }
            ans += now;
        }
        return ans;
    }
} EXSAM;
</code></pre>
<pre><code class="language-cpp">struct EXSAM {
    struct Point { // 2 * MaxN
        map&lt;int, int&gt; ch;
        int len, fa;
    } tree[MaxN];
    int tot = 1, F[MaxN], id[MaxN];
    int vis[MaxN][10];
    inline void clear() {
        for (int i = 0; i &lt;= tot; i++) {
            F[i] = 0;
            tree[i].len = tree[i].fa = 0;
            tree[i].ch.clear();
        }
        tot = 1;
    }
    int add1(int last, int c) {
        int p = last, np = last = ++tot;
        F[tot] = 1;
        tree[np].len = tree[p].len + 1;
        for (; p &amp;&amp; !tree[p].ch[c]; p = tree[p].fa) {
            tree[p].ch[c] = np;
        } 
        if (!p) {
            tree[np].fa = 1;
        } else {
            int q = tree[p].ch[c]; 
            if (tree[q].len == tree[p].len + 1) {
                tree[np].fa = q;
            } else {
                int nq = ++tot;
                tree[nq] = tree[q];
                tree[nq].len = tree[p].len + 1;
                tree[q].fa = tree[np].fa = nq;
                for (; p &amp;&amp; tree[p].ch[c] == q; p = tree[p].fa) {
                    tree[p].ch[c] = nq;
                }
            }
        }
        return np;
    }
    void insert(string s1) {
        int root = 1;
        for (auto x : s1) {
            root = add1(root, x);
        }
    }
    void sort1() {
        vector&lt;int&gt; vis(tot + 1);
        for (int i = 1; i &lt;= tot; i++) vis[tree[i].len]++;
        for (int i = 1; i &lt;= tot; i++) vis[i] += vis[i - 1];
        for (int i = tot; i &gt;= 1; i--) id[vis[tree[i].len]--] = i;
    }
    int solve() {
        int ans = 0;
        // sort1();
        for (int i = tot; i &gt;= 2; i--) {
            int t = i;
            ans += tree[t].len - tree[tree[t].fa].len;
        }
        return ans;
    }
} EXSAM;
</code></pre>
<h3 id="_96">最长公共子串</h3>
<pre><code class="language-cpp">    void build() {
        sort1();
        for (int i = 1; i &lt;= tot; i++) {
            minn[i] = INF;
        }
    }
    // 求多个字符串最长公共字串，将第一个字符串建SAM，其余solve，最后一个为答案
    int solve(string s1) {
        int x = 1, len = 0;
        for (auto c : s1) {
            while (1) {
                if (tree[x].ch[c]) {
                    x = tree[x].ch[c];
                    len++;
                    break;
                }
                if (!len) break;;
                if (--len == tree[tree[x].fa].len) {
                    x = tree[x].fa;
                }
            }
            if (x) {
                maxn[x] = max(maxn[x], len);
            }
        }
        int ans = 0;
        for (int i = tot; i &gt;= 1; i--) {
            int x = id[i], fa = tree[x].fa;
            maxn[fa] = max(maxn[fa], min(tree[fa].len, maxn[x]));
            minn[x] = min(minn[x], maxn[x]);
            maxn[x] = 0;
            ans = max(ans, minn[x]);
        }
        return ans;
    }
</code></pre>
<h2 id="_97">回文自动机（回文树）</h2>
<pre><code class="language-cpp">struct Pam {
    int sz, tot, last;
    int cnt[MaxN], ch[MaxN][26], len[MaxN], fail[MaxN];
    char s[MaxN];
    int node(int l) {  // 建立一个新节点，长度为 l
        sz++;
        memset(ch[sz], 0, sizeof(ch[sz]));
        len[sz] = l;
        fail[sz] = cnt[sz] = 0;
        return sz;
    }

    void clear() {  // 初始化
        sz = -1;
        last = 0;
        s[tot = 0] = '$';
        node(0);
        node(-1);
        fail[0] = 1;
    }

    int getfail(int x) {  // 找后缀回文
        while (s[tot - len[x] - 1] != s[tot]) x = fail[x];
        return x;
    }

    void insert(char c) {  // 建树
        s[++tot] = c;
        int now = getfail(last);
        if (!ch[now][c - 'a']) {
            int x = node(len[now] + 2);
            fail[x] = ch[getfail(fail[now])][c - 'a'];
            ch[now][c - 'a'] = x;
        }
        last = ch[now][c - 'a'];
        cnt[last]++;
    }

    int Solve() {
        for (int i = sz; i &gt;= 0; i--) {
            cnt[fail[i]] += cnt[i];
        }
        int ans = 0;
        for (int i = 1; i &lt;= sz; i++) {
            ans = max(ans, cnt[i] * len[i]);
        }
        return ans;
    }
} pam;

struct Pam {
    int sz, tot, last, num;
    int cnt[MaxN], len[MaxN], fail[MaxN];
    int fir[MaxN], nex[MaxN], go[MaxN], w[MaxN];
    int pos[MaxN];
    char s[MaxN];
    inline void add1(int x, int y, int z) {
        nex[++num] = fir[x];
        fir[x] = num;
        go[num] = y;
        w[num] = z;
    }
    inline int get(int x ,int y) {
        for (int i = fir[x]; i; i = nex[i]) {
            if (go[i] == y) return w[i];
        }
        return 0;
    }
    int node(int l) {  // 建立一个新节点，长度为 l
        sz++;
        len[sz] = l;
        fail[sz] = cnt[sz] = 0;
        return sz;
    }
    void clear() {  // 初始化
        sz = -1;
        last = 0;
        s[tot = 0] = '$';
        node(0);
        node(-1);
        fail[0] = 1;
        memset(fir, 0, sizeof fir);
        num = 0;
    }

    int getfail(int x) {  // 找后缀回文
        while (s[tot - len[x] - 1] != s[tot]) x = fail[x];
        return x;
    }

    void insert(char c) {  // 建树
        s[++tot] = c;
        int now = getfail(last);
        if (!get(now, c - 'a')) {
            int x = node(len[now] + 2);
            fail[x] = get(getfail(fail[now]), c - 'a');
            add1(now, c - 'a', x);
        }
        last = get(now, c - 'a');
        cnt[last] = cnt[fail[last]] + 1;
        pos[tot] = cnt[last];
    }
} pam;
</code></pre>
<h2 id="acacm">AC自动机(ACM)</h2>
<pre><code class="language-cpp">struct ACM {
    // flag: 这个点和他的nex包含不包含模式串
    // bo: 这个点包含哪几个字符串
    // vis 对应串出现次数
    // rev: 第i个字符串对应的节点
    struct Point {
        int nex;
        vector&lt;int&gt; bo;
        int ch[26];
    } tree[MaxN];
    int flag[MaxN], in[MaxN], ans[MaxN], rev[MaxN], vis[MaxN];
    int cnt;
    void clear() {
        for (int i = 0; i &lt;= cnt; i++) {
            tree[i].nex = 0;
            tree[i].bo.clear();
            memset(tree[i].ch, 0, sizeof tree[i].ch);
            flag[i] = 0;
            in[i] = 0;
            rev[i] = 0;
            vis[i] = 0;
            ans[i] = 0;
        }
        cnt = 1;
    }
    void insert(string s1, int num) {
        int u = 1;
        for (int i = 0; i &lt; (int)s1.size(); i++) {
            int c = s1[i] - 'a';
            if (!tree[u].ch[c]) {
                tree[u].ch[c] = ++cnt;
            }
            u = tree[u].ch[c];
        }
        tree[u].bo.push_back(num);
        rev[num] = u;
        flag[u] = 1;
    }
    void bfs() {
        for (int i = 0; i &lt; 26; i++) {
            tree[0].ch[i] = 1;
        }
        queue&lt;int&gt; q;
        q.push(1);
        tree[1].nex = 0;
        while (!q.empty()) {
            auto u = q.front(); q.pop();
            for (int i = 0; i &lt; 26; i++) {
                if (!tree[u].ch[i]) tree[u].ch[i] = tree[tree[u].nex].ch[i];
                else {
                    q.push(tree[u].ch[i]);
                    int v = tree[u].nex;
                    tree[tree[u].ch[i]].nex = tree[v].ch[i];
                    flag[tree[u].ch[i]] += flag[tree[v].ch[i]];
                    in[tree[v].ch[i]]++;
                }
            }
        }
    }
    void topu() {
        vector&lt;int&gt; indeg(cnt + 1);
        queue&lt;int&gt; q;
        for (int i = 1; i &lt;= cnt; i++) {
            indeg[i] = in[i];
            if (!indeg[i]) q.push(i);
        }
        while (!q.empty()) {
            int x = q.front(); q.pop();
            int y = tree[x].nex;
            for (auto t : tree[x].bo) {
                vis[t] = ans[x];
            }

            ans[y] += ans[x];
            indeg[y]--;
            if (!indeg[y]) {
                q.push(y);
            }

        }
    }
    void query(string ss) {
        int u = 1;
        for (int i = 0; i &lt; ss.size(); i++) {
            int c = ss[i] - 'a';
            u = tree[u].ch[c];
            ans[u]++;
        }
    }

} ACM;
inline void Solve() {
    cin &gt;&gt; N;
    ACM.clear();
    for (int i = 1; i &lt;= N; i++) {
        cin &gt;&gt; s1;
        ACM.insert(s1, i);
    }
    ACM.bfs();
    cin &gt;&gt; s1;
    ACM.query(s1);
    ACM.topu();
    for (int i = 1; i &lt;= N; i++) {
        cout &lt;&lt; ACM.vis[i] &lt;&lt; endl;
    }
}
</code></pre>
<h1 id="_98">图论</h1>
<h2 id="tarjan">tarjan</h2>
<pre><code class="language-cpp">int st[MaxN], top, col, co[MaxN], num, dfn[MaxN], low[MaxN];
vector&lt;int&gt; G1[MaxN], G2[MaxN];
struct Point {
    int x, y;
} b[MaxN]; // 注意边需要存到b里面
int F[MaxN], ans[MaxN];
inline void tarjan(int x) {
    dfn[x] = low[x] = ++num;
    st[++top] = x;
    for (int i = 0; i &lt; (int)G1[x].size(); i++) {
        int y = G1[x][i];
        if (!dfn[y]) {
            tarjan(y);
            low[x] = min(low[x], low[y]);
        }
        else if (!co[y]) {
            low[x] = min(low[x], dfn[y]);
        }
    }
    if (low[x] == dfn[x]) {
        co[x] = ++col;
        while (st[top] != x) {
            co[st[top]] = col;
            top--;
        }
        top--;
    }
}
inline void solve() {
    for (int i = 1; i &lt;= N; i++) {
        if (!dfn[i]) tarjan(i);
    }
    for (int i = 1; i &lt;= M; i++) {
        auto [x, y] = b[i];
        if (co[x] != co[y]) {
            G2[co[y]].push_back(co[x]);
            in[co[x]]++;
        }
    }
    for (int i = 1; i &lt;= N; i++) {
        c[co[i]] += a[i];
        sum[co[i]]++;
    }
    queue&lt;int&gt; q;
    for (int i = 1; i &lt;= col; i++) {
        if (!in[i]) q.push(i);
    }

    while (!q.empty()) {
        int x = q.front(); q.pop();
        for (auto y : G2[x]) {
            in[y]--;
            if (!in[y]) {
                q.push(y);
            }
        }
    }
}
</code></pre>
<h2 id="_99">模板】单源最短路径（标准版）</h2>
<pre><code class="language-cpp">struct Dijkstra{
    int d[MaxN], vis[MaxN];
    struct Point {
        int id, x;
        inline bool operator&lt;(const Point &amp;aa)const {
            return x &gt; aa.x;
        }
    };
    priority_queue&lt;Point&gt;q;
    inline void solve(int S) {
        for(int i = 1; i &lt;= N; i++) d[i] = INF, vis[i] = 0;

        d[S] = 0;
        q.push((Point){ S, 0 });
        while(!q.empty()) {
            auto [x, w] = q.top(); q.pop();
            if (vis[x]) continue;
            vis[x] = 1;
            for(auto it : G1[x]) {
                int y = it.first;
                int z = it.second;
                if(d[x] + z &lt; d[y]) {
                    d[y] = d[x] + z;
                    if(!vis[y])  q.push((Point){ y, d[y] });
                }
            }
        }
    }
} dij;
</code></pre>
<h2 id="ek">EK费用流处理负环</h2>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
#define int ll
#define lowbit(x) (x)&amp;(-x)
#define zuo p&lt;&lt;1
#define you p&lt;&lt;1|1
#define INF 9187201950435737471
const int MaxN=1e5+100;
int a[51][51],N,M,s,t,K,st,tt;
int fir[MaxN],nex[MaxN],go[MaxN],tot=1,w[MaxN],v[MaxN];
int ans,incf[MaxN],d[MaxN],vis[MaxN],pre[MaxN],maxn,ts,ans1,total[MaxN];
template&lt;class T&gt;
inline void qread(T &amp;sum)
{
    sum=0;int boo=1;
    char x=getchar();
    while(x&lt;'0'||x&gt;'9'){if(x=='-')boo=-1;x=getchar();}
    while(x&gt;='0'&amp;&amp;x&lt;='9'){sum=(sum&lt;&lt;1)+(sum&lt;&lt;3)+x-'0';x=getchar();}
    sum*=boo;
}
template&lt;class T&gt;
void qput(T x)
{
    if(x&lt;0) {x=-x;putchar('-');}
    if(x&gt;9){qput(x/10);}
    putchar(x%10+48);
}
inline void add1(int x,int y,int z,int k)
{
    nex[++tot]=fir[x];fir[x]=tot;go[tot]=y;w[tot]=z;v[tot]=k;
    nex[++tot]=fir[y];fir[y]=tot;go[tot]=x;w[tot]=0;v[tot]=-k;
}
inline bool spfa(int s,int t)
{
    queue&lt;int&gt;q;
    memset(d,127,sizeof d);
    memset(vis,0,sizeof v);
    q.push(s);d[s]=0;vis[s]=1;
    incf[s]=INF;
    while(!q.empty())
    {
        int x=q.front();q.pop();
        vis[x]=0;
        for(int i=fir[x];i;i=nex[i])
        {
            int y=go[i],z=w[i],k=v[i];
            if(z&amp;&amp;d[x]+k&lt;d[y])
            {
                d[y]=d[x]+k;
                incf[y]=min(incf[x],z);
                pre[y]=i;
                if(!vis[y])
                {
                    vis[y]=1;
                    q.push(y);
                }
            }
        }
    }
    if(d[t]&gt;=INF) return 0;
    return 1;
}
inline void updata(int s,int t)
{
    int x=t;
    ans=0;
    while(x!=s)
    {
        int i=pre[x];
        ans+=v[i];
        w[i]-=incf[t];
        w[i^1]+=incf[t];
        x=go[i^1];
    }
    maxn+=incf[t]*ans;
    ans1+=incf[t];
}
signed main()
{
    qread(N);qread(M);
    qread(s);qread(t);
    st=N+1;tt=N+2;
    for(int i=1;i&lt;=M;i++)
    {
        int x,y,z,k;
        qread(x);qread(y);qread(z);qread(k);
        if(k&gt;=0)
        add1(x,y,z,k);
        else
        {
            add1(y,x,z,-k);
            total[x]-=z;total[y]+=z;
            maxn+=k*z;
        }
    }
    for(int i=1;i&lt;=N;i++)
    {
        if(!total[i]) continue;
        if(total[i]&gt;0)
        {
            add1(st,i,total[i],0);
        }
        else
        {
            add1(i,tt,-total[i],0);
        }
    }
    while(spfa(st,tt)) updata(st,tt);
    ans1=0;
    while(spfa(s,t)) updata(s,t);
    qput(ans1);putchar(' ');
    qput(maxn);putchar('\n');
}
</code></pre>
<h2 id="dinic">最大流（dinic）</h2>
<pre><code class="language-cpp">struct wll {
    int  s, t;
    int fir[MaxN], nex[MaxN], go[MaxN], w[MaxN] , tot = 1;
    int d[MaxN], v[MaxN], cur[MaxN];
    void clear() {
        for (int i = s; i &lt;= t; i++) {
            fir[i] = 0;
        }
        tot = 1;
    }
    void add1(int x, int y, int z) {
        nex[++tot] = fir[x]; fir[x] = tot; go[tot] = y; w[tot] = z;
        nex[++tot] = fir[y]; fir[y] = tot; go[tot] = x; w[tot] = 0;
    }
    inline bool bfs() {
        for (int i = s; i &lt;= t; i++) {
            d[i] = 0;
        }
        queue&lt;int&gt; q;
        q.push(s); d[s] = 1;
        cur[s] = fir[s];
        while (!q.empty()) {
            int x = q.front(); q.pop();
            for (int i = fir[x]; i; i = nex[i]) {
                int y = go[i], z = w[i];
                if (z &amp;&amp; !d[y]) {
                    cur[y] = fir[y];
                    d[y] = d[x] + 1;
                    q.push(y);
                    if (y == t) return 1;
                }
            }
        }
        return 0;
    }
    int dinic(int x, int flow) {
        if (x == t) return flow;
        int rest = flow, k;
        for (int i = cur[x]; i &amp;&amp; rest; i = nex[i]) {
            int y = go[i], z = w[i];
            cur[x] = i;
            if (z &amp;&amp; d[y] == d[x] + 1) {
                k = dinic(y, min(rest, w[i]));
                if (!k) d[y] = 0;
                w[i] -= k;
                w[i ^ 1] += k;
                rest -= k;
            }
        }
        return flow - rest;
    }
    vector&lt;int&gt; vis1, vis2;
    void dfs1(int x) {
        vis1[x] = 1; 
        for (int i = fir[x]; i; i = nex[i]) {
            int y = go[i], z = w[i];
            if (vis1[y]) continue;
            if (z) {
                dfs1(y);
            }
        }
    }
    void dfs2(int x) {
        vis2[x] = 1; 
        for (int i = fir[x]; i; i = nex[i]) {
            int y = go[i], z = w[i];
            if (vis2[y]) continue;
            if (!z) {
                dfs2(y);
            }
        }
    }
    int solve() {
        int ans = 0, flow;
        while (bfs()) {
            while (flow = dinic(s, INF)) ans += flow;
        }
        return ans;
    }
} di;
</code></pre>
<h2 id="_100">费用流</h2>
<pre><code class="language-cpp">struct fyl {
    int fir[MaxN], nex[MaxN], go[MaxN], w[MaxN], v[MaxN], tot = 1;
    int d[MaxN], vis[MaxN], incf[MaxN], pre[MaxN];
    int s, t;
    int minn, ans; // 流量， 费用
    inline void add1(int x, int y, int z, int k) {
        nex[++tot] = fir[x]; fir[x] = tot; go[tot] = y; w[tot] = z; v[tot] = k;
        nex[++tot] = fir[y]; fir[y] = tot; go[tot] = x; w[tot] = 0; v[tot] = -k;
    }
    inline bool bfs() {
        queue&lt;int&gt; q;
        memset(d, 127, sizeof d);
        memset(vis, 0, sizeof vis);
        q.push(s);
        d[s] = 0;
        vis[s] = 1;
        incf[s] = INF;
        while (!q.empty()) {
            int x = q.front(); q.pop();
            vis[x] = 0;
            for (int i = fir[x]; i; i = nex[i]) {
                int y = go[i], z = w[i], k = v[i];
                if (z &amp;&amp; d[x] + k &lt; d[y]) {
                    d[y] = d[x] + k;
                    incf[y] = min(incf[x], z);
                    pre[y] = i;
                    if (!vis[y]) {
                        vis[y] = 1;
                        q.push(y);
                    }
                }
            }
        }
        if (d[t] == INF) return 0;
        return 1;
    }
    inline void updata() {
        int x = t;
        int sum = 0;
        while (x != s) {
            int i = pre[x];
            sum += v[i];
            w[i] -= incf[t];
            w[i ^ 1] += incf[t];
            x = go[i ^ 1];
        }
        ans += sum * incf[t];
        minn += incf[t];
    }
    inline pair&lt;int, int&gt; solve() {
        while (bfs()) updata();
        return make_pair(minn, ans);
    }
} fyl;
</code></pre>
<h2 id="2-sat">2-SAT</h2>
<pre><code class="language-cpp">struct TwoSat {
    int st[MaxN], top, col, co[MaxN], num, dfn[MaxN], low[MaxN];
    vector&lt;int&gt; G1[MaxN];
    int N;
    void clear(int n) {
        col = top = num = 0;
        for (int i = 0; i &lt;= 2 * n; i++) {
            st[i] = co[i] = dfn[i] = low[i] = 0;
            G1[i].clear();
        }
    }
    void init(int n) {
        clear(n);
        N = n;
    }

    inline void tarjan(int x) {
        dfn[x] = low[x] = ++num;
        st[++top] = x;
        for (auto y : G1[x]) {
            if (!dfn[y]) {
                tarjan(y);
                low[x] = min(low[x], low[y]);
            }
            else if (!co[y]) {
                low[x] = min(low[x], dfn[y]);
            }
        }
        if (low[x] == dfn[x]) {
            co[x] = ++col;
            while (st[top] != x) {
                co[st[top]] = col;
                top--;
            }
            top--;
        }
    }
    int inv(int x) {
        if (x &gt; N) return x - N;
        return x + N;
    }
    void insert(int x, int y) {
        G1[x].push_back(y);
    }
    void add1(int x, int y) { //蕴含关系
        G1[x].push_back(y);
        G1[inv(y)].push_back(inv(x));
    }
    void equal(int x, int y) {
        add1(x, y);
        add1(inv(x), inv(y));
    }
    void unequal(int x, int y) {
        add1(x, inv(y));
        add1(inv(x), y);
    }
    void either(int x, int y) {
        G1[inv(x)].push_back(y);
        G1[inv(y)].push_back(x);
    }
    void equalTrue(int x) { //设x为真
        G1[inv(x)].push_back(x);
    }
    bool run() {
        for (int i = 1; i &lt;= 2 * N; i++) {
            if (!dfn[i]) tarjan(i);
        }
        for (int i = 1; i &lt;= N; i++) {
            if (co[i] == co[i + N]) return 0;
        }
        return 1;
    }
    vector&lt;int&gt; query() {
        vector&lt;int&gt; now(N);
        for (int i = 1; i &lt;= N; i++) {
            now[i - 1] = co[i] &lt; co[inv(i)];
        }
        return now;
    }
} TS;
</code></pre>
<h1 id="dp">dp</h1>
<h2 id="_101">斜率优化</h2>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
#define lowbit(x) (x)&amp;(-x)
#define zuo p&lt;&lt;1
#define you p&lt;&lt;1|1
#define INF 2147483647
const int MaxN=1e6+100;
int N,M,l,r;
ll a,b,c,sum[MaxN],F[MaxN],q[MaxN];
double js(int x,int y)
{
    double sum1=-b*sum[y]+a*sum[y]*sum[y]+F[y]-
    (-b*sum[x]+a*sum[x]*sum[x]+F[x]);
    double sum2=sum[y]-sum[x];
    return sum1/sum2;
}
int main()
{
    qread(N);
    qread(a);qread(b);qread(c);
    memset(F,-127,sizeof F);
    F[0]=0;
    for(int i=1;i&lt;=N;i++)
    {
        qread(sum[i]);
        sum[i]+=sum[i-1];
    }
    l=r=1;
    q[l]=0;
    for(int i=1;i&lt;=N;i++)
    {
        while(l&lt;r&amp;&amp;js(q[l],q[l+1])&gt;2*a*sum[i]) l++;
        int j=q[l];
        F[i]=F[j]+a*(sum[i]-sum[j])*(sum[i]-sum[j])+
        b*(sum[i]-sum[j])+c;
        while(l&lt;r&amp;&amp;js(q[r-1],q[r])&lt;js(q[r],i)) r--;
        q[++r]=i;
    }
    qput(F[N]);
}
</code></pre>
<h1 id="_102">计算几何</h1>
<pre><code class="language-cpp">const ld eps = 1e-12;
struct Point {
    ld x, y;
    inline ld Rand() {
        return rand() / (ld)RAND_MAX;
    }
    inline void shake() {
        x += (Rand() - 0.5) * eps;
        y += (Rand() - 0.5) * eps;
    }
    inline bool operator &lt;(const Point &amp;aa) const{
        if (x != aa.x) return x &lt; aa.x;
        return y &lt; aa.y; 
    }
    inline double operator*(const Point &amp;aa) const {
        return x * aa.x + y * aa.y;
    }
    inline ld operator /(const Point &amp;aa) const {
        return x * aa.y - y * aa.x;
    }
    inline Point operator +(const Point &amp;aa) const {
        return (Point){aa.x + x, aa.y + y};
    }
    inline Point operator -(const Point &amp;aa) const {
        return (Point){x - aa.x, y - aa.y};
    }
    inline Point operator ^(const ld k) const {
        return (Point){x * k, y * k};
    }
    inline Point xz() {
        if (x &gt;= 0 &amp;&amp; y &gt;= 0)
            return (Point){-y, x};
        else if (x &lt; 0 &amp;&amp; y &gt; 0)
            return (Point){-y, x};
        else if (x &lt; 0 &amp;&amp; y &lt; 0)
            return (Point){-y, x};
        else
            return (Point){-y, x};
    }
    inline ld len() {
        return sqrt(x * x + y * y);
    }
};

inline bool same(ld x, ld y) { //判断相等
    if (fabs(x - y) &lt; eps) return 1;
    return 0;
}
inline bool cmp2(Point x, Point y) { //极角排序
    if (same(x / y, 0)) {
        return x.len() &lt; y.len();
    }
    return x / y &gt; 0;
}
</code></pre>
<h3 id="_103">二维凸包</h3>
<pre><code class="language-cpp">int st[MaxN], top;
vector&lt;Point&gt; tubao(vector&lt;Point&gt; a) {
    vector&lt;Point&gt; b;
    if (a.size() == 0) return b;
    for (int i = 0; i &lt; (int)a.size(); i++) {
        used[i] = 0;
    }
    sort(a.begin(), a.end());
    top = 0;
    st[++top] = 0;
    for (int i = 1; i &lt; (int)a.size(); i++) {
        while (top &gt;= 2 &amp;&amp; (a[st[top]] - a[st[top - 1]]) / (a[i] - a[st[top]]) &lt;= 0) {
            used[st[top--]] = 0;
        }
        used[i] = 1;
        st[++top] = i;
    }
    int tmp = top;
    for (int i = a.size() - 2; i &gt;= 0; i--) {
        if (!used[i]) {
            while (top &gt; tmp &amp;&amp; (a[st[top]] - a[st[top - 1]]) / (a[i] - a[st[top]]) &lt;= 0) {
                used[st[top--]] = 0;
            }
            used[i] = 1;
            st[++top] = i;
        }
    }
    for (int i = 1; i &lt;= top; i++) {
        b.push_back(a[st[i]]);
    }
    return b;
}
</code></pre>
<h3 id="_104">两直线交点</h3>
<pre><code class="language-cpp">Point add1(Point a1, Point a2, Point b1, Point b2) {
    Point t1 = a2 - a1;
    Point t2 = b2 - b1;
    Point t3 = b1 - a1;
    if (fabs(t2 / t1) &lt; esp) return (Point){ -1e9 , -1e9 };
    ld t = (t2 / t3) / (t2 / t1);
    t = max(t, -t);
    return a1 + (t1 ^ t);
}
</code></pre>
<h3 id="_105">判断在凸包内</h3>
<pre><code class="language-cpp">int in(Point x) {
    if (x / A[2] &gt; 0 || A[tot] / x &gt; 0) return 0;
    int ps = lower_bound(A + 1, A + 1 + tot, x, cmp2) - (A + 1);
    if (same((x - A[ps]) / (A[ps % tot + 1] - A[ps]), 0) &amp;&amp; ps == tot) {
        return x.len() &lt;= A[ps].len();
    }
    return (x - A[ps]) / (A[ps % tot + 1] - A[ps]) &lt;= 0;
}
</code></pre>
<h3 id="_106">多边形面积</h3>
<pre><code class="language-cpp">ld CalaS() {
    ld res = 0;
    for (int i = 3; i &lt;= top; i++) {
        res += (a[i - 1]  - a[1]) / (a[i] - a[1]);
    }
    return res / 2;
}
</code></pre>
<h3 id="_107">判断圆和线段有几个交点</h3>
<pre><code class="language-cpp">inline int check(Point x) { // 1 out
    ld len = (x - a[0]).len();
    if (same(len, K)) return 0;
    if (len &gt; K) return 1;
    if (len &lt; K) return -1;
    return 0;
}
inline int js(Point x, Point y) { //a[0] 是圆的坐标， K是半径
    ld dis = (a[0] - x) / (a[0] - y);
    dis = fabs(dis);
    dis /= (x - y).len();
    ld t1 = pd(x, y, a[0]);
    ld t2 = pd(y, x, a[0]);
    if (same(dis, K)) {
        if (t1 &lt; 0 || t2 &lt; 0) {
            return 0;
        }
        return 1;
    }
    if (dis &gt; K) return 0;
    if (check(x) == -1 &amp;&amp; check(y) == -1) return 0;
    if (check(x) &gt;= 0 &amp;&amp; check(y) &gt;= 0) {
        if (t1 &lt; 0 || t2 &lt; 0) return 0;
        int ans = 2;
        if (same((x - a[0]).len(), K) == 1) ans--;
        if (same((y - a[0]).len(), K) == 1) ans--;
        return ans;
    }
    if (check(x) == 0 || check(y) == 0) return 0;
    return 1;
}
</code></pre>
<h3 id="_108">半平面交</h3>
<pre><code class="language-cpp">Point add1(Point a1, Point a2, Point b1, Point b2) {
    Point t1 = a2 - a1;
    Point t2 = b2 - b1;
    Point t3 = b1 - a1;
    ld t = (t2 / t3) / (t2 / t1);
    t = max(t, - t);
    t1.x *= t;
    t1.y *= t;
    return a1 + t1;
}
void cut(Point x, Point y) {
    a[top + 1] = a[1];
    tot = 0;
    for (int i = 1; i &lt;= top; i++) {
        ld v1 = (a[i] - x) / (a[i] - y);
        ld v2 = (a[i + 1] - x) / (a[i + 1] - y);
        if (v1 &gt;= 0) {
            c[++tot] = a[i];
        }
        if (v1 * v2 &lt; 0) {
            c[++tot] = add1(a[i], a[i + 1], x, y);
        }
    }
    for (int i = 1; i &lt;= tot; i++) {
        a[i] = c[i];
    }
    top = tot;
}
</code></pre>
<h3 id="_109">旋转卡壳</h3>
<pre><code class="language-cpp">double js(int x, int y, int z) {
    return (a[y] - a[x]) / (a[z] - a[x]);
}
double dj(int x, int y, int z) {
    return (a[y] - a[x]) * (a[z] - a[x]);
}
signed() {
    int j = 3, l = 2, r = 2;
    double t1 = 0, t2 = 0, t3 = 0, ans = 1e18;
    point b[4];
    for (int i = 1; i &lt; top; i++) {
        while (js(st[i], st[i + 1], st[j]) &lt;= js (st[i], st[i + 1], st[j % top + 1])) {
            j = j % top + 1;
        }
        while (dj(st[i], st[i + 1], st[r]) &lt;= dj(st[i], st[i + 1], st[r % top + 1])) {
            r = r % top + 1;
        }
        if (i == 1) {
            l = r;
        }
        while (dj(st[i], st[i + 1], st[l]) &gt;= dj(st[i], st[i + 1], st[l % top + 1])) {
            l = l % top + 1;
        }
        t1 = js(st[i], st[i + 1], st[j]);
        t2 = abs((a[st[r]] - a[st[i]]) * (a[st[i + 1]] - a[st[i]])) + 
             abs((a[st[l]] - a[st[i + 1]]) * (a[st[i]] - a[st[i + 1]])) -
             abs((a[st[i + 1]] - a[st[i]]) * (a[st[i]] - a[st[i + 1]]));
        t3 = abs((a[st[i + 1]] - a[st[i]]) * (a[st[i]] - a[st[i + 1]]));
        // cout &lt;&lt; t1 &lt;&lt; ' ';
        // cout &lt;&lt; t2 &lt;&lt; ' ';
        // cout &lt;&lt; t3 &lt;&lt; endl;
        if (ans &gt; t1 * t2 / t3) {
            ans = min(ans, t1 * t2 / t3);
            point mm = a[st[i + 1]] - a[st[i]];
            point m1 = mm;
            double h = t1 / mm.len();
            double ch = ans / h;
            m1.x *= dj(st[i], st[i + 1], st[r]) / (a[st[i + 1]] - a[st[i]]).len() / (a[st[i + 1]] - a[st[i]]).len();
            m1.y *= dj(st[i], st[i + 1], st[r]) / (a[st[i + 1]] - a[st[i]]).len() / (a[st[i + 1]] - a[st[i]]).len();
            b[1] = a[st[i]] + m1;

            mm = mm.xz();
            m1 = mm;
            m1.x *= h / mm.len();
            m1.y *= h / mm.len();
            b[2] = b[1] + m1;

            mm = mm.xz();
            m1 = mm;
            m1.x *= ch / mm.len();
            m1.y *= ch / mm.len();
            b[3] = b[2] + m1;

            mm = mm.xz();
            m1 = mm;
            m1.x *= h / mm.len();
            m1.y *= h / mm.len();
            b[0] = b[3] + m1;

            ans = min(ans, t1 * t2 / t3);
        }
    }
    int id = 0, maxn1 = 1e18;
    printf(&quot;%.5lf\n&quot;, ans);
    for (int i = 0; i &lt; 4; i++) {
        b[i].x += eps;
        b[i].y += eps;
        if (b[i].y &lt; maxn1) {
            id = i;
            maxn1 = b[i].y;
        }
    }
    int nowsum = 0;
    for (int i = id; i &lt; 4; i = (i + 1) % 4) {
        nowsum++;
        if (nowsum == 5) break;
        printf(&quot;%.5lf %.5lf\n&quot;, b[i].x, b[i].y);
    }
}
</code></pre>
<h3 id="_110">闵可夫斯基和</h3>
<pre><code class="language-cpp">vector&lt;Point&gt; Minkowski(vector&lt;Point&gt; t1, vector&lt;Point&gt; t2) {
    vector&lt;Point&gt; A;
    if (t1.size() == 0 || t2.size() == 0) return A;
    for (int i = 1; i &lt; (int)t1.size(); i++) s1[i] = t1[i] - t1[i - 1];
    for (int i = 1; i &lt; (int)t2.size(); i++) s2[i] = t2[i] - t2[i - 1];
    A.push_back(t1[0] + t2[0]);
    int p1 = 1, p2 = 1, tot = 0;
    while(p1 &lt; (int) t1.size() &amp;&amp; p2 &lt; (int) t2.size()) {
        A.push_back((Point){0, 0});
        tot++;
        A[tot] = A[tot - 1] + (s1[p1] / s2[p2] &gt;= 0? s1[p1++] : s2[p2++]);
    }
    while (p1 &lt; (int) t1.size()) {
        A.push_back((Point){0, 0});
        tot++;
        A[tot] = A[tot - 1] + s1[p1++];
    }
    while (p2 &lt; (int)t2.size()) {
        A.push_back((Point){0, 0});
        tot++;
        A[tot] = A[tot - 1] + s2[p2++];
    }
    return A;
}
</code></pre>
<p>```cpp</p>
<h1 id="include">include <bits/stdc++.h></h1>
<p>using namespace std;</p>
<p>using ll = long long;
using vi = vector<int>;
using pii = pair<int, int>;</p>
<h1 id="define-endl-n">define endl '\n'</h1>
<h1 id="define-allx-xbegin-xend">define all(x) (x).begin(), (x).end()</h1>
<h1 id="define-uniquex-xeraseuniqueallx-xend">define UNIQUE(x) (x).erase(unique(all(x)), (x).end())</h1>
<h1 id="define-repit-ff-ee-for-int-it-ff-it-ee-it">define rep(it, ff, ee) for (int it = (ff); it &lt;= (ee); ++it)</h1>
<h1 id="define-perit-ff-ee-for-int-it-ff-it-ee-it">define per(it, ff, ee) for (int it = (ff); it &gt;= (ee); --it)</h1>
<p>int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);</p>
<pre><code>int T;
cin &gt;&gt; T;
while (T--) {
    ll x, m;
    cin &gt;&gt; x &gt;&gt; m;

    ll k = 1;
    while (k &lt;= x) k &lt;&lt;= 1;

    ll ans = 0;
    if (m &lt;= k) {
        rep (y, 1, m) {
            ll p = x ^ y;
            if (p != 0 &amp;&amp; (x % p == 0 || y % p == 0)) ++ans;
        }
        cout &lt;&lt; ans &lt;&lt; endl;
        continue;
    }

    ll y_ = k;
    while (--y_) {
        ll p = x ^ y_;
        if (p != 0 &amp;&amp; (x % p == 0 || y_ % p == 0)) ++ans;
    }

    cout &lt;&lt; ans &lt;&lt; endl;
}

return 0;
</code></pre>
<p>}</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["navigation.tabs"], "search": "../../../assets/javascripts/workers/search.f8cc74c7.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.c8b220af.min.js"></script>
      
    
  </body>
</html>